<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.10.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>infix: The &lt;tt&gt;infix&lt;/tt&gt; FFI Cookbook</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="clipboard.js"></script>
  <script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="version_selector_handler.js"></script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">infix
                  <span id="projectnumber"/>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part --><!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">The &lt;tt&gt;infix&lt;/tt&gt; FFI Cookbook</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md60"></a> This guide provides practical, real-world examples to help you solve common FFI problems and leverage the full power of the <code>infix</code> library. Where the <code>README.md</code> covers concepts, this cookbook provides the code.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note:</b> For a complete reference on the string format used in these examples (e.g., <code>"int"</code>, <code>"{double, double}"</code>, <code>"*char"</code>), please see the <b><a class="el" href="md_signatures.html">Signature Language Reference</a></b>. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md61"></a>
Table of Contents</h1>
<ul>
<li><b>Chapter 1: The Basics (Forward Calls)</b><ul>
<li>Recipe: Calling a Simple C Function</li>
<li>Recipe: Passing and Receiving Pointers</li>
<li>Recipe: Working with Opaque Pointers (Incomplete Types)</li>
<li>Recipe: Working with Fixed-Size Arrays</li>
</ul>
</li>
<li><b>Chapter 2: Handling Complex Data Structures</b><ul>
<li>Recipe: Dynamic Struct Marshalling with the Signature Parser</li>
<li>Recipe: Small Structs Passed by Value</li>
<li>Recipe: Large Structs Passed by Reference</li>
<li>Recipe: Receiving a Struct from a Function</li>
<li>Recipe: Working with Packed Structs</li>
<li>Recipe: Working with Unions</li>
<li>Recipe: Working with Pointers to Arrays</li>
<li>Recipe: Working with Complex Numbers</li>
<li>Recipe: Working with SIMD Vectors</li>
<li>Recipe: Introspecting a Trampoline for a Wrapper</li>
</ul>
</li>
<li><b>Chapter 3: The Power of Callbacks (Reverse Calls)</b><ul>
<li>Recipe: Creating a Stateless Callback for `qsort`</li>
<li>Recipe: Creating a Stateful Callback (The Modern Way)</li>
</ul>
</li>
<li><b>Chapter 4: Advanced Techniques</b><ul>
<li>Recipe: Calling Variadic Functions like `printf`</li>
<li>Recipe: Creating a Variadic Callback</li>
<li>Recipe: Proving Reentrancy with Nested FFI Calls</li>
<li>Recipe: Receiving and Calling a Function Pointer</li>
</ul>
</li>
<li><b>Chapter 5: Interoperability with Other Languages</b><ul>
<li>The Universal Principle: The C ABI</li>
<li>Recipe: Interfacing with a C++ Class</li>
<li>The Pattern for Other Compiled Languages</li>
</ul>
</li>
<li><b>Chapter 6: Calling System Libraries</b><ul>
<li>Recipe: Calling Native System Libraries</li>
</ul>
</li>
<li><b>Chapter 7: Memory Management &amp; Performance</b><ul>
<li>Best Practice: Caching Trampolines</li>
</ul>
</li>
<li><b>Chapter 8: Common Pitfalls &amp; Troubleshooting</b><ul>
<li>Mistake: Passing a Value Instead of a Pointer in `args[]`</li>
<li>Mistake: `infix` Signature Mismatch</li>
<li>Pitfall: Function Pointer Syntax</li>
</ul>
</li>
<li><b>Chapter 9: Building Language Bindings</b><ul>
<li>The Four Pillars of a Language Binding</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md63"></a>
Chapter 1: The Basics (Forward Calls)</h1>
<h2><a class="anchor" id="autotoc_md64"></a>
Recipe: Calling a Simple C Function</h2>
<p><b>Problem</b>: You want to call a standard <a class="el" href="classC.html">C</a> function, like <code>int add(int, int);</code>.</p>
<p><b>Solution</b>: Describe the function's signature using the v1.0 format (<code>"(int32, int32) -&gt; int32"</code>), prepare pointers to your arguments, and invoke the function through the generated trampoline.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The C function we want to call dynamically.</span></div>
<div class="line"><span class="keywordtype">int</span> add_ints(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">    <span class="keywordflow">return</span> a + b;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Describe the signature: int(int, int).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(int32, int32) -&gt; int32&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Generate the trampoline. This is the one-time setup cost.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Prepare arguments. The args array must hold *pointers* to the values.</span></div>
<div class="line">    <span class="keywordtype">int</span> a = 40, b = 2;</div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;a, &amp;b};</div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Get the callable function pointer and invoke it.</span></div>
<div class="line">    <a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a> cif_func = (<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline);</div>
<div class="line">    cif_func((<span class="keywordtype">void</span> *)add_ints, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Result of add_ints(40, 2) is: %d\n&quot;</span>, result);  <span class="comment">// Expected: 42</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Clean up.</span></div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__public__api_html_ga34ef26a155a3861d5172b7c07239ee43"><div class="ttname"><a href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a></div><div class="ttdeci">void(* infix_cif_func)(void *, void *, void **)</div><div class="ttdoc">The signature for a generic forward-call trampoline, the &quot;Call InterFace&quot; function.</div><div class="ttdef"><b>Definition</b> infix.h:440</div></div>
<div class="ttc" id="ainfix_8h_html"><div class="ttname"><a href="infix_8h.html">infix.h</a></div><div class="ttdoc">The main public header for the infix FFI library.</div></div>
<div class="ttc" id="astructinfix__forward__t_html"><div class="ttname"><a href="structinfix__forward__t.html">infix_forward_t</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:69</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
Recipe: Passing and Receiving Pointers</h2>
<p><b>Problem</b>: You need to call a <a class="el" href="classC.html">C</a> function that takes pointers as arguments, like <code>void swap(int* a, int* b);</code>.</p>
<p><b>Solution</b>: Use the <code>*</code> prefix modifier in the signature string (<code>"(*int32, *int32) -&gt; void"</code>). The values you pass in the <code>args</code> array are the addresses of your pointer variables.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A C function that takes pointers and modifies the values they point to.</span></div>
<div class="line"><span class="keywordtype">void</span> swap_ints(<span class="keywordtype">int</span> * a, <span class="keywordtype">int</span> * b) {</div>
<div class="line">    <span class="keywordtype">int</span> temp = *a;</div>
<div class="line">    *a = *b;</div>
<div class="line">    *b = temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Describe the signature: void(int*, int*)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(*int32, *int32) -&gt; void&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare arguments.</span></div>
<div class="line">    <span class="keywordtype">int</span> x = 10, y = 20;</div>
<div class="line">    <span class="keywordtype">int</span> * ptr_x = &amp;x;  <span class="comment">// These pointers are the actual arguments.</span></div>
<div class="line">    <span class="keywordtype">int</span> * ptr_y = &amp;y;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The `args` array for infix must hold the addresses *of our pointer variables*.</span></div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;ptr_x, &amp;ptr_y};</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Before swap: x = %d, y = %d\n&quot;</span>, x, y);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call the function via the trampoline.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)swap_ints, NULL, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;After swap: x = %d, y = %d\n&quot;</span>, x, y);  <span class="comment">// Expected: x = 20, y = 10</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Clean up.</span></div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
Recipe: Working with Opaque Pointers (Incomplete Types)</h2>
<p><b>Problem</b>: You need to interact with a <a class="el" href="classC.html">C</a> library that uses opaque pointers (or "handles") where the internal structure is hidden.</p>
<p><b>Solution</b>: Use the <code>*void</code> signature. This is the canonical representation for a generic handle or opaque pointer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// --- Mock C Library with Opaque Pointers ---</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structmy__handle.html">my_handle</a> { <span class="keywordtype">int</span> value; };</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structmy__handle.html">my_handle</a> <a class="code hl_struct" href="structmy__handle.html">my_handle_t</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structmy__handle.html">my_handle_t</a> * create_handle(<span class="keywordtype">int</span> initial_value) {</div>
<div class="line">    <a class="code hl_struct" href="structmy__handle.html">my_handle_t</a> * h = (<a class="code hl_struct" href="structmy__handle.html">my_handle_t</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="structmy__handle.html">my_handle_t</a>));</div>
<div class="line">    <span class="keywordflow">if</span> (h) { h-&gt;value = initial_value; }</div>
<div class="line">    <span class="keywordflow">return</span> h;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> destroy_handle(<a class="code hl_struct" href="structmy__handle.html">my_handle_t</a> * handle) { free(handle); }</div>
<div class="line"><span class="keywordtype">int</span> get_handle_value(<a class="code hl_struct" href="structmy__handle.html">my_handle_t</a> * handle) { <span class="keywordflow">return</span> handle ? handle-&gt;value : -1; }</div>
<div class="line"><span class="comment">// --- End Mock Library ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Create trampolines for the C API using signatures.</span></div>
<div class="line">    <span class="comment">//    `*void` is the signature for any opaque pointer or handle.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> *t_create, *t_destroy, *t_get;</div>
<div class="line">    infix_forward_create(&amp;t_create, <span class="stringliteral">&quot;(int) -&gt; *void&quot;</span>);</div>
<div class="line">    infix_forward_create(&amp;t_destroy, <span class="stringliteral">&quot;(*void) -&gt; void&quot;</span>);</div>
<div class="line">    infix_forward_create(&amp;t_get, <span class="stringliteral">&quot;(*void) -&gt; int&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Use the API through the trampolines.</span></div>
<div class="line">    <a class="code hl_struct" href="structmy__handle.html">my_handle_t</a> * handle = NULL;</div>
<div class="line">    <span class="keywordtype">int</span> initial_val = 123;</div>
<div class="line">    <span class="keywordtype">void</span> * create_args[] = {&amp;initial_val};</div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_create))((<span class="keywordtype">void</span> *)create_handle, &amp;handle, create_args);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (handle) {</div>
<div class="line">        <span class="keywordtype">int</span> value = 0;</div>
<div class="line">        <span class="keywordtype">void</span> * handle_arg[] = {&amp;handle};</div>
<div class="line">        ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_get))((<span class="keywordtype">void</span> *)get_handle_value, &amp;value, handle_arg);</div>
<div class="line">        printf(<span class="stringliteral">&quot;Value from handle: %d\n&quot;</span>, value);  <span class="comment">// Expected: 123</span></div>
<div class="line"> </div>
<div class="line">        ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_destroy))((<span class="keywordtype">void</span> *)destroy_handle, NULL, handle_arg);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Clean up.</span></div>
<div class="line">    infix_forward_destroy(t_create);</div>
<div class="line">    infix_forward_destroy(t_destroy);</div>
<div class="line">    infix_forward_destroy(t_get);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructmy__handle_html"><div class="ttname"><a href="structmy__handle.html">my_handle</a></div><div class="ttdef"><b>Definition</b> handle_lib.c:5</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md67"></a>
Recipe: Working with Fixed-Size Arrays</h2>
<p><b>Problem</b>: You need to call a function that operates on a fixed-size array, like <code>long long sum_array(long long arr[4]);</code>.</p>
<p><b>Solution</b>: In <a class="el" href="classC.html">C</a>, an array argument "decays" to a pointer to its first element. The signature must reflect this (<code>"(*int64) -&gt; int64"</code>). <code>infix</code> will handle the call correctly.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// In C, a function parameter `arr[4]` is treated as a pointer `arr*`.</span></div>
<div class="line">int64_t sum_array_elements(<span class="keyword">const</span> int64_t * arr) {</div>
<div class="line">    int64_t sum = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) sum += arr[i];</div>
<div class="line">    <span class="keywordflow">return</span> sum;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Signature describes the decayed pointer type: int64_t(const int64_t*)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(*int64) -&gt; int64&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare the array and the pointer to it.</span></div>
<div class="line">    int64_t my_array[] = {10, 20, 30, 40};</div>
<div class="line">    <span class="keyword">const</span> int64_t * ptr_to_array = my_array;</div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;ptr_to_array};</div>
<div class="line">    int64_t result = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Invoke the call.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)sum_array_elements, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Sum of array is: %lld\n&quot;</span>, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)result);  <span class="comment">// Expected: 100</span></div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md69"></a>
Chapter 2: Handling Complex Data Structures</h1>
<h2><a class="anchor" id="autotoc_md70"></a>
Recipe: Dynamic Struct Marshalling with the Signature Parser</h2>
<p><b>Problem</b>: You have data from a dynamic source (e.g., a script) and need to pack it into a <a class="el" href="classC.html">C</a> <code>struct</code> layout at runtime.</p>
<p><b>Solution</b>: Use <code>infix_type_from_signature</code> to parse a signature string into a detailed <code>infix_type</code> graph. This graph contains all the <code>size</code>, <code>alignment</code>, and member <code>offset</code> information needed to correctly write data into a C-compatible memory buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stddef.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The C struct we want to pack data into.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    int32_t user_id;</div>
<div class="line">    <span class="keywordtype">double</span> score;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line">} <a class="code hl_struct" href="structUserProfile.html">UserProfile</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function dynamically packs data into a buffer according to the signature.</span></div>
<div class="line"><span class="keywordtype">void</span> marshal_ordered_data(<span class="keywordtype">void</span> * dest_buffer, <span class="keyword">const</span> <span class="keywordtype">char</span> * signature, <span class="keywordtype">void</span> ** source_values) {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__type__t.html">infix_type</a> * struct_type = NULL;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__arena__t.html">infix_arena_t</a> * arena = NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. Parse the signature to get the type layout information.</span></div>
<div class="line">    <span class="keywordflow">if</span> (infix_type_from_signature(&amp;struct_type, &amp;arena, signature) != <a class="code hl_enumvalue" href="group__public__api.html#gga8643667be6ea1ef9269c2e46d8f11ff7ae50c34a24362f9364b4b20ef29d259da">INFIX_SUCCESS</a>) {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Failed to parse signature.\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Iterate through the members described by the parsed type.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; infix_type_get_member_count(struct_type); ++i) {</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_struct" href="structinfix__struct__member__t.html">infix_struct_member</a> * member = infix_type_get_member(struct_type, i);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 3. Copy the source data to the correct offset in the destination buffer.</span></div>
<div class="line">        memcpy((<span class="keywordtype">char</span> *)dest_buffer + member-&gt;<a class="code hl_variable" href="structinfix__struct__member__t.html#abc9fb3780626694111f4c8c74700a9b9">offset</a>, source_values[i], infix_type_get_size(member-&gt;<a class="code hl_variable" href="structinfix__struct__member__t.html#aa89e6621da98f5115dcc807599c4ac77">type</a>));</div>
<div class="line">    }</div>
<div class="line">    infix_arena_destroy(arena);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordtype">void</span> * my_data[] = {</div>
<div class="line">        &amp;(int32_t){123},</div>
<div class="line">        &amp;(double){98.6},</div>
<div class="line">        &amp;(<span class="keyword">const</span> <span class="keywordtype">char</span> *){<span class="stringliteral">&quot;Sanko&quot;</span>}</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * profile_sig = <span class="stringliteral">&quot;{id:int32, score:double, name:*char}&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structUserProfile.html">UserProfile</a> profile_buffer = {0};</div>
<div class="line">    marshal_ordered_data(&amp;profile_buffer, profile_sig, my_data);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Resulting C struct:\n  user_id: %d\n  score:   %f\n  name:    %s\n&quot;</span>,</div>
<div class="line">           profile_buffer.user_id, profile_buffer.score, profile_buffer.name);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__public__api_html_gga8643667be6ea1ef9269c2e46d8f11ff7ae50c34a24362f9364b4b20ef29d259da"><div class="ttname"><a href="group__public__api.html#gga8643667be6ea1ef9269c2e46d8f11ff7ae50c34a24362f9364b4b20ef29d259da">INFIX_SUCCESS</a></div><div class="ttdeci">@ INFIX_SUCCESS</div><div class="ttdoc">The operation completed successfully.</div><div class="ttdef"><b>Definition</b> infix.h:446</div></div>
<div class="ttc" id="astructUserProfile_html"><div class="ttname"><a href="structUserProfile.html">UserProfile</a></div><div class="ttdef"><b>Definition</b> 05_dynamic_marshalling.c:14</div></div>
<div class="ttc" id="astructinfix__arena__t_html"><div class="ttname"><a href="structinfix__arena__t.html">infix_arena_t</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:112</div></div>
<div class="ttc" id="astructinfix__struct__member__t_html"><div class="ttname"><a href="structinfix__struct__member__t.html">infix_struct_member_t</a></div><div class="ttdoc">Describes a single member of an aggregate type (struct or union).</div><div class="ttdef"><b>Definition</b> infix.h:317</div></div>
<div class="ttc" id="astructinfix__struct__member__t_html_aa89e6621da98f5115dcc807599c4ac77"><div class="ttname"><a href="structinfix__struct__member__t.html#aa89e6621da98f5115dcc807599c4ac77">infix_struct_member_t::type</a></div><div class="ttdeci">infix_type * type</div><div class="ttdoc">An infix_type describing the member's type.</div><div class="ttdef"><b>Definition</b> infix.h:319</div></div>
<div class="ttc" id="astructinfix__struct__member__t_html_abc9fb3780626694111f4c8c74700a9b9"><div class="ttname"><a href="structinfix__struct__member__t.html#abc9fb3780626694111f4c8c74700a9b9">infix_struct_member_t::offset</a></div><div class="ttdeci">size_t offset</div><div class="ttdoc">The byte offset of the member from the start of the aggregate.</div><div class="ttdef"><b>Definition</b> infix.h:320</div></div>
<div class="ttc" id="astructinfix__type__t_html"><div class="ttname"><a href="structinfix__type__t.html">infix_type_t</a></div><div class="ttdoc">The central structure for describing any data type in the FFI system.</div><div class="ttdef"><b>Definition</b> infix.h:261</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md71"></a>
Recipe: Small Structs Passed by Value</h2>
<p><b>Problem</b>: You need to call a function that takes a small <code>struct</code> that the ABI passes in registers.</p>
<p><b>Solution</b>: Use the anonymous struct syntax <code>({...})</code>. <code>infix</code> will automatically determine the correct ABI passing convention.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">double</span> x; <span class="keywordtype">double</span> y; } <a class="code hl_struct" href="structPoint.html">Point</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A C function that takes a small struct by value.</span></div>
<div class="line"><span class="keywordtype">double</span> process_point(<a class="code hl_struct" href="structPoint.html">Point</a> p) {</div>
<div class="line">    <span class="keywordflow">return</span> p.x + p.y;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Describe the signature: double(Point).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;({double, double}) -&gt; double&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare the struct argument.</span></div>
<div class="line">    <a class="code hl_struct" href="structPoint.html">Point</a> p = {1.5, 2.5};</div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;p};</div>
<div class="line">    <span class="keywordtype">double</span> result = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call the function.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)process_point, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Result is: %f\n&quot;</span>, result);  <span class="comment">// Expected: 4.0</span></div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructPoint_html"><div class="ttname"><a href="structPoint.html">Point</a></div><div class="ttdoc">A simple struct with two doubles. Small enough to be passed in registers on some ABIs.</div><div class="ttdef"><b>Definition</b> types.h:13</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md72"></a>
Recipe: Large Structs Passed by Reference</h2>
<p><b>Problem</b>: <a class="el" href="classA.html">A</a> function takes a struct that is too large to fit in registers.</p>
<p><b>Solution</b>: The process is identical to the small struct example. <code>infix</code>'s ABI logic will detect that the struct is large and automatically pass it by reference (by passing a pointer).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">int</span> a, b, c, d, e, f; } <a class="code hl_struct" href="structLargeStruct.html">LargeStruct</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A C function that takes a large struct. The ABI will pass it by reference.</span></div>
<div class="line"><span class="keywordtype">int</span> sum_large_struct_fields(<a class="code hl_struct" href="structLargeStruct.html">LargeStruct</a> s) {</div>
<div class="line">    <span class="keywordflow">return</span> s.a + s.f;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Signature: int(LargeStruct).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;({int,int,int,int,int,int}) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. The process is identical. `infix` handles the pass-by-reference detail.</span></div>
<div class="line">    <a class="code hl_struct" href="structLargeStruct.html">LargeStruct</a> data = {10, 20, 30, 40, 50, 60};</div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;data};</div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line"> </div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)sum_large_struct_fields, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Result is: %d\n&quot;</span>, result);  <span class="comment">// Expected: 70</span></div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructLargeStruct_html"><div class="ttname"><a href="structLargeStruct.html">LargeStruct</a></div><div class="ttdoc">A struct larger than 16 bytes, guaranteed to be passed by reference.</div><div class="ttdef"><b>Definition</b> types.h:22</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md73"></a>
Recipe: Receiving a Struct from a Function</h2>
<p><b>Problem</b>: You need to call a function that <em>returns</em> a struct by value.</p>
<p><b>Solution</b>: Simply use the struct signature as the return type (e.g., <code>"() -&gt; {double, double}"</code>).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">double</span> x; <span class="keywordtype">double</span> y; } <a class="code hl_struct" href="structPoint.html">Point</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A C function that returns a struct by value.</span></div>
<div class="line"><a class="code hl_struct" href="structPoint.html">Point</a> create_point() {</div>
<div class="line">    <span class="keywordflow">return</span> (<a class="code hl_struct" href="structPoint.html">Point</a>){100.0, 200.0};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Signature: Point(void).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;() -&gt; {double, double}&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare a buffer to receive the returned struct.</span></div>
<div class="line">    <a class="code hl_struct" href="structPoint.html">Point</a> result_point;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call the function.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)create_point, &amp;result_point, NULL);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Returned point: (%f, %f)\n&quot;</span>, result_point.x, result_point.y);</div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md74"></a>
Recipe: Working with Packed Structs</h2>
<p><b>Problem</b>: You need to call a <a class="el" href="classC.html">C</a> function that takes a packed struct.</p>
<p><b>Solution</b>: Use the <code>!{...}</code> syntax. The <code>!</code> prefix tells <code>infix</code> to use a packed layout with 1-byte alignment. For other alignments, use <code>!N:{...}</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma pack(push, 1)</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">char</span> a; uint64_t b; } <a class="code hl_struct" href="structPackedStruct.html">PackedStruct</a>;</div>
<div class="line"><span class="preprocessor">#pragma pack(pop)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> process_packed(<a class="code hl_struct" href="structPackedStruct.html">PackedStruct</a> p) {</div>
<div class="line">    <span class="keywordflow">return</span> (p.a == <span class="charliteral">&#39;X&#39;</span> &amp;&amp; p.b == 0x1122334455667788ULL) ? 42 : -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Describe the packed struct using the `!{...}` syntax.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(!{char, uint64}) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare arguments and call.</span></div>
<div class="line">    <a class="code hl_struct" href="structPackedStruct.html">PackedStruct</a> data = {<span class="charliteral">&#39;X&#39;</span>, 0x1122334455667788ULL};</div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;data};</div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)process_packed, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Packed struct result: %d\n&quot;</span>, result);  <span class="comment">// Expected: 42</span></div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructPackedStruct_html"><div class="ttname"><a href="structPackedStruct.html">PackedStruct</a></div><div class="ttdoc">A struct with a non-standard, packed memory layout.</div><div class="ttdef"><b>Definition</b> types.h:42</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md75"></a>
Recipe: Working with Unions</h2>
<p><b>Problem</b>: You need to call a function that passes or returns a <code>union</code>.</p>
<p><b>Solution</b>: Use the <code>&lt;...&gt;</code> syntax to describe the union.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span>{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; } <a class="code hl_union" href="unionNumber.html">Number</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> process_number_as_int(<a class="code hl_union" href="unionNumber.html">Number</a> n) {</div>
<div class="line">    <span class="keywordflow">return</span> n.i * 2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Signature for int(Number).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(&lt;int, float&gt;) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare the union argument.</span></div>
<div class="line">    <a class="code hl_union" href="unionNumber.html">Number</a> num_val;</div>
<div class="line">    num_val.i = 21;</div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;num_val};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call the function.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)process_number_as_int, &amp;result, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Result: %d\n&quot;</span>, result);  <span class="comment">// Expected: 42</span></div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aunionNumber_html"><div class="ttname"><a href="unionNumber.html">Number</a></div><div class="ttdoc">A simple union of an integer and a float.</div><div class="ttdef"><b>Definition</b> types.h:30</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md76"></a>
Recipe: Working with Pointers to Arrays</h2>
<p><b>Problem</b>: You need to call a function that takes a pointer to a fixed-size array, like <code>void process_matrix(int (*matrix)[4]);</code>.</p>
<p><b>Solution</b>: Use the pointer prefix <code>*</code> on an array type (<code>*[4:int32]</code>).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function expects a pointer to an array of 4 integers.</span></div>
<div class="line"><span class="keywordtype">void</span> process_matrix_row(<span class="keywordtype">int</span> (*row_ptr)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Processing row: &quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;%d &quot;</span>, (*row_ptr)[i]);</div>
<div class="line">    }</div>
<div class="line">    printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Signature for void(int(*)).</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(*[4:int32]) -&gt; void&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare arguments.</span></div>
<div class="line">    <span class="keywordtype">int</span> matrix = {{1, 2, 3, 4}, {5, 6, 7, 8}};</div>
<div class="line">    int(*ptr_to_first_row) = &amp;matrix;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;ptr_to_first_row};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call the function.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)process_matrix_row, NULL, args);</div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md77"></a>
Recipe: Working with Complex Numbers</h2>
<p><b>Problem</b>: You need to call a <a class="el" href="classC.html">C</a> function that uses <code>_Complex</code> types.</p>
<p><b>Solution</b>: Use the <code>c[...]</code> constructor in the signature string.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;complex.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> complex c_square(<span class="keywordtype">double</span> complex z) {</div>
<div class="line">    <span class="keywordflow">return</span> z * z;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Signature for: double complex(double complex)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(c[double]) -&gt; c[double]&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare arguments.</span></div>
<div class="line">    <span class="keywordtype">double</span> complex input = 3.0 + 4.0 * I;</div>
<div class="line">    <span class="keywordtype">double</span> complex result;</div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;input};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call the function.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)c_square, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;The square of (3.0 + 4.0i) is (%.1f + %.1fi)\n&quot;</span>, creal(result), cimag(result));</div>
<div class="line">    <span class="comment">// Expected: -7.0 + 24.0i</span></div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md78"></a>
Recipe: Working with SIMD Vectors</h2>
<p><b>Problem</b>: You need to call a high-performance <a class="el" href="classC.html">C</a> function that uses SIMD vector types (like SSE's <code>__m128d</code>).</p>
<p><b>Solution</b>: Use the <code>v[&lt;N&gt;:&lt;type&gt;]</code> syntax. The ABI logic will ensure the vector is correctly passed in a SIMD register (e.g., XMM on x86-64).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;emmintrin.h&gt;</span> <span class="comment">// For SSE2 intrinsics like __m128d</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A C function that takes two SSE vectors and returns their dot product.</span></div>
<div class="line"><span class="keywordtype">double</span> dot_product(__m128d v1, __m128d v2) {</div>
<div class="line">    __m128d xy = _mm_mul_pd(v1, v2);</div>
<div class="line">    __m128d temp = _mm_shuffle_pd(xy, xy, 1);</div>
<div class="line">    __m128d sum = _mm_add_pd(xy, temp);</div>
<div class="line">    <span class="keywordflow">return</span> _mm_cvtsd_f64(sum);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Signature for: double( __m128d, __m128d )</span></div>
<div class="line">    <span class="comment">//    An __m128d is a vector of 2 doubles, so the signature is v[2:double].</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(v[2:double], v[2:double]) -&gt; double&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare the vector arguments.</span></div>
<div class="line">    __m128d vec1 = _mm_set_pd(2.0, 3.0); <span class="comment">// Creates vector [3.0, 2.0]</span></div>
<div class="line">    __m128d vec2 = _mm_set_pd(4.0, 5.0); <span class="comment">// Creates vector [5.0, 4.0]</span></div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;vec1, &amp;vec2};</div>
<div class="line">    <span class="keywordtype">double</span> result = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call the function.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)dot_product, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Dot product is (3.0 * 5.0) + (2.0 * 4.0) = 15.0 + 8.0 = 23.0</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;Dot product is: %f\n&quot;</span>, result); <span class="comment">// Expected: 23.0</span></div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md79"></a>
Recipe: Introspecting a Trampoline for a Wrapper</h2>
<p><b>Problem</b>: You are building a language binding and need to verify the number and types of arguments provided by the user at call time.</p>
<p><b>Solution</b>: Use the forward trampoline introspection API to query the signature information.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A dynamic wrapper that uses the introspection API to validate arguments.</span></div>
<div class="line"><span class="keywordtype">void</span> dynamic_wrapper(<a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline, <span class="keywordtype">void</span>* target_func, <span class="keywordtype">void</span>** args, <span class="keywordtype">size_t</span> num_provided_args) {</div>
<div class="line">    <span class="keywordtype">size_t</span> num_expected_args = infix_forward_get_num_args(trampoline);</div>
<div class="line">    <span class="keywordflow">if</span> (num_provided_args != num_expected_args) {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Error: Expected %zu arguments, but got %zu.\n&quot;</span>, num_expected_args, num_provided_args);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// A real binding would also check the types of the provided arguments.</span></div>
<div class="line"> </div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))(target_func, NULL, args);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_c_func(<span class="keywordtype">int</span> a, <span class="keywordtype">double</span> b) { printf(<span class="stringliteral">&quot;my_c_func called with: %d, %f\n&quot;</span>, a, b); }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, <span class="stringliteral">&quot;(int32, double) -&gt; void&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> arg1 = 42;</div>
<div class="line">    <span class="keywordtype">double</span> arg2 = 3.14;</div>
<div class="line">    <span class="keywordtype">void</span>* good_args[] = {&amp;arg1, &amp;arg2};</div>
<div class="line"> </div>
<div class="line">    dynamic_wrapper(trampoline, (<span class="keywordtype">void</span>*)my_c_func, good_args, 2);</div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md81"></a>
Chapter 3: The Power of Callbacks (Reverse Calls)</h1>
<h2><a class="anchor" id="autotoc_md82"></a>
Recipe: Creating a Stateless Callback for <code>qsort</code></h2>
<p><b>Problem</b>: You need to sort an array using <a class="el" href="classC.html">C</a>'s <code>qsort</code>, which requires a function pointer for the comparison logic.</p>
<p><b>Solution</b>: Use a reverse trampoline. The handler's signature must accept <code>infix_context_t*</code> as its first argument and a pointer for the return value.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// qsort expects: int(const void*, const void*)</span></div>
<div class="line"><span class="comment">// Our handler is: void(infix_context_t*, int*, const void*, const void*)</span></div>
<div class="line"><span class="keywordtype">void</span> compare_ints_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a> * context, <span class="keywordtype">int</span>* retval, <span class="keyword">const</span> <span class="keywordtype">void</span> * a, <span class="keyword">const</span> <span class="keywordtype">void</span> * b) {</div>
<div class="line">    (void)context;</div>
<div class="line">    <span class="keywordtype">int</span> int_a = *(<span class="keyword">const</span> <span class="keywordtype">int</span> *)a;</div>
<div class="line">    <span class="keywordtype">int</span> int_b = *(<span class="keyword">const</span> <span class="keywordtype">int</span> *)b;</div>
<div class="line">    *retval = (int_a &gt; int_b) - (int_a &lt; int_b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Describe the signature `qsort` expects.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * qsort_compare_sig = <span class="stringliteral">&quot;(*void, *void) -&gt; int32&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a> * rt = NULL;</div>
<div class="line">    infix_reverse_create(&amp;rt, qsort_compare_sig, (<span class="keywordtype">void</span> *)compare_ints_handler, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Get the native, callable function pointer.</span></div>
<div class="line">    int (*comparison_func_ptr)(<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *) =</div>
<div class="line">        (<span class="keywordtype">int</span> (*)(<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *))infix_reverse_get_code(rt);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call `qsort` with our generated function pointer.</span></div>
<div class="line">    <span class="keywordtype">int</span> numbers[] = {5, 2, 8, 1, 9};</div>
<div class="line">    qsort(numbers, 5, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), comparison_func_ptr);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Sorted numbers: 1 2 5 8 9\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    infix_reverse_destroy(rt);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructinfix__reverse__t_html"><div class="ttname"><a href="structinfix__reverse__t.html">infix_reverse_t</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:92</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md83"></a>
Recipe: Creating a Stateful Callback (The Modern Way)</h2>
<p><b>Problem</b>: <a class="el" href="classA.html">A</a> callback handler needs access to application state, but the <a class="el" href="classC.html">C</a> library API is stateless.</p>
<p><b>Solution</b>: <code>infix</code> automatically passes a pointer to the <code>infix_context_t</code> as the <b>first argument</b> to every <a class="el" href="classC.html">C</a> callback handler. Retrieve your application state from the context's <code>user_data</code> field.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A mock C library with a stateless callback API.</span></div>
<div class="line"><span class="keyword">typedef</span> void (*item_processor_t)(<span class="keywordtype">int</span> item_value);</div>
<div class="line"><span class="keywordtype">void</span> process_list(<span class="keywordtype">int</span> * items, <span class="keywordtype">int</span> count, item_processor_t process_func) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i)  process_func(items[i]);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> * name; <span class="keywordtype">int</span> sum; } <a class="code hl_struct" href="structAppContext.html">AppContext</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Our handler receives the context as its first argument.</span></div>
<div class="line"><span class="keywordtype">void</span> my_stateful_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a> * context, <span class="keywordtype">int</span> item_value) {</div>
<div class="line">    <span class="comment">// Retrieve our application&#39;s state from the user_data pointer!</span></div>
<div class="line">    <a class="code hl_struct" href="structAppContext.html">AppContext</a> * ctx = (<a class="code hl_struct" href="structAppContext.html">AppContext</a> *)infix_reverse_get_user_data(context);</div>
<div class="line">    ctx-&gt;sum += item_value;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_struct" href="structAppContext.html">AppContext</a> ctx = {<span class="stringliteral">&quot;My List&quot;</span>, 0};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. Create a reverse trampoline, passing a pointer to our AppContext as user_data.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a> * rt = NULL;</div>
<div class="line">    infix_reverse_create(&amp;rt, <span class="stringliteral">&quot;(int) -&gt; void&quot;</span>, (<span class="keywordtype">void</span> *)my_stateful_handler, &amp;ctx);</div>
<div class="line"> </div>
<div class="line">    item_processor_t processor_ptr = (item_processor_t)infix_reverse_get_code(rt);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Call the C library.</span></div>
<div class="line">    <span class="keywordtype">int</span> list[] = {10, 20, 30};</div>
<div class="line">    process_list(list, 3, processor_ptr);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Final sum: %d\n&quot;</span>, ctx.sum);  <span class="comment">// Expected: 60</span></div>
<div class="line"> </div>
<div class="line">    infix_reverse_destroy(rt);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructAppContext_html"><div class="ttname"><a href="structAppContext.html">AppContext</a></div><div class="ttdef"><b>Definition</b> 13_stateful_callback.c:19</div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md85"></a>
Chapter 4: Advanced Techniques</h1>
<h2><a class="anchor" id="autotoc_md86"></a>
Recipe: Calling Variadic Functions like <code>printf</code></h2>
<p><b>Problem</b>: You need to call a function with a variable number of arguments.</p>
<p><b>Solution</b>: Use the <code>;</code> token to separate fixed and variadic arguments in the signature.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// 1. Describe the *specific instance* of the call:</span></div>
<div class="line">    <span class="comment">//    int printf(const char* format, int, const char*);</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(*char; int, *char) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * trampoline = NULL;</div>
<div class="line">    infix_forward_create(&amp;trampoline, signature);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Prepare arguments for this specific call.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * fmt = <span class="stringliteral">&quot;Number: %d, String: %s\n&quot;</span>;</div>
<div class="line">    <span class="keywordtype">int</span> val = 123;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * str = <span class="stringliteral">&quot;test&quot;</span>;</div>
<div class="line">    <span class="keywordtype">void</span> * args[] = {&amp;fmt, &amp;val, &amp;str};</div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Call printf through the trampoline.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(trampoline))((<span class="keywordtype">void</span> *)printf, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;printf returned %d\n&quot;</span>, result);</div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(trampoline);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md87"></a>
Recipe: Creating a Variadic Callback</h2>
<p><b>Problem</b>: You need to create a native function pointer for a handler that is itself variadic.</p>
<p><b>Solution</b>: Your <a class="el" href="classC.html">C</a> handler will use <code>&lt;stdarg.h&gt;</code>. The <code>infix</code> signature includes the <code>;</code> token after the fixed arguments.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdarg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Our C handler is itself variadic.</span></div>
<div class="line"><span class="keywordtype">void</span> my_logger(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a> * context, <span class="keyword">const</span> <span class="keywordtype">char</span> * level, <span class="keyword">const</span> <span class="keywordtype">char</span> * format, ...) {</div>
<div class="line">    (void)context;</div>
<div class="line">    printf(<span class="stringliteral">&quot;[%s] &quot;</span>, level);</div>
<div class="line">    va_list args;</div>
<div class="line">    va_start(args, format);</div>
<div class="line">    vprintf(format, args);</div>
<div class="line">    va_end(args);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> void (*log_func_t)(<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, ...);</div>
<div class="line"><span class="keywordtype">void</span> run_logger(log_func_t logger) {</div>
<div class="line">    logger(<span class="stringliteral">&quot;INFO&quot;</span>, <span class="stringliteral">&quot;User logged in with ID %d\n&quot;</span>, 42);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// The semicolon indicates where the variadic arguments begin.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * signature = <span class="stringliteral">&quot;(*char, *char; int) -&gt; void&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a> * rt = NULL;</div>
<div class="line">    infix_reverse_create(&amp;rt, signature, (<span class="keywordtype">void</span> *)my_logger, NULL);</div>
<div class="line"> </div>
<div class="line">    run_logger((log_func_t)infix_reverse_get_code(rt));</div>
<div class="line"> </div>
<div class="line">    infix_reverse_destroy(rt);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md88"></a>
Recipe: Proving Reentrancy with Nested FFI Calls</h2>
<p><b>Problem</b>: You need to call a <a class="el" href="classC.html">C</a> function that takes a callback, and inside that callback handler, you need to call <em>another</em> <a class="el" href="classC.html">C</a> function using <code>infix</code>.</p>
<p><b>Solution</b>: <code>infix</code> is fully reentrant. Create all necessary trampolines upfront and use them as needed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// --- Mock C Library ---</span></div>
<div class="line"><span class="keyword">static</span> void (*g_handler)(int) = NULL;</div>
<div class="line"><span class="keywordtype">void</span> log_event(<span class="keyword">const</span> <span class="keywordtype">char</span> * msg) { printf(<span class="stringliteral">&quot;C Log: %s\n&quot;</span>, msg); }</div>
<div class="line"><span class="keywordtype">void</span> register_handler(<span class="keywordtype">void</span> (*h)(<span class="keywordtype">int</span>)) { g_handler = h; }</div>
<div class="line"><span class="keywordtype">void</span> run_loop() { <span class="keywordflow">if</span> (g_handler) g_handler(42); }</div>
<div class="line"><span class="comment">// --- End Mock ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * g_log_trampoline = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Our callback handler.</span></div>
<div class="line"><span class="keywordtype">void</span> my_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a> * context, <span class="keywordtype">int</span> event_code) {</div>
<div class="line">    (void)context;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * log_msg = <span class="stringliteral">&quot;Event processed inside handler.&quot;</span>;</div>
<div class="line">    <span class="keywordtype">void</span> * log_args[] = {&amp;log_msg};</div>
<div class="line">    <span class="comment">// Nested call: a forward FFI call made from within a reverse FFI call.</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(g_log_trampoline))((<span class="keywordtype">void</span> *)log_event, NULL, log_args);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    infix_forward_create(&amp;g_log_trampoline, <span class="stringliteral">&quot;(*char) -&gt; void&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a> * rt = NULL;</div>
<div class="line">    infix_reverse_create(&amp;rt, <span class="stringliteral">&quot;(int) -&gt; void&quot;</span>, (<span class="keywordtype">void</span> *)my_handler, NULL);</div>
<div class="line">    <span class="keywordtype">void</span> * handler_ptr = infix_reverse_get_code(rt);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> *t_register, *t_run;</div>
<div class="line">    <span class="comment">// Signature for register_handler: void(void(*)(int))</span></div>
<div class="line">    infix_forward_create(&amp;t_register, <span class="stringliteral">&quot;(*((int) -&gt; void)) -&gt; void&quot;</span>);</div>
<div class="line">    infix_forward_create(&amp;t_run, <span class="stringliteral">&quot;() -&gt; void&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_register))((<span class="keywordtype">void</span> *)register_handler, NULL, &amp;handler_ptr);</div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_run))((<span class="keywordtype">void</span> *)run_loop, NULL, NULL);</div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(g_log_trampoline);</div>
<div class="line">    infix_reverse_destroy(rt);</div>
<div class="line">    infix_forward_destroy(t_register);</div>
<div class="line">    infix_forward_destroy(t_run);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md89"></a>
Recipe: Receiving and Calling a Function Pointer</h2>
<p><b>Problem</b>: You need to call a factory function that returns a pointer to another function, which you then need to call.</p>
<p><b>Solution</b>: Use two reverse trampolines. The "provider" callback returns a pointer to the "worker" callback. The signature for a function pointer is <code>*((...)-&gt;...)</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> final_multiply_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a> * context, <span class="keywordtype">int</span>* retval, <span class="keywordtype">int</span> val) {</div>
<div class="line">    (void)context;</div>
<div class="line">    *retval = val * 10;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> callback_provider_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a> * context, <span class="keywordtype">void</span>** retval) {</div>
<div class="line">    *retval = infix_reverse_get_user_data(context);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> int (*worker_func_t)(int);</div>
<div class="line"><span class="keyword">typedef</span> worker_func_t (*provider_func_t)(void);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> call_harness(provider_func_t provider, <span class="keywordtype">int</span> input_val) {</div>
<div class="line">    worker_func_t worker = provider();</div>
<div class="line">    <span class="keywordflow">return</span> worker(input_val);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a> * worker_rt = NULL;</div>
<div class="line">    infix_reverse_create(&amp;worker_rt, <span class="stringliteral">&quot;(int) -&gt; int&quot;</span>, (<span class="keywordtype">void</span> *)final_multiply_handler, NULL);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a> * provider_rt = NULL;</div>
<div class="line">    <span class="keywordtype">void</span> * worker_ptr = infix_reverse_get_code(worker_rt);</div>
<div class="line">    infix_reverse_create(&amp;provider_rt, <span class="stringliteral">&quot;() -&gt; *void&quot;</span>, (<span class="keywordtype">void</span> *)callback_provider_handler, worker_ptr);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * harness_sig = <span class="stringliteral">&quot;(*(() -&gt; *void), int) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * harness_ft = NULL;</div>
<div class="line">    infix_forward_create(&amp;harness_ft, harness_sig);</div>
<div class="line"> </div>
<div class="line">    provider_func_t provider_ptr = (provider_func_t)infix_reverse_get_code(provider_rt);</div>
<div class="line">    <span class="keywordtype">int</span> input = 7;</div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line">    <span class="keywordtype">void</span> * harness_args[] = {&amp;provider_ptr, &amp;input};</div>
<div class="line"> </div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(harness_ft))((<span class="keywordtype">void</span> *)call_harness, &amp;result, harness_args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Final result: %d\n&quot;</span>, result);  <span class="comment">// Expected: 70</span></div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(harness_ft);</div>
<div class="line">    infix_reverse_destroy(provider_rt);</div>
<div class="line">    infix_reverse_destroy(worker_rt);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md91"></a>
Chapter 5: Interoperability with Other Languages</h1>
<h2><a class="anchor" id="autotoc_md92"></a>
The Universal Principle: The C ABI</h2>
<p>It is possible to call a function written in Rust, Fortran, or C++ from <a class="el" href="classC.html">C</a> because of a shared standard: the <b><a class="el" href="classC.html">C</a> Application Binary Interface (ABI)</b>. Nearly every compiled language provides a mechanism to expose a function using the <a class="el" href="classC.html">C</a> ABI. Once you have a C-compatible function pointer, <code>infix</code> can call it.</p>
<h2><a class="anchor" id="autotoc_md93"></a>
Recipe: Interfacing with a C++ Class</h2>
<p><b>Problem</b>: You need to create, use, and destroy a C++ object from a pure <a class="el" href="classC.html">C</a> environment.</p>
<p><b>Solution</b>: Create a simple C-style API in your C++ code using <code>extern "C"</code>. <code>infix</code> can then call this clean, predictable API, using <code>*void</code> as the opaque handle for the object pointer.</p>
<div class="fragment"><div class="line"><span class="comment">// File: lib/counter.hpp</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><span class="keyword">class </span>Counter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Counter();</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="restypedef_8cpp.html#a102acaaa258e937adf910898c6133545">add</a>(<span class="keywordtype">int</span> value);</div>
<div class="line">    <span class="keywordtype">int</span> get() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> count;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Counter Counter;</div>
<div class="line">Counter * Counter_create();</div>
<div class="line"><span class="keywordtype">void</span> Counter_destroy(Counter * c);</div>
<div class="line"><span class="keywordtype">void</span> Counter_add(Counter * c, <span class="keywordtype">int</span> value);</div>
<div class="line"><span class="keywordtype">int</span> Counter_get(Counter * c);</div>
<div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// File: 18_cpp_example.c</span></div>
<div class="line"><span class="preprocessor">#include &quot;lib/counter.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> *t_create, *t_destroy, *t_add, *t_get;</div>
<div class="line">    infix_forward_create(&amp;t_create, <span class="stringliteral">&quot;() -&gt; *void&quot;</span>);</div>
<div class="line">    infix_forward_create(&amp;t_destroy, <span class="stringliteral">&quot;(*void) -&gt; void&quot;</span>);</div>
<div class="line">    infix_forward_create(&amp;t_add, <span class="stringliteral">&quot;(*void, int) -&gt; void&quot;</span>);</div>
<div class="line">    infix_forward_create(&amp;t_get, <span class="stringliteral">&quot;(*void) -&gt; int&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    Counter * counter_obj = NULL;</div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_create))((<span class="keywordtype">void</span> *)Counter_create, &amp;counter_obj, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (counter_obj) {</div>
<div class="line">        <span class="keywordtype">int</span> val_to_add = 50;</div>
<div class="line">        <span class="keywordtype">void</span> * add_args[] = {&amp;counter_obj, &amp;val_to_add};</div>
<div class="line">        ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_add))((<span class="keywordtype">void</span> *)Counter_add, NULL, add_args);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">int</span> final_val = 0;</div>
<div class="line">        <span class="keywordtype">void</span> * get_args[] = {&amp;counter_obj};</div>
<div class="line">        ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_get))((<span class="keywordtype">void</span> *)Counter_get, &amp;final_val, get_args);</div>
<div class="line">        printf(<span class="stringliteral">&quot;[C] Final value from C++ object: %d\n&quot;</span>, final_val);</div>
<div class="line"> </div>
<div class="line">        ((<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t_destroy))((<span class="keywordtype">void</span> *)Counter_destroy, NULL, get_args);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    infix_forward_destroy(t_create); <span class="comment">/* ... destroy others ... */</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="arestypedef_8cpp_html_a102acaaa258e937adf910898c6133545"><div class="ttname"><a href="restypedef_8cpp.html#a102acaaa258e937adf910898c6133545">add</a></div><div class="ttdeci">Coord add(Coord c1, Coord c2)</div><div class="ttdef"><b>Definition</b> restypedef.cpp:23</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md94"></a>
The Pattern for Other Compiled Languages</h2>
<p>The following examples demonstrate how to export a simple <code>int add(int, int)</code> function from a shared library. The <code>infix</code> <a class="el" href="classC.html">C</a> code is nearly identical in every case, highlighting the power of the <a class="el" href="classC.html">C</a> ABI.</p>
<h3><a class="anchor" id="autotoc_md95"></a>
Rust</h3>
<div class="fragment"><div class="line">// librust_math.rs</div>
<div class="line">#[no_mangle]</div>
<div class="line">pub extern &quot;C&quot; fn rust_add(a: i32, b: i32) -&gt; i32 {</div>
<div class="line">    a + b</div>
<div class="line">}</div>
</div><!-- fragment --><p> <em>Compile with: <code>rustc --crate-type cdylib librust_math.rs</code></em></p>
<h3><a class="anchor" id="autotoc_md96"></a>
Fortran</h3>
<div class="fragment"><div class="line"><span class="comment">! libfortran_math.f90</span></div>
<div class="line"><span class="keyword">function </span>fortran_add(a, b) <span class="keyword">result</span>(c) bind(C, name=&#39;fortran_add&#39;)</div>
<div class="line">    <span class="keywordtype">use </span>iso_c_binding</div>
<div class="line">    <span class="keywordtype">integer(c_int)</span>, <span class="keywordtype">value</span> :: a, b</div>
<div class="line">    <span class="keywordtype">integer(c_int)</span> :: c</div>
<div class="line">    c = a + b</div>
<div class="line"><span class="keyword">end function </span>fortran_add</div>
</div><!-- fragment --><p> <em>Compile with: <code>gfortran -shared -fPIC -o libfortran_math.so libfortran_math.f90</code></em></p>
<h3><a class="anchor" id="autotoc_md97"></a>
Zig</h3>
<div class="fragment"><div class="line">// libzig_math.zig</div>
<div class="line">export fn zig_add(a: c_int, b: c_int) c_int {</div>
<div class="line">    return a + b;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <em>Compile with: <code>zig build-lib -dynamic libzig_math.zig</code></em></p>
<h3><a class="anchor" id="autotoc_md98"></a>
Go</h3>
<div class="fragment"><div class="line">// libgo_math.go</div>
<div class="line">package main</div>
<div class="line">import &quot;C&quot;</div>
<div class="line">//export go_add</div>
<div class="line">func go_add(a C.int, b C.int) C.int { return a + b }</div>
<div class="line">func main() {}</div>
</div><!-- fragment --><p> <em>Compile with: <code>go build -buildmode=c-shared -o libgo_math.so libgo_math.go</code></em></p>
<h3><a class="anchor" id="autotoc_md99"></a>
Swift</h3>
<div class="fragment"><div class="line">// libswift_math.swift</div>
<div class="line">@_cdecl(&quot;swift_add&quot;)</div>
<div class="line">public func swift_add(a: CInt, b: CInt) -&gt; CInt {</div>
<div class="line">    return a + b</div>
<div class="line">}</div>
</div><!-- fragment --><p> <em>Compile with: <code>swiftc -emit-library libswift_math.swift -o libswift_math.so</code></em></p>
<h3><a class="anchor" id="autotoc_md100"></a>
D (dlang)</h3>
<div class="fragment"><div class="line"><span class="comment">// libd_math.d</span></div>
<div class="line"><span class="keyword">extern</span> (<a class="code hl_class" href="classC.html">C</a>) <span class="keywordtype">int</span> d_add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">    <span class="keywordflow">return</span> a + b;</div>
<div class="line">}</div>
<div class="ttc" id="aclassC_html"><div class="ttname"><a href="classC.html">C</a></div><div class="ttdef"><b>Definition</b> diagrams_c.h:5</div></div>
</div><!-- fragment --><p> <em>Compile with: <code>dmd -shared -fPIC -of=libd_math.so libd_math.d</code></em></p>
<h3><a class="anchor" id="autotoc_md101"></a>
Assembly (NASM on System V)</h3>
<div class="fragment"><div class="line">; libasm_math.asm</div>
<div class="line">section .text</div>
<div class="line">global asm_add</div>
<div class="line">asm_add:</div>
<div class="line">    mov eax, edi ; Move first argument (edi) into eax</div>
<div class="line">    add eax, esi ; Add second argument (esi) to eax</div>
<div class="line">    ret</div>
</div><!-- fragment --><p> <em>Compile with: <code>nasm -f elf64 libasm_math.asm &amp;&amp; gcc -shared -o libasm_math.so libasm_math.o</code></em></p>
<hr  />
<h1><a class="anchor" id="autotoc_md103"></a>
Chapter 6: Calling System Libraries</h1>
<h2><a class="anchor" id="autotoc_md104"></a>
Recipe: Calling Native System Libraries</h2>
<p><b>Problem</b>: You need to call a native OS library like <code>user32.dll</code> on Windows or <code>libc.so.6</code> on Linux.</p>
<p><b>Solution</b>: Load the library dynamically, get a function pointer, and use <code>infix</code> with the correct signature.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line"><span class="preprocessor">#include &lt;windows.h&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> run_example() {</div>
<div class="line">    HMODULE user32 = LoadLibraryA(<span class="stringliteral">&quot;user32.dll&quot;</span>);</div>
<div class="line">    <span class="keywordtype">void</span> * MessageBoxW_ptr = (<span class="keywordtype">void</span> *)GetProcAddress(user32, <span class="stringliteral">&quot;MessageBoxW&quot;</span>);</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * t = NULL;</div>
<div class="line">    infix_forward_create(&amp;t, <span class="stringliteral">&quot;(*void, *void, *void, uint) -&gt; int&quot;</span>);</div>
<div class="line">    <span class="comment">// ... call MessageBoxW ...</span></div>
<div class="line">    infix_forward_destroy(t);</div>
<div class="line">    FreeLibrary(user32);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#elif defined(__linux__)</span></div>
<div class="line"><span class="preprocessor">#include &lt;dlfcn.h&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> run_example() {</div>
<div class="line">    <span class="keywordtype">void</span> * libm = dlopen(<span class="stringliteral">&quot;libm.so.6&quot;</span>, RTLD_LAZY);</div>
<div class="line">    <span class="keywordtype">void</span> * pow_ptr = dlsym(libm, <span class="stringliteral">&quot;pow&quot;</span>);</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> * t = NULL;</div>
<div class="line">    infix_forward_create(&amp;t, <span class="stringliteral">&quot;(double, double) -&gt; double&quot;</span>);</div>
<div class="line">    <span class="comment">// ... call pow ...</span></div>
<div class="line">    infix_forward_destroy(t);</div>
<div class="line">    dlclose(libm);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="keywordtype">void</span> run_example() { printf(<span class="stringliteral">&quot;No system library example for this platform.\n&quot;</span>); }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    run_example();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md106"></a>
Chapter 7: Memory Management &amp; Performance</h1>
<h2><a class="anchor" id="autotoc_md107"></a>
Best Practice: Caching Trampolines</h2>
<p><b>Rule</b>: <b>NEVER</b> generate a new trampoline for the same function signature inside a hot loop. The performance of <code>infix</code> comes from amortizing the one-time generation cost over many fast calls.</p>
<div class="fragment"><div class="line"><span class="comment">// Correct Pattern: Generate once, use many times.</span></div>
<div class="line"><a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t;</div>
<div class="line">infix_forward_create(&amp;t, <span class="stringliteral">&quot;(int, int) -&gt; int&quot;</span>);</div>
<div class="line"><a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a> cif_func = (<a class="code hl_typedef" href="group__public__api.html#ga34ef26a155a3861d5172b7c07239ee43">infix_cif_func</a>)infix_forward_get_code(t);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {</div>
<div class="line">    <span class="comment">// VERY FAST: Re-using the same highly-optimized trampoline.</span></div>
<div class="line">    cif_func(target, &amp;result, args);</div>
<div class="line">}</div>
<div class="line">infix_forward_destroy(t);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md109"></a>
Chapter 8: Common Pitfalls &amp; Troubleshooting</h1>
<h2><a class="anchor" id="autotoc_md110"></a>
Mistake: Passing a Value Instead of a Pointer in <code>args[]</code></h2>
<ul>
<li><b>Symptom</b>: Crash or garbage data.</li>
<li><b>Explanation</b>: The <code>args</code> array must contain <b>pointers to</b> your argument values, not the values themselves.</li>
</ul>
<h2><a class="anchor" id="autotoc_md111"></a>
Mistake: <code>infix</code> Signature Mismatch</h2>
<ul>
<li><b>Symptom</b>: Silent data corruption or a crash.</li>
<li><b>Explanation</b>: The signature string must <em>exactly</em> match the <a class="el" href="classC.html">C</a> type's size and alignment. <a class="el" href="classA.html">A</a> <code>long</code> is 32 bits on 64-bit Windows but 64 bits on 64-bit Linux.</li>
<li><b>Solution</b>: Use fixed-width types (<code>int32</code>, <code>uint64</code>) whenever possible.</li>
</ul>
<h2><a class="anchor" id="autotoc_md112"></a>
Pitfall: Function Pointer Syntax</h2>
<ul>
<li><b>Symptom</b>: Parser error.</li>
<li><b>Explanation</b>: <a class="el" href="classA.html">A</a> function type is <code>(...) -&gt; ...</code>, and a pointer to anything is <code>*...</code>. Therefore, a pointer to a function type is <code>*((...) -&gt; ...)</code>.</li>
<li><b>Solution</b>: <code>int (*callback)(void)</code> is <code>*(() -&gt; int32)</code>.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md114"></a>
Chapter 9: Building Language Bindings</h1>
<p><a class="el" href="classA.html">A</a> robust language binding built on <code>infix</code> must solve four main challenges.</p>
<h3><a class="anchor" id="autotoc_md115"></a>
1. Type Mapping -&gt; Signature String Generation</h3>
<p>The binding's primary job is to <b>generate a signature string</b> from the high-level language's type information.</p>
<h3><a class="anchor" id="autotoc_md116"></a>
2. Trampoline Caching</h3>
<p>The binding <b>must</b> implement a global, persistent cache for trampolines, using the signature string as the key.</p>
<h3><a class="anchor" id="autotoc_md117"></a>
3. Managing Memory &amp; Object Lifetimes</h3>
<p>The binding must act as a bridge between the host language's Garbage Collector (GC) and <a class="el" href="classC.html">C</a>'s manual memory management, holding references to objects to prevent premature collection.</p>
<h3><a class="anchor" id="autotoc_md118"></a>
4. Implementing the Callback Bridge</h3>
<p>When a <a class="el" href="classC.html">C</a> library invokes a reverse trampoline, the JIT-compiled stub calls a <a class="el" href="classC.html">C</a> handler. This "bridge" handler must then transfer control back to the high-level language's runtime, often involving acquiring a global lock (like Python's GIL). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
