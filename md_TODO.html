<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>infix: Project Roadmap: infix FFI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript"> DoxygenAwesomeDarkModeToggle.init() </script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript"> DoxygenAwesomeFragmentCopyButton.init() </script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript"> DoxygenAwesomeParagraphLink.init() </script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript"> DoxygenAwesomeInteractiveToc.init() </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">infix
   </div>
   <div id="projectbrief">A JIT-Powered FFI Library for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_TODO.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Project Roadmap: infix FFI</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md216"></a> This document outlines the planned development goals for the infix FFI library, categorized by priority. Each item includes the context for why it's important, the proposed idea, a clear definition of what "done" looks like, and potential challenges.</p>
<h1><a class="anchor" id="autotoc_md217"></a>
High Priority: Foundation &amp; Stability</h1>
<p><em>These tasks focus on critical infrastructure, core reliability, and essential C language feature completeness. They must be addressed before major new features are added.</em></p>
<ul>
<li>[x] <b>Design and Implement New Signature Parser (<code><a class="el" href="signature_8c.html" title="Implements the infix signature string parser and type printer.">signature.c</a></code>)**<ul>
<li><b>Context:</b> The current single-character signature system is minimal and lacks the expressiveness needed for rich introspection and clarity. The v1.0 specification is the path forward.</li>
<li><b>Idea:</b> Replace the existing recursive-descent parser in <code><a class="el" href="signature_8c.html" title="Implements the infix signature string parser and type printer.">signature.c</a></code> with a new one that implements the full v1.0 EBNF grammar. This will be a ground-up rewrite.</li>
<li><b>Goal:</b> The new <code>infix_signature_parse</code> can correctly parse all valid examples from the v1.0 specification, including nested structs, unions, and pointers. It must produce a valid <code>infix_type</code> graph in an arena. The old parser will be completely removed.</li>
<li><b>Possible Roadblocks:</b> This is the largest single task. It requires careful implementation to handle all grammatical rules, whitespace, and error conditions correctly.</li>
</ul>
</b></li>
<li><b>[x] **Update Type System for New Concepts (<code><a class="el" href="types_8c.html" title="Implements the public API for creating and managing type descriptions.">types.c</a></code>, <code><a class="el" href="infix_8h.html" title="The public interface for the infix FFI library.">infix.h</a></code>)**<ul>
<li><b>Context:</b> The v1.0 spec introduces concepts like <code>enum</code> that are not present in the current type system.</li>
<li><b>Idea:</b><ol type="1">
<li>Add a new <code>INFIX_TYPE_ENUM</code> category to the <code>infix_type_category</code> enum.</li>
<li>Add a corresponding <code>enum_info</code> struct to the <code><a class="el" href="structinfix__type__t.html" title="A semi-opaque structure that describes a C type.">infix_type_t</a></code> <code>meta</code> union to store the underlying integer type.</li>
<li>Implement a new <code>infix_type_create_enum(arena, &amp;type, underlying_type)</code> function.</li>
</ol>
</li>
<li><b>Goal:</b> The type system can fully represent every construct from the v1.0 signature language. The new parser will use these new functions to build the type graph.</li>
</ul>
</b></li>
<li><b>[x] <b>Refactor and Test All Examples and Unit Tests</b><ul>
<li><b>Context:</b> Every single test file (<code>t/*.c</code>) and example file (`eg//*.c<code>) in the project uses the old signature format. They will all be broken by the new parser.</code></li>
<li><code> **Idea:** Go through every</code>.c<code>file in the</code>t/<code>and</code>eg/<code>directories and update all signature strings to the new v1.o format.</code></li>
<li><code> **Goal:** The entire test suite (</code>xmake test`) and all examples compile and run successfully using the new parser. This is the definition of "done" for the transition.</li>
<li><b>Possible Roadblocks:</b> This is a tedious but essential task. It will touch dozens of files and is a good opportunity to improve the clarity of existing tests.</li>
</ul>
</b></li>
<li><b>[x] <b>Update All Public Documentation (<code><a class="el" href="README_8md.html">README.md</a></code>, <code><a class="el" href="cookbook_8md.html">cookbook.md</a></code>, etc.)**<ul>
<li><b>Context:</b> The project's documentation is a key feature. It must be updated to reflect the new, more powerful signature language.</li>
<li>**Idea: Replace the existing <code><a class="el" href="signatures_8md.html">signatures.md</a></code> with the new v1.0 specification. Update the <code><a class="el" href="README_8md.html">README.md</a></code>, <code><a class="el" href="cookbook_8md.html">cookbook.md</a></code>, and all other documentation to use and explain the new syntax.</li>
<li><b>Goal:</b> All documentation is consistent and accurately describes the v1.0 signature language. All code examples are updated to the new syntax.</li>
</ul>
</b></b></li>
<li><b><b>[x] <b>Re-evaluate and Implement Variadic API</b><ul>
<li><b>Context:</b> The new spec proposes a different model for handling variadic functions. The current implementation uses a single signature with a <code>;</code> separator.</li>
<li><b>Idea:</b> Remove the <code>num_fixed_args</code> parameter from the core <code>infix_forward_create_manual</code> and <code>infix_reverse_create_manual</code> functions. Implement the new high-level API proposed in the spec, <code>infix_forward_create_variadic</code>, which will internally construct the final, concrete signature before calling the manual API.</li>
<li><b>Goal:</b> The library's public API for variadics matches the new specification. The old semicolon logic is completely removed from the parser.</li>
</ul>
</b></b></li>
<li><b><b>[x] <b>Refactor Platform-Specific Emitters</b><ul>
<li><b>Context:</b> The initial design mixed platform-specific instruction emitters (e.g., for x86-64) into the generic <code><a class="el" href="trampoline_8c.html" title="The core JIT engine for generating forward and reverse trampolines.">trampoline.c</a></code> and public <code><a class="el" href="infix_8h.html" title="The public interface for the infix FFI library.">infix.h</a></code>, breaking the library's architectural abstraction.</li>
<li><b>Idea:</b> Move all platform-specific emitter functions into their own dedicated, internal modules (e.g., <code><a class="el" href="abi__x64__emitters_8c.html" title="Implements internal helper functions for emitting x86-64 machine code.">abi_x64_emitters.c</a></code>, <code><a class="el" href="abi__arm64__emitters_8c.html" title="Implements internal helper functions for emitting AArch64 machine code.">abi_arm64_emitters.c</a></code>) with non-public headers.</li>
<li><b>Goal:</b> The generic <code><a class="el" href="trampoline_8c.html" title="The core JIT engine for generating forward and reverse trampolines.">trampoline.c</a></code> is now 100% platform-agnostic. The public <code><a class="el" href="infix_8h.html" title="The public interface for the infix FFI library.">infix.h</a></code> no longer exposes any internal emitter functions. The architecture is cleaner, more maintainable, and easier to extend to new platforms.</li>
</ul>
</b></b></li>
<li><b><b>[x] <b>Implement Fuzzing</b><ul>
<li><b>Context:</b> The type creation API is a potential attack surface for security vulnerabilities via malformed input. Fuzzing is the most effective method for automatically discovering such bugs.</li>
<li><b>Idea:</b> Create a fuzzing harness using a framework like libFuzzer that calls the type creation APIs with random, malformed data.</li>
<li><b>Goal:</b> An <code>xmake fuzz</code> target is created. The CI pipeline runs the fuzzer for a set duration to continuously search for vulnerabilities. The fuzzer runs without finding any crashes.</li>
<li><b>Possible Roadblocks:</b> Fuzzing can be slow; requires careful tuning of the CI process to avoid excessive run times. Setting up the fuzzing environment can be complex.</li>
</ul>
</b></b></li>
<li><b><b>[x] <b>Add Memory Stress Test with Valgrind Monitoring</b><ul>
<li><b>Context:</b> In a C library that performs many dynamic allocations, it's easy to introduce subtle memory leaks.</li>
<li><b>Idea:</b> Create a new test that rapidly creates and destroys thousands of trampolines with varied signatures in a tight loop.</li>
<li><b>Goal:</b> A new test target, <code>xmake run memory_test</code>, is created. The CI pipeline runs this test under Valgrind's <code>memcheck</code> tool on the Linux runner with <code>--leak-check=full</code>. The build must fail if Valgrind reports <em>any</em> memory leaks.</li>
<li><b>Possible Roadblocks:</b> Test can be slow to run; requires a Linux-based CI runner with Valgrind installed.</li>
</ul>
</b></b></li>
<li><b><b>[x] <b>Add Threading Stress Test</b><ul>
<li><b>Context:</b> The documentation claims callbacks are thread-safe. This must be rigorously proven to detect potential race conditions.</li>
<li><b>Idea:</b> Create a test that spawns multiple threads to call a single reverse trampoline concurrently.</li>
<li><b>Goal:</b> The project is compiled with a thread sanitizer (<code>-fsanitize=thread</code> for GCC/Clang) in the CI, and the stress test must pass without any reported data races.</li>
<li><b>Possible Roadblocks:</b> Threading bugs can be notoriously difficult to reproduce reliably; requires a sanitizer-compatible toolchain.</li>
</ul>
</b></b></li>
<li><b><b>[x] <b>Use Guard Pages for Freed Trampolines</b><ul>
<li><b>Context:</b> After a trampoline is freed, its function pointer becomes a dangling pointer. If a user accidentally calls it, a use-after-free vulnerability can be triggered.</li>
<li><b>Idea:</b> Instead of just releasing memory, change its protection to <code>PROT_NONE</code> (no read/write/execute). This turns a subtle vulnerability into a safe, immediate, and obvious crash.</li>
<li><b>Goal:</b> The <code>infix_executable_free</code> function is updated to use <code>mprotect</code>/<code>VirtualProtect</code>. A new test is created that frees a trampoline and then calls its old function pointer, asserting that the program safely terminates.</li>
<li><b>Possible Roadblocks:</b> Testing for an expected crash is non-trivial and may require platform-specific signal handling or process management in the test suite.</li>
</ul>
</b></b></li>
<li><b><b>[x] <b>Add <code>longdouble</code> Support</b><ul>
<li><b>Context:</b> <code>longdouble</code> was the last major C primitive type not supported by the library.</li>
<li><b>Idea:</b> Add a new primitive type and implement the correct, platform-specific ABI handling for it.</li>
<li><b>Goal:</b> <code>longdouble</code> is a recognized <code>infix_type</code> and passes correctly in forward and reverse calls on all supported platforms (System V, Windows/GCC, AArch64).</li>
</ul>
</b></b></li>
<li><b><b>[x] <b>Read-Only Callback Contexts (RELRO for Callbacks)</b><ul>
<li><b>Context:</b> The <code><a class="el" href="structinfix__reverse__t.html" title="Internal definition of a reverse trampoline (callback/closure) handle.">infix_reverse_t</a></code> struct contains function pointers that could be targeted by memory corruption attacks to hijack control flow.</li>
<li><b>Idea:</b> After a callback context is created, use <code>mprotect</code>/<code>VirtualProtect</code> on the memory page containing it to make it read-only.</li>
<li><b>Goal:</b> The context is hardened by default. Any attempt to write to a hardened context struct will cause an immediate segmentation fault, preventing the attack.</li>
<li><b>Possible Roadblocks:</b> <code>mprotect</code> operates on page boundaries, not on individual structs. This requires careful memory management to ensure unrelated writable data is not on the same page, which might make the implementation complex.</li>
</ul>
</b></b></li>
</ul>
<p><b><b></b></b></p>
<h1><a class="anchor" id="autotoc_md218"></a>
Medium Priority: Expansion &amp; Optimization</h1>
<p><b><b></b></b></p>
<p><b><b><em>Once the foundation is solid, these tasks focus on adding major new capabilities, improving performance, and expanding test coverage.</em></b></b></p>
<p><b><b></p><ul>
<li>[x] <b>Add <code>_Complex</code> Type Support</b><ul>
<li><b>Context:</b> The C <code>_Complex</code> type is a standard feature used in scientific and engineering domains. Supporting it is a key step towards feature-completeness. The ABI rules for <code>_Complex</code> are generally straightforward, often mapping directly to existing logic for two-element structs or Homogeneous Floating-point Aggregates (HFAs).</li>
<li><b>Idea:</b><ol type="1">
<li>Introduce a new <code>INFIX_TYPE_COMPLEX</code> category to the <code>infix_type</code> system.</li>
<li>Add a new signature syntax, such as ~~<code>complex(f)</code> for <code>float _Complex</code> and <code>complex(d)</code> for <code>double _Complex</code>~~.</li>
<li>Update the ABI backends to classify this new type. On System V/AArch64, it should be treated like a two-element float/double aggregate. On Windows x64, it will be passed by reference (as its size, 16 bytes, is not a power of two).</li>
</ol>
</li>
<li><b>Goal:</b> A user can create a trampoline for a function like <code>double _Complex cadd(double _Complex a, double _Complex b)</code> using the signature <code>"complex(d),complex(d)=&gt;complex(d)"</code> and have it work correctly on all supported platforms.</li>
<li><b>Possible Roadblocks:</b> Minimal. The logic for this largely exists within the aggregate classifiers already. The main work is in plumbing the new type through the system.</li>
</ul>
</li>
<li>[x] <b>Internal Arena Allocator</b><ul>
<li><b>Context:</b> The JIT generation process involves many small, short-lived memory allocations which can be inefficient and cause fragmentation.</li>
<li><b>Idea:</b> Implement a simple arena/pool allocator for the lifetime of a single trampoline generation to reduce <code>malloc</code> overhead.</li>
<li><b>Goal:</b> This is an internal optimization. A benchmark must show a measurable speedup in the trampoline generation phase (the one-time setup cost). Trampoline generation is now ~50x faster for complex signatures.</li>
<li><b>Possible Roadblocks:</b> Requires careful changes to internal APIs to pass the allocator context around; potential for subtle memory management bugs during implementation.</li>
</ul>
</li>
<li>[x] <b>Profile Code Generation and Execution</b><ul>
<li><b>Context:</b> Before optimizing, we need to identify performance bottlenecks. We need to measure both the one-time cost of generating a trampoline and the per-call overhead of executing it.</li>
<li><b>Idea:</b> Use platform-specific profiling tools (Valgrind/Callgrind, Instruments, VTune) to measure trampoline generation and execution overhead.</li>
<li><b>Goal:</b> A new document, <code>docs/performance.md</code>, is created to summarize the findings and guide future optimization work.</li>
<li><b>Possible Roadblocks:</b> Profiling JIT'd code can be complex, as symbols may not be easily visible in standard profilers.</li>
</ul>
</li>
<li>[x] <b>Implement Packed Argument Trampolines</b><ul>
<li><b>Context:</b> The current <code>void** args</code> API requires pointer indirection. A "packed" API would improve cache performance by passing arguments in a single contiguous block of memory.</li>
<li><b>Idea:</b> Implement <code>infix_forward_create_packed</code>, where the JIT'd code reads arguments from offsets relative to a single pointer.</li>
<li><b>Goal:</b> A benchmark demonstrates a significant performance improvement for calls with many arguments compared to the standard trampoline.</li>
</ul>
</li>
<li>[ ] <b>Implement Validation for Unresolved Types</b><ul>
<li><b>Context:</b> The JIT might try creating a trampoline if the signature contains an unresolved named reference (like <code>struct&lt;Foo&gt;</code>).</li>
</ul>
</li>
</ul>
<p></b></b></p>
<p><b><b></b></b></p>
<h1><a class="anchor" id="autotoc_md219"></a>
Low Priority: Advanced Features &amp; Polish</h1>
<p><b><b></b></b></p>
<p><b><b><em>These items are valuable but less critical. They can be addressed over time to round out the library's feature set.</em></b></b></p>
<p><b><b></p><ul>
<li>[ ] <b>Add SIMD Vector Type Support (Phased)</b><ul>
<li><b>Context:</b> High-performance computing, multimedia processing, and cryptography rely heavily on SIMD vector types (<code>__m128</code>, NEON types). Direct support for these types is a critical feature for advanced use cases.</li>
<li><b>Idea (Phased Approach):</b><ol type="1">
<li><b>Phase 1 (128-bit Vectors):</b> Add an <code>INFIX_TYPE_VECTOR</code> category and a signature syntax like <code>vector(f, 4)</code> for <code>__m128</code>. Update ABI backends to pass these types in XMM (x64) or VFP (AArch64) registers.</li>
<li><b>Phase 2 (256/512-bit Vectors):</b> Extend the x64 backends to be aware of YMM and ZMM registers. Implement new emitters in <code><a class="el" href="abi__x64__emitters_8c.html" title="Implements internal helper functions for emitting x86-64 machine code.">abi_x64_emitters.c</a></code> for AVX/AVX512 instructions and update classifiers for their unique passing rules.</li>
</ol>
</li>
<li><b>Goal:</b><ul>
<li><b>Phase 1:</b> A user can successfully call a function taking <code>__m128d</code> on both SysV and Windows x64.</li>
<li><b>Phase 2:</b> A user can successfully call a function taking <code>__m256</code> on an AVX-capable system.</li>
</ul>
</li>
<li><b>Possible Roadblocks:</b> Phase 2 is a major undertaking. It requires significant changes to the x64 register allocators and new, complex instruction encodings. Testing will require hardware or emulators that support AVX2 and AVX-512.</li>
</ul>
</li>
<li>[ ] <b>Implement RISC-V 64-bit ABI</b><ul>
<li><b>Context:</b> RISC-V is a growing open-source architecture. Adding support would demonstrate the library's portability.</li>
<li><b>Idea:</b> Create a new <code>abi_riscv.c</code> file and associated low-level instruction emitters, following the roadmap in <code><a class="el" href="internals_8md.html">internals.md</a></code>.</li>
<li><b>Goal:</b> The library successfully compiles and passes the entire test suite on a RISC-V 64-bit platform (e.g., in QEMU within the CI).</li>
<li><b>Possible Roadblocks:</b> Access to RISC-V hardware or a reliable CI-based emulator is required for testing.</li>
</ul>
</li>
<li>[ ] **(Re-scoped) Enhance <code>symbol_finder.pl</code> with Multi-Language Demangling**<ul>
<li><b>Context:</b> The <code>symbol_finder.pl</code> script can be extended to demangle symbols from C++, Rust, and Fortran, making it a powerful tool for FFI development.</li>
<li><b>Idea:</b> Adopt a pragmatic, phased approach to implementation.</li>
<li><b>Goal:</b><ul>
<li><b>Phase 1:</b> The script shells out to standard toolchains (<code>c++filt</code> for Itanium) for immediate functionality.</li>
<li><b>Phase 2:</b> Begin the major task of writing pure-Perl demanglers from scratch for Itanium C++ and Rust v0 to remove all external tool dependencies.</li>
</ul>
</li>
<li><b>Possible Roadblocks:</b> Writing full-featured demanglers from scratch (Phase 2) is an extremely large and complex undertaking.</li>
</ul>
</li>
<li>[ ] <b>Direct System Call Interface</b><ul>
<li><b>Context:</b> Some advanced applications need to bypass standard C libraries and make direct calls to the OS kernel, which uses a different, low-level ABI.</li>
<li><b>Idea:</b> Create a new <code>infix_syscall_create</code> API that emits assembly to load registers and execute the <code>syscall</code> instruction.</li>
<li><b>Goal:</b> A user can successfully call a basic OS syscall, such as <code>write</code> on Linux, using a generated trampoline.</li>
<li><b>Possible Roadblocks:</b> Extremely high implementation cost. Requires a unique ABI implementation for every supported OS. Testing is very difficult and OS-specific.</li>
<li><b>References:</b><ul>
<li>General:<ul>
<li><a href="https://www.cs.uaf.edu/courses/cs301/2014-fall/notes/syscall/index.html">https://www.cs.uaf.edu/courses/cs301/2014-fall/notes/syscall/index.html</a></li>
</ul>
</li>
<li>Windows:<ul>
<li><a href="https://j00ru.vexillium.org/syscalls/nt/64/">https://j00ru.vexillium.org/syscalls/nt/64/</a></li>
<li><a href="https://github.com/hfiref0x/SyscallTables">https://github.com/hfiref0x/SyscallTables</a></li>
</ul>
</li>
<li>Linux:<ul>
<li><a href="https://syscalls64.paolostivanin.com/">https://syscalls64.paolostivanin.com/</a></li>
<li><a href="https://filippo.io/linux-syscall-table/">https://filippo.io/linux-syscall-table/</a></li>
</ul>
</li>
<li>FreeBSD:<ul>
<li><a href="https://lists.freebsd.org/archives/freebsd-hackers/2023-July/002351.html">https://lists.freebsd.org/archives/freebsd-hackers/2023-July/002351.html</a></li>
<li><a href="https://www.lurklurk.org/concordance.html">https://www.lurklurk.org/concordance.html</a> (Linux vs. FreeBSD)</li>
<li><a href="https://alfonsosiciliano.gitlab.io/posts/2023-08-28-freebsd-15-system-calls.html">https://alfonsosiciliano.gitlab.io/posts/2023-08-28-freebsd-15-system-calls.html</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>[ ] <b>Add Exception Handling Boundary</b><ul>
<li><b>Context:</b> An unhandled C++ or SEH exception that crosses the FFI boundary will crash the program. A robust library should provide a way to handle this.</li>
<li><b>Idea:</b> Create a <code>infix_forward_create_safe</code> function where the JIT code wraps the native call in a <code>try...catch</code> or <code>__try...__except</code> block.</li>
<li><b>Goal:</b> If a native function throws an exception, the trampoline catches it, returns <code>INFIX_ERROR_NATIVE_EXCEPTION</code>, and the program does not crash.</li>
<li><b>Possible Roadblocks:</b> This requires mixing C and C++ or using platform-specific SEH, which adds significant complexity and potential portability issues.</li>
</ul>
</li>
<li>[ ] <b>Add Bitfield Support in Structs</b><ul>
<li><b>Context:</b> C allows structs to have bitfields, but their memory layout is highly compiler-specific. Supporting them is an advanced FFI feature.</li>
<li><b>Idea:</b> Extend the <code>infix_type</code> system to describe bitfields and implement the packing/unpacking logic for each ABI.</li>
<li><b>Goal:</b> Successfully call a function that takes a struct containing bitfields and get the correct result.</li>
<li><b>Possible Roadblocks:</b> This is a notoriously difficult part of FFI implementation, as bitfield layout rules are often poorly documented and vary even between versions of the same compiler.</li>
</ul>
</li>
<li>[ ] <strike><b>Add Type System Builder API</b></strike><ul>
<li><strike><b>Context:</b> The current Manual API for creating complex structs is verbose and requires manual memory management for the member array within the arena.</strike></li>
<li><strike><b>Idea:</b> Create a fluent builder pattern API (e.g., <code>infix_struct_builder_*</code> functions) to simplify type creation.</strike></li>
<li><strike><b>Goal:</b> A user can define a complex struct without manually allocating or managing the <code>infix_struct_member</code> array, reducing boilerplate and potential for errors.</strike></li>
<li>Supplanted by signature API.</li>
</ul>
</li>
<li>[ ] <b>Add Support for 32-bit Architectures</b><ul>
<li><b>Context:</b> A major future direction to support legacy or embedded systems.</li>
<li><b>Idea:</b> Create new ABI backends for 32-bit x86 and ARM.</li>
<li><b>Goal:</b> The library compiles and passes the test suite when targeting a 32-bit architecture.</li>
<li><b>Possible Roadblocks:</b> This is a very large undertaking, effectively doubling the number of supported ABIs that must be maintained and tested.</li>
</ul>
</li>
<li>[x] <b>Decouple Debug Logging from <code><a class="el" href="double__tap_8h.html" title="A lightweight, single-header TAP (Test Anything Protocol) library.">double_tap.h</a></code></b><ul>
<li><b>Context:</b> The library's internal <code>INFIX_DEBUG_PRINTF</code> macro should not be tied to the test framework's <code><a class="el" href="double__tap_8h.html#a7a59fa444b44e2775bc266715a34f51a">note()</a></code> function, which improves modularity.</li>
<li><b>Idea:</b> Refactor <code>INFIX_DEBUG_PRINTF</code> in <code><a class="el" href="utility_8h.html" title="A header for conditionally compiled debugging utilities.">utility.h</a></code> to use <code>fprintf(stderr, ...)</code> directly.</li>
<li><b>Goal:</b> The library source code (<code>src/</code>) has no includes of <code><a class="el" href="double__tap_8h.html" title="A lightweight, single-header TAP (Test Anything Protocol) library.">double_tap.h</a></code>. Internal debug messages are printed to <code>stderr</code> when <code>INFIX_DEBUG_ENABLED</code> is active.</li>
<li><b>Possible Roadblocks:</b> Minimal; this is a straightforward refactoring task.</li>
</ul>
</li>
<li>[x] <b>Investigate and Fix Read-Only Context on macOS</b><ul>
<li><b>Context:</b> The read-only hardening for reverse trampoline contexts does not currently work on macOS due to platform-specific memory protection behavior.</li>
<li><b>Idea:</b> Research the correct combination of <code>mmap</code> flags and/or other system calls required to create a reliably read-only data page on macOS.</li>
<li><b>Goal:</b> The "Writing to a hardened reverse trampoline context causes a crash" test passes successfully on macOS.</li>
<li><b>Possible Roadblocks:</b> This may require deep knowledge of macOS virtual memory and could be more complex than on other POSIX systems.</li>
</ul>
</li>
<li>[ ] <b>Add Half-Precision Floating-Point (<code>float16_t</code>) Support**<ul>
<li><b>Context:</b> <code>_Float16</code> is increasingly important for machine learning and GPU-related tasks.</li>
<li><b>Idea:</b> Add a new primitive type. The ABI rules are simple: <code>_Float16</code> arguments are promoted to <code>float</code> and passed in standard floating-point registers.</li>
<li><b>Goal:</b> The library correctly handles <code>float16_t</code> arguments and return values.</li>
</ul>
</b></li>
<li><b>[ ] **Add Support for Scalable Vectors (ARM SVE &amp; RISC-V 'V')</b><ul>
<li><b>Context:</b> This is the future of SIMD on these architectures, where the vector size is determined by the hardware at runtime.</li>
<li><b>Idea:</b> This would require a major architectural redesign. The JIT code would need to query the hardware's vector length at runtime and dynamically adjust its behavior.</li>
<li><b>Goal:</b> Basic support for a function taking a scalable vector type.</li>
<li><b>Possible Roadblocks:</b> Monumental implementation effort. Likely out of scope for the current library</li>
</ul>
</li>
<li>[ ] <b>Typedef System</b> </li>
</ul>
<p></b></b></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
