/**
 * @file 006_end_to_end_calls.c
 * @brief End-to-end unit test for passing and returning aggregate types (structs).
 * @ingroup test_suite
 *
 * @details This test verifies that `infix` can correctly handle FFI calls where
 * structs are passed by value as arguments and/or returned by value. This is a
 * complex scenario that heavily depends on the correctness of both the type
 * layout calculation and the ABI-specific classification and code generation logic.
 *
 * The test covers:
 * - **Forward Call:** A call from the test harness into a native C function
 *   (`move_point`) that takes a `Point` struct by value and returns one by value.
 *   This is tested with both bound and unbound trampolines.
 *
 * - **Reverse Call:** A native C function (`execute_point_callback`) calls a
 *   JIT-compiled function pointer generated by `infix`. This callback then
 *   invokes a C handler (`point_callback_handler`) that also takes and returns
 *   a `Point` struct by value.
 *
 * This test serves as a high-level integration test, confirming that all the
 * pieces of the library (parser, type system, ABI classifier, JIT emitter) work
 * together correctly for a common and important use case.
 */

#define DBLTAP_IMPLEMENTATION
#include "common/double_tap.h"
#include "types.h"
#include <infix/infix.h>
#include <math.h>

// Native C Functions for Testing

/** @brief A C function to be called via a forward trampoline. Takes and returns a struct. */
Point move_point(Point p, double dx, double dy) {
    Point result = {p.x + dx, p.y + dy};
    note("Native C move_point called: (%f, %f) + (%f, %f) -> (%f, %f)", p.x, p.y, dx, dy, result.x, result.y);
    return result;
}

/** @brief A C handler to be invoked by a reverse trampoline. */
Point point_callback_handler(Point p) {
    note("point_callback_handler received p={%.1f, %.1f}", p.x, p.y);
    return (Point){p.x * 2.0, p.y * 2.0};
}

/** @brief A C "harness" function that simulates a C library calling our JIT-compiled callback. */
void execute_point_callback(Point (*func_ptr)(Point), Point p) {
    Point result = func_ptr(p);
    ok(fabs(result.x - p.x * 2.0) < 1e-9 && fabs(result.y - p.y * 2.0) < 1e-9,
       "Callback returned correct Point struct by value");
    diag("Harness received Point {%.1f, %.1f}", result.x, result.y);
}

TEST {
    plan(2);

    subtest("Forward calls with aggregate types (structs)") {
        plan(1);
        subtest("Passing and returning a small struct by value") {
            plan(3);
            Point bad_result = {0, 0};
            ok(fabs(bad_result.x - 15.5) > 1e-9, "Sanity check: non-matching result fails");
            const char * signature = "({double, double}, double, double) -> {double, double}";
            Point start_point = {10.0, 20.0};
            double offset_x = 5.5;
            double offset_y = -2.5;
            void * args[] = {&start_point, &offset_x, &offset_y};

            subtest("Unbound trampoline") {
                plan(2);
                infix_forward_t * unbound_t = nullptr;
                ok(infix_forward_create_unbound(&unbound_t, signature, nullptr) == INFIX_SUCCESS,
                   "Unbound trampoline created");
                if (unbound_t) {
                    Point unbound_result = {0.0, 0.0};
                    infix_unbound_cif_func cif = infix_forward_get_unbound_code(unbound_t);
                    cif((void *)move_point, &unbound_result, args);
                    ok(fabs(unbound_result.x - 15.5) < 1e-9 && fabs(unbound_result.y - 17.5) < 1e-9,
                       "Unbound call correct");
                }
                else
                    skip(1, "Skipping unbound call");

                infix_forward_destroy(unbound_t);
            }

            subtest("Bound trampoline") {
                plan(2);
                infix_forward_t * bound_t = nullptr;
                ok(infix_forward_create(&bound_t, signature, (void *)move_point, nullptr) == INFIX_SUCCESS,
                   "Bound trampoline created");
                if (bound_t) {
                    Point bound_result = {0.0, 0.0};
                    infix_cif_func cif = infix_forward_get_code(bound_t);
                    cif(&bound_result, args);
                    ok(fabs(bound_result.x - 15.5) < 1e-9 && fabs(bound_result.y - 17.5) < 1e-9, "Bound call correct");
                }
                else
                    skip(1, "Skipping bound call");

                infix_forward_destroy(bound_t);
            }
        }
    }

    subtest("Reverse calls (callbacks) with aggregate types") {
        plan(1);
        subtest("Passing and returning a small struct by value") {
            plan(2);
            const char * signature = "({double, double}) -> {double, double}";

            infix_reverse_t * context = nullptr;
            infix_status status =
                infix_reverse_create_callback(&context, signature, (void *)point_callback_handler, nullptr);
            ok(status == INFIX_SUCCESS, "Successfully created reverse trampoline for struct by value");

            if (status == INFIX_SUCCESS) {
                typedef Point (*PointCallback)(Point);
                PointCallback native_func_ptr = (PointCallback)infix_reverse_get_code(context);
                Point input_point = {21.0, -10.5};
                // This call simulates an external C library invoking our callback.
                execute_point_callback(native_func_ptr, input_point);
            }
            else
                skip(1, "Skipping call check due to trampoline creation failure.");

            infix_reverse_destroy(context);
        }
    }
}
