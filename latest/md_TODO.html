<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>infix FFI Library: &lt;strong&gt;Project Roadmap: infix FFI&lt;/strong&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">infix FFI Library<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">&lt;strong&gt;Project Roadmap: infix FFI&lt;/strong&gt;</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md228"></a> This document outlines the planned development goals for the infix FFI library, categorized by priority. Each item includes the context for why it's important, the proposed idea, a clear definition of what "done" looks like, and potential challenges.</p>
<h1><a class="anchor" id="autotoc_md229"></a>
&lt;strong&gt;High Priority: Foundation &amp; Stability&lt;/strong&gt;</h1>
<p><em>These tasks focus on critical infrastructure, core reliability, and essential C language feature completeness. They must be addressed before major new features are added.</em></p>
<ul>
<li>[x] <b>Refactor Platform-Specific Emitters</b><ul>
<li><b>Context:</b> The initial design mixed platform-specific instruction emitters (e.g., for x86-64) into the generic <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code> and public <code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code>, breaking the library's architectural abstraction.</li>
<li><b>Idea:</b> Move all platform-specific emitter functions into their own dedicated, internal modules (e.g., <code><a class="el" href="abi__x64__emitters_8c.html" title="Implements the internal helper functions for emitting x86-64 machine code.">abi_x64_emitters.c</a></code>, <code><a class="el" href="abi__arm64__emitters_8c.html" title="Implements the internal helper functions for emitting AArch64 machine code.">abi_arm64_emitters.c</a></code>) with non-public headers.</li>
<li><b>Goal:</b> The generic <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code> is now 100% platform-agnostic. The public <code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code> no longer exposes any internal emitter functions. The architecture is cleaner, more maintainable, and easier to extend to new platforms.</li>
</ul>
</li>
<li>[x] <b>Implement Fuzzing</b><ul>
<li><b>Context:</b> The type creation API is a potential attack surface for security vulnerabilities via malformed input. Fuzzing is the most effective method for automatically discovering such bugs.</li>
<li><b>Idea:</b> Create a fuzzing harness using a framework like libFuzzer that calls the type creation APIs with random, malformed data.</li>
<li><b>Goal:</b> An <code>xmake fuzz</code> target is created. The CI pipeline runs the fuzzer for a set duration to continuously search for vulnerabilities. The fuzzer runs without finding any crashes.</li>
<li><b>Possible Roadblocks:</b> Fuzzing can be slow; requires careful tuning of the CI process to avoid excessive run times. Setting up the fuzzing environment can be complex.</li>
</ul>
</li>
<li>[x] <b>Add Memory Stress Test with Valgrind Monitoring</b><ul>
<li><b>Context:</b> In a C library that performs many dynamic allocations, it's easy to introduce subtle memory leaks.</li>
<li><b>Idea:</b> Create a new test that rapidly creates and destroys thousands of trampolines with varied signatures in a tight loop.</li>
<li><b>Goal:</b> A new test target, <code>xmake run memory_test</code>, is created. The CI pipeline runs this test under Valgrind's <code>memcheck</code> tool on the Linux runner with <code>--leak-check=full</code>. The build must fail if Valgrind reports <em>any</em> memory leaks.</li>
<li><b>Possible Roadblocks:</b> Test can be slow to run; requires a Linux-based CI runner with Valgrind installed.</li>
</ul>
</li>
<li>[x] <b>Add Threading Stress Test</b><ul>
<li><b>Context:</b> The documentation claims callbacks are thread-safe. This must be rigorously proven to detect potential race conditions.</li>
<li><b>Idea:</b> Create a test that spawns multiple threads to call a single reverse trampoline concurrently.</li>
<li><b>Goal:</b> The project is compiled with a thread sanitizer (<code>-fsanitize=thread</code> for GCC/Clang) in the CI, and the stress test must pass without any reported data races.</li>
<li><b>Possible Roadblocks:</b> Threading bugs can be notoriously difficult to reproduce reliably; requires a sanitizer-compatible toolchain.</li>
</ul>
</li>
<li>[x] <b>Use Guard Pages for Freed Trampolines</b><ul>
<li><b>Context:</b> After a trampoline is freed, its function pointer becomes a dangling pointer. If a user accidentally calls it, a use-after-free vulnerability can be triggered.</li>
<li><b>Idea:</b> Instead of just releasing memory, change its protection to <code>PROT_NONE</code> (no read/write/execute). This turns a subtle vulnerability into a safe, immediate, and obvious crash.</li>
<li><b>Goal:</b> The <code>infix_executable_free</code> function is updated to use <code>mprotect</code>/<code>VirtualProtect</code>. A new test is created that frees a trampoline and then calls its old function pointer, asserting that the program safely terminates.</li>
<li><b>Possible Roadblocks:</b> Testing for an expected crash is non-trivial and may require platform-specific signal handling or process management in the test suite.</li>
</ul>
</li>
<li>[x] <b>Add <code>long double</code> Support</b><ul>
<li><b>Context:</b> <code>long double</code> was the last major C primitive type not supported by the library.</li>
<li><b>Idea:</b> Add a new primitive type and implement the correct, platform-specific ABI handling for it.</li>
<li><b>Goal:</b> <code>long double</code> is a recognized <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> and passes correctly in forward and reverse calls on all supported platforms (System V, Windows/GCC, AArch64).</li>
</ul>
</li>
<li>[x] <b>Read-Only Callback Contexts (RELRO for Callbacks)</b><ul>
<li><b>Context:</b> The <code><a class="el" href="structinfix__reverse__t.html">infix_reverse_t</a></code> struct contains function pointers that could be targeted by memory corruption attacks to hijack control flow.</li>
<li><b>Idea:</b> After a callback context is created, use <code>mprotect</code>/<code>VirtualProtect</code> on the memory page containing it to make it read-only.</li>
<li><b>Goal:</b> The context is hardened by default. Any attempt to write to a hardened context struct will cause an immediate segmentation fault, preventing the attack.</li>
<li><b>Possible Roadblocks:</b> <code>mprotect</code> operates on page boundaries, not on individual structs. This requires careful memory management to ensure unrelated writable data is not on the same page, which might make the implementation complex.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md230"></a>
&lt;strong&gt;Medium Priority: Expansion &amp; Optimization&lt;/strong&gt;</h1>
<p><em>Once the foundation is solid, these tasks focus on adding major new capabilities, improving performance, and expanding test coverage.</em></p>
<ul>
<li>[x] <b>Internal Arena Allocator</b><ul>
<li><b>Context:</b> The JIT generation process involves many small, short-lived memory allocations which can be inefficient and cause fragmentation.</li>
<li><b>Idea:</b> Implement a simple arena/pool allocator for the lifetime of a single trampoline generation to reduce <code>malloc</code> overhead.</li>
<li><b>Goal:</b> This is an internal optimization. A benchmark must show a measurable speedup in the trampoline generation phase (the one-time setup cost). Trampoline generation is now ~50x faster for complex signatures.</li>
<li><b>Possible Roadblocks:</b> Requires careful changes to internal APIs to pass the allocator context around; potential for subtle memory management bugs during implementation.</li>
</ul>
</li>
<li>[x] <b>Profile Code Generation and Execution</b><ul>
<li><b>Context:</b> Before optimizing, we need to identify performance bottlenecks. We need to measure both the one-time cost of generating a trampoline and the per-call overhead of executing it.</li>
<li><b>Idea:</b> Use platform-specific profiling tools (Valgrind/Callgrind, Instruments, VTune) to measure trampoline generation and execution overhead.</li>
<li><b>Goal:</b> A new document, <code>docs/performance.md</code>, is created to summarize the findings and guide future optimization work.</li>
<li><b>Possible Roadblocks:</b> Profiling JIT'd code can be complex, as symbols may not be easily visible in standard profilers.</li>
</ul>
</li>
<li>[x] <b>Implement Packed Argument Trampolines</b><ul>
<li><b>Context:</b> The current <code>void** args</code> API requires pointer indirection. A "packed" API would improve cache performance by passing arguments in a single contiguous block of memory.</li>
<li><b>Idea:</b> Implement <code>infix_forward_create_packed</code>, where the JIT'd code reads arguments from offsets relative to a single pointer.</li>
<li><b>Goal:</b> A benchmark demonstrates a significant performance improvement for calls with many arguments compared to the standard trampoline.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md231"></a>
&lt;strong&gt;Low Priority: Advanced Features &amp; Polish&lt;/strong&gt;</h1>
<p><em>These items are valuable but less critical. They can be addressed over time to round out the library's feature set.</em></p>
<ul>
<li>[ ] <b>Implement RISC-V 64-bit ABI</b><ul>
<li><b>Context:</b> RISC-V is a growing open-source architecture. Adding support would demonstrate the library's portability.</li>
<li><b>Idea:</b> Create a new <code>abi_riscv.c</code> file and associated low-level instruction emitters, following the roadmap in <code>internals.md</code>.</li>
<li><b>Goal:</b> The library successfully compiles and passes the entire test suite on a RISC-V 64-bit platform (e.g., in QEMU within the CI).</li>
<li><b>Possible Roadblocks:</b> Access to RISC-V hardware or a reliable CI-based emulator is required for testing.</li>
</ul>
</li>
<li>[ ] **(Re-scoped) Enhance <code>symbol_finder.pl</code> with Multi-Language Demangling**<ul>
<li><b>Context:</b> The <code>symbol_finder.pl</code> script can be extended to demangle symbols from C++, Rust, and Fortran, making it a powerful tool for FFI development.</li>
<li><b>Idea:</b> Adopt a pragmatic, phased approach to implementation.</li>
<li><b>Goal:</b><ul>
<li><b>Phase 1:</b> The script shells out to standard toolchains (<code>c++filt</code> for Itanium) for immediate functionality.</li>
<li><b>Phase 2:</b> Begin the major task of writing pure-Perl demanglers from scratch for Itanium C++ and Rust v0 to remove all external tool dependencies.</li>
</ul>
</li>
<li><b>Possible Roadblocks:</b> Writing full-featured demanglers from scratch (Phase 2) is an extremely large and complex undertaking.</li>
</ul>
</li>
<li>[ ] <b>Direct System Call Interface</b><ul>
<li><b>Context:</b> Some advanced applications need to bypass standard C libraries and make direct calls to the OS kernel, which uses a different, low-level ABI.</li>
<li><b>Idea:</b> Create a new <code>infix_syscall_create</code> API that emits assembly to load registers and execute the <code>syscall</code> instruction.</li>
<li><b>Goal:</b> A user can successfully call a basic OS syscall, such as <code>write</code> on Linux, using a generated trampoline.</li>
<li><b>Possible Roadblocks:</b> Extremely high implementation cost. Requires a unique ABI implementation for every supported OS. Testing is very difficult and OS-specific.</li>
</ul>
</li>
<li>[ ] <b>Add Exception Handling Boundary</b><ul>
<li><b>Context:</b> An unhandled C++ or SEH exception that crosses the FFI boundary will crash the program. A robust library should provide a way to handle this.</li>
<li><b>Idea:</b> Create a <code>infix_forward_create_safe</code> function where the JIT code wraps the native call in a <code>try...catch</code> or <code>__try...__except</code> block.</li>
<li><b>Goal:</b> If a native function throws an exception, the trampoline catches it, returns <code>INFIX_ERROR_NATIVE_EXCEPTION</code>, and the program does not crash.</li>
<li><b>Possible Roadblocks:</b> This requires mixing C and C++ or using platform-specific SEH, which adds significant complexity and potential portability issues.</li>
</ul>
</li>
<li>[ ] <b>Add Bitfield Support in Structs</b><ul>
<li><b>Context:</b> C allows structs to have bitfields, but their memory layout is highly compiler-specific. Supporting them is an advanced FFI feature.</li>
<li><b>Idea:</b> Extend the <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> system to describe bitfields and implement the packing/unpacking logic for each ABI.</li>
<li><b>Goal:</b> Successfully call a function that takes a struct containing bitfields and get the correct result.</li>
<li><b>Possible Roadblocks:</b> This is a notoriously difficult part of FFI implementation, as bitfield layout rules are often poorly documented and vary even between versions of the same compiler.</li>
</ul>
</li>
<li>[ ] <strike><b>Add Type System Builder API</b></strike><ul>
<li><strike><b>Context:</b> The current Manual API for creating complex structs is verbose and requires manual memory management for the member array within the arena.</strike></li>
<li><strike><b>Idea:</b> Create a fluent builder pattern API (e.g., <code>infix_struct_builder_*</code> functions) to simplify type creation.</strike></li>
<li><strike><b>Goal:</b> A user can define a complex struct without manually allocating or managing the <code><a class="el" href="structinfix__struct__member.html" title="Describes a single member of an aggregate type (struct or union).">infix_struct_member</a></code> array, reducing boilerplate and potential for errors.</strike></li>
<li>Supplanted by signature API.</li>
</ul>
</li>
<li>[ ] <b>Add Support for 32-bit Architectures</b><ul>
<li><b>Context:</b> A major future direction to support legacy or embedded systems.</li>
<li><b>Idea:</b> Create new ABI backends for 32-bit x86 and ARM.</li>
<li><b>Goal:</b> The library compiles and passes the test suite when targeting a 32-bit architecture.</li>
<li><b>Possible Roadblocks:</b> This is a very large undertaking, effectively doubling the number of supported ABIs that must be maintained and tested.</li>
</ul>
</li>
<li>[x] <b>Decouple Debug Logging from <code><a class="el" href="double__tap_8h.html" title="A simple, header-only TAP14-compatible testing framework for C.">double_tap.h</a></code></b><ul>
<li><b>Context:</b> The library's internal <code>INFIX_DEBUG_PRINTF</code> macro should not be tied to the test framework's <code>note()</code> function, which improves modularity.</li>
<li><b>Idea:</b> Refactor <code>INFIX_DEBUG_PRINTF</code> in <code><a class="el" href="utility_8h.html" title="A header for debugging utilities that are conditionally compiled.">utility.h</a></code> to use <code>fprintf(stderr, ...)</code> directly.</li>
<li><b>Goal:</b> The library source code (<code>src/</code>) has no includes of <code><a class="el" href="double__tap_8h.html" title="A simple, header-only TAP14-compatible testing framework for C.">double_tap.h</a></code>. Internal debug messages are printed to <code>stderr</code> when <code>INFIX_DEBUG_ENABLED</code> is active.</li>
<li><b>Possible Roadblocks:</b> Minimal; this is a straightforward refactoring task.</li>
</ul>
</li>
<li>[x] <b>Investigate and Fix Read-Only Context on macOS</b><ul>
<li><b>Context:</b> The read-only hardening for reverse trampoline contexts does not currently work on macOS due to platform-specific memory protection behavior.</li>
<li><b>Idea:</b> Research the correct combination of <code>mmap</code> flags and/or other system calls required to create a reliably read-only data page on macOS.</li>
<li><b>Goal:</b> The "Writing to a hardened reverse trampoline context causes a crash" test passes successfully on macOS.</li>
<li><b>Possible Roadblocks:</b> This may require deep knowledge of macOS virtual memory and could be more complex than on other POSIX systems.</li>
</ul>
</li>
<li>[ ] **Add Support for Advanced C Types (<code>_Complex</code> and SIMD)**<ul>
<li><b>Context:</b> Modern C and its common extensions include types for complex numbers (<code>float _Complex</code>, <code>double _Complex</code>) and SIMD vectors (<code>__m128</code>, NEON types) that have specific ABI passing rules. Supporting them directly would improve interoperability with scientific and multimedia libraries.</li>
<li><b>Idea:</b> Extend the <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> system with new categories or primitives for these types. Implement the corresponding ABI classification and marshalling logic in each backend. For example, <code>_Complex</code> types are often passed as if they were a two-element struct of floats/doubles.</li>
<li><b>Goal:</b> A user can create an <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> for <code>double _Complex</code> and successfully call a function that uses it, with the library handling the ABI rules correctly on all supported platforms.</li>
<li><b>Possible Roadblocks:</b> SIMD types in particular have very platform-specific ABI rules that will require careful research for each backend. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
