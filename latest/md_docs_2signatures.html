<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>infix FFI Library: FFI Signature Format Specification v1.0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">infix FFI Library<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">FFI Signature Format Specification v1.0</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md164"></a> </p>
<h2><a class="anchor" id="autotoc_md165"></a>
Part 1: Introduction</h2>
<h3><a class="anchor" id="autotoc_md166"></a>
1.1 The Challenge of Interoperability</h3>
<p>In modern software development, it is rare for a system to be built in a single programming language. High-performance libraries are often written in C, C++, or Rust, while applications are built in Python, C#, Java, or JavaScript. The bridge between these worlds is the Foreign Function Interface (FFI). An FFI allows code written in one language to call functions and manipulate data structures defined in another.</p>
<p>The core challenge of any FFI is establishing a precise, unambiguous contract between the caller and the callee. Both sides must agree on the exact size, alignment, and representation of every piece of data. Failure to do so results in stack corruption, crashes, and security vulnerabilities.</p>
<h3><a class="anchor" id="autotoc_md167"></a>
1.2 The Limitations of C Declarations</h3>
<p>For decades, the de facto standard for this contract has been the C header file. However, C's declaration syntax, while powerful, is notoriously difficult for both humans and machines to parse. It requires a complex "spiral rule" to decipher, is filled with ambiguity, and often hides the true memory layout of data. A declaration like <code>void (*(*f[])())()</code> is a testament to this complexity, being nearly unreadable while describing a valid type.</p>
<h3><a class="anchor" id="autotoc_md168"></a>
1.3 Our Solution: A Human-First Signature System</h3>
<p>This document specifies a new FFI signature format designed from the ground up to solve these problems. It is a concise, string-based representation of C types and function signatures, built on three core principles:</p>
<ol type="1">
<li><b>Human-Readability First:</b> The syntax is intuitive and immediately understandable to a developer familiar with C-family languages. It prioritizes clarity over absolute, machine-focused compactness.</li>
<li><b>Unambiguous and Consistent:</b> The grammar is designed to be parsed linearly (left-to-right) without the precedence battles and ambiguities of C's syntax. A given symbol or structure has a single, consistent meaning.</li>
<li><b>Developer-Centric Type System:</b> It provides two tiers of types: abstract C-style keywords for platform portability, and explicit fixed-width keywords for when precise memory layout is paramount.</li>
</ol>
<h3><a class="anchor" id="autotoc_md169"></a>
1.4 A Stateless, Composable Core</h3>
<p>A key architectural principle of this specification is that the core FFI library remains <b>stateless</b>. The FFI's responsibility is to parse a complete, self-contained signature string and prepare a function call. It does not maintain a global type registry.</p>
<p>This design empowers the user. The management of named types is handled by the user or a higher-level binding generator, typically through a simple dictionary or map. This allows for maximum flexibility, composability, and thread-safety. A user can maintain separate type registries for different libraries and compose them as needed. The process is simple:</p>
<ol type="1">
<li>Define complex types using their full, descriptive signature.</li>
<li>Store these definitions in a user-space registry (e.g., a hash map).</li>
<li>When preparing a function call, use a simple string replacement or a more sophisticated resolver to construct the final, fully-qualified signature string.</li>
<li>Pass this complete string to the stateless FFI core.</li>
</ol>
<p>This separation of concerns—type management vs. call invocation—is a cornerstone of this design's robustness.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md170"></a>
Part 2: The Type System Reference</h1>
<p>The signature system is composed of primitive types, type constructors, composite data structures, and function types.</p>
<h2><a class="anchor" id="autotoc_md171"></a>
2.1 Tier 1: Abstract C Types</h2>
<p>These keywords represent standard C types whose size can vary by platform. The FFI implementation is responsible for resolving them to the correct size and alignment for the target ABI. Use these for portable bindings to standard C libraries.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Signature   </th><th class="markdownTableHeadLeft">Size   </th><th class="markdownTableHeadLeft">C/C++ Equivalent   </th><th class="markdownTableHeadLeft">Rust Equivalent   </th><th class="markdownTableHeadLeft">Python <code>ctypes</code> Equivalent   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>void</code>   </td><td class="markdownTableBodyLeft">N/A   </td><td class="markdownTableBodyLeft"><code>void</code>   </td><td class="markdownTableBodyLeft"><code>()</code> (unit type)   </td><td class="markdownTableBodyLeft"><code>None</code> (return value)   </td><td class="markdownTableBodyLeft">Represents the absence of a value, typically for a function's return.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>char</code>   </td><td class="markdownTableBodyLeft">8 bits   </td><td class="markdownTableBodyLeft"><code>signed char</code>   </td><td class="markdownTableBodyLeft"><code>i8</code> (<code>std::os::raw::c_char</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_char</code>   </td><td class="markdownTableBodyLeft">A signed 8-bit integer, conventionally used for ASCII characters.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>uchar</code>   </td><td class="markdownTableBodyLeft">8 bits   </td><td class="markdownTableBodyLeft"><code>unsigned char</code>   </td><td class="markdownTableBodyLeft"><code>u8</code> (<code>std::os::raw::c_uchar</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_ubyte</code>   </td><td class="markdownTableBodyLeft">An unsigned 8-bit integer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>short</code>   </td><td class="markdownTableBodyLeft">16 bits   </td><td class="markdownTableBodyLeft"><code>short</code>   </td><td class="markdownTableBodyLeft"><code>i16</code> (<code>std::os::raw::c_short</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_short</code>   </td><td class="markdownTableBodyLeft">A signed integer of at least 16 bits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ushort</code>   </td><td class="markdownTableBodyLeft">16 bits   </td><td class="markdownTableBodyLeft"><code>unsigned short</code>   </td><td class="markdownTableBodyLeft"><code>u16</code> (<code>std::os::raw::c_ushort</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_ushort</code>   </td><td class="markdownTableBodyLeft">An unsigned integer of at least 16 bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>int</code>   </td><td class="markdownTableBodyLeft">32 bits   </td><td class="markdownTableBodyLeft"><code>int</code>   </td><td class="markdownTableBodyLeft"><code>i32</code> (<code>std::os::raw::c_int</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_int</code>   </td><td class="markdownTableBodyLeft">The platform's native signed integer; at least 16 bits, usually 32.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>uint</code>   </td><td class="markdownTableBodyLeft">32 bits   </td><td class="markdownTableBodyLeft"><code>unsigned int</code>   </td><td class="markdownTableBodyLeft"><code>u32</code> (<code>std::os::raw::c_uint</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_uint</code>   </td><td class="markdownTableBodyLeft">The platform's native unsigned integer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>long</code>   </td><td class="markdownTableBodyLeft"><b>32 or 64 bits</b>   </td><td class="markdownTableBodyLeft"><code>long</code>   </td><td class="markdownTableBodyLeft"><code>i32</code>/<code>i64</code> (<code>c_long</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_long</code>   </td><td class="markdownTableBodyLeft"><b>The key abstract integer.</b> 32 bits on 64-bit Windows, 64 bits on Linux.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ulong</code>   </td><td class="markdownTableBodyLeft"><b>32 or 64 bits</b>   </td><td class="markdownTableBodyLeft"><code>unsigned long</code>   </td><td class="markdownTableBodyLeft"><code>u32</code>/<code>u64</code> (<code>c_ulong</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_ulong</code>   </td><td class="markdownTableBodyLeft">The unsigned version of <code>long</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>longlong</code>   </td><td class="markdownTableBodyLeft">64 bits   </td><td class="markdownTableBodyLeft"><code>long long</code>   </td><td class="markdownTableBodyLeft"><code>i64</code> (<code>c_longlong</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_longlong</code>   </td><td class="markdownTableBodyLeft">A signed integer of at least 64 bits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>ulonglong</code>   </td><td class="markdownTableBodyLeft">64 bits   </td><td class="markdownTableBodyLeft"><code>unsigned long long</code>   </td><td class="markdownTableBodyLeft"><code>u64</code> (<code>c_ulonglong</code>)   </td><td class="markdownTableBodyLeft"><code>ctypes.c_ulonglong</code>   </td><td class="markdownTableBodyLeft">An unsigned integer of at least 64 bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>float</code>   </td><td class="markdownTableBodyLeft">32 bits   </td><td class="markdownTableBodyLeft"><code>float</code>   </td><td class="markdownTableBodyLeft"><code>f32</code>   </td><td class="markdownTableBodyLeft"><code>ctypes.c_float</code>   </td><td class="markdownTableBodyLeft">A 32-bit single-precision floating-point number.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>double</code>   </td><td class="markdownTableBodyLeft">64 bits   </td><td class="markdownTableBodyLeft"><code>double</code>   </td><td class="markdownTableBodyLeft"><code>f64</code>   </td><td class="markdownTableBodyLeft"><code>ctypes.c_double</code>   </td><td class="markdownTableBodyLeft">A 64-bit double-precision floating-point number.   </td></tr>
</table>
<p>See <a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(basic_instructions)">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(basic_instructions)</a> for more languages to compare against.</p>
<h2><a class="anchor" id="autotoc_md172"></a>
2.2 Tier 2: Explicit Fixed-Width Types</h2>
<p>These keywords are used when the exact size of a type is known and required. This is essential for network protocols, file formats, and fixed-layout APIs.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Signature Keyword   </th><th class="markdownTableHeadLeft">Common C Equivalent   </th><th class="markdownTableHeadLeft">Size   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>int8</code>, <code>uint8</code>   </td><td class="markdownTableBodyLeft"><code>int8_t</code>, <code>uint8_t</code>   </td><td class="markdownTableBodyLeft">8 bits   </td><td class="markdownTableBodyLeft">Explicitly-sized 8-bit signed/unsigned integers.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>int16</code>, <code>uint16</code>   </td><td class="markdownTableBodyLeft"><code>int16_t</code>, <code>uint16_t</code>   </td><td class="markdownTableBodyLeft">16 bits   </td><td class="markdownTableBodyLeft">Explicitly-sized 16-bit signed/unsigned integers.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>int32</code>, <code>uint32</code>   </td><td class="markdownTableBodyLeft"><code>int32_t</code>, <code>uint32_t</code>   </td><td class="markdownTableBodyLeft">32 bits   </td><td class="markdownTableBodyLeft">Explicitly-sized 32-bit signed/unsigned integers.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>int64</code>, <code>uint64</code>   </td><td class="markdownTableBodyLeft"><code>int64_t</code>, <code>uint64_t</code>   </td><td class="markdownTableBodyLeft">64 bits   </td><td class="markdownTableBodyLeft">Explicitly-sized 64-bit signed/unsigned integers.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>int128</code>, <code>uint128</code>   </td><td class="markdownTableBodyLeft"><code>__int128_t</code>   </td><td class="markdownTableBodyLeft">128 bits   </td><td class="markdownTableBodyLeft">128-bit integers, a common compiler extension.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>float32</code>   </td><td class="markdownTableBodyLeft"><code>float</code>   </td><td class="markdownTableBodyLeft">32 bits   </td><td class="markdownTableBodyLeft">An explicit alias for a 32-bit float.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>float64</code>   </td><td class="markdownTableBodyLeft"><code>double</code>   </td><td class="markdownTableBodyLeft">64 bits   </td><td class="markdownTableBodyLeft">An explicit alias for a 64-bit float.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>float80</code>   </td><td class="markdownTableBodyLeft"><code>long double</code> (x86)   </td><td class="markdownTableBodyLeft">80 bits   </td><td class="markdownTableBodyLeft">An 80-bit extended-precision float, used by x86 ABIs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>float128</code>   </td><td class="markdownTableBodyLeft"><code>long double</code> (PPC/SPARC)   </td><td class="markdownTableBodyLeft">128 bits   </td><td class="markdownTableBodyLeft">A 128-bit quadruple-precision float.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md173"></a>
2.3 Advanced Numeric and Vector Types</h2>
<p>These are defined for forward compatibility in high-performance computing.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">Signature Syntax   </th><th class="markdownTableHeadLeft">C Equivalent   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Complex <a class="el" href="unionNumber.html" title="A simple union of an integer and a float.">Number</a></b>   </td><td class="markdownTableBodyLeft"><code>c[&lt;type&gt;]</code>   </td><td class="markdownTableBodyLeft"><code>float _Complex</code>   </td><td class="markdownTableBodyLeft">A complex number, constructed from a floating-point <code>&lt;type&gt;</code>. The memory layout is equivalent to <code>[2:&lt;type&gt;]</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>128-bit SIMD Vector</b>   </td><td class="markdownTableBodyLeft"><code>v[2:double]</code> <br  />
 <code>v[4:float]</code>   </td><td class="markdownTableBodyLeft"><code>__m128d</code> <br  />
 <code>__m128</code>   </td><td class="markdownTableBodyLeft">A 128-bit SSE vector. Passed in a single XMM/NEON register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>256-bit SIMD Vector</b>   </td><td class="markdownTableBodyLeft"><code>v[4:double]</code> <br  />
 <code>v[8:float]</code>   </td><td class="markdownTableBodyLeft"><code>__m256d</code> <br  />
 <code>__m256</code>   </td><td class="markdownTableBodyLeft">A 256-bit AVX vector. Requires AVX support. Passed in a YMM register on System V or by reference on Windows.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Opaque Vector</b>   </td><td class="markdownTableBodyLeft"><code>v&lt;bits&gt;</code>   </td><td class="markdownTableBodyLeft">N/A   </td><td class="markdownTableBodyLeft">A fallback for rare cases where a SIMD value's element types are unknown.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md174"></a>
2.4 Type Constructors and Composite Structures</h2>
<p>A key design principle is the distinction between types defined by a <b>body</b> (<code>struct</code>, <code>union</code>) and types that are semantic <b>aliases</b> (<code>enum</code>).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Name   </th><th class="markdownTableHeadLeft">Syntax   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Pointer</b>   </td><td class="markdownTableBodyLeft"><code>*&lt;type&gt;</code>   </td><td class="markdownTableBodyLeft">The asterisk <code>*</code> is the universal prefix for a pointer to any other valid type. <code>*void</code> is the generic pointer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Array</b>   </td><td class="markdownTableBodyLeft"><code>[&lt;size&gt;:&lt;type&gt;]</code>   </td><td class="markdownTableBodyLeft">A fixed-size array. The colon <code>:</code> separates the size descriptor from the element type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Struct</b>   </td><td class="markdownTableBodyLeft"><code>struct&lt;Name&gt;{...}</code> <br  />
 <code>{...}</code>   </td><td class="markdownTableBodyLeft">A C <code>struct</code>, defined by its <code>{...}</code> body. The named form is for definition; the anonymous form is for inline use.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Union</b>   </td><td class="markdownTableBodyLeft"><code>union&lt;Name&gt;&lt;...&gt;</code> <br  />
 <code>&lt;...&gt;</code>   </td><td class="markdownTableBodyLeft">A C <code>union</code>, defined by its <code>&lt;...&gt;</code> body. The named form is for definition; the anonymous form is for inline use.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Enum</b>   </td><td class="markdownTableBodyLeft"><code>e&lt;Name&gt;:&lt;type&gt;</code> <br  />
 <code>e:&lt;type&gt;</code>   </td><td class="markdownTableBodyLeft">A C <code>enum</code>. This is a semantic alias for an underlying integer <code>&lt;type&gt;</code>, which is <b>required</b>. The named form is for definition; the anonymous form <code>e:</code> is for inline use.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Function Signature</b>   </td><td class="markdownTableBodyLeft"><code>(&lt;arg_types&gt;) -&gt; &lt;return_type&gt;</code>   </td><td class="markdownTableBodyLeft">Defines the type of a function. Arguments may be named (<code>(name:type)</code>) or anonymous (<code>(type)</code>).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Variadic Signature</b>   </td><td class="markdownTableBodyLeft"><code>(&lt;fixed_args&gt;; &lt;variadic_args&gt;) -&gt; &lt;return_type&gt;</code>   </td><td class="markdownTableBodyLeft">Defines a function signature. Fixed arguments are separated by commas. A semicolon <code>;</code> <b>must</b> appear to separate the fixed arguments from the variadic arguments.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Function Pointer</b>   </td><td class="markdownTableBodyLeft"><code>*((&lt;arg_types&gt;) -&gt; &lt;return_type&gt;)</code>   </td><td class="markdownTableBodyLeft">A pointer to a function. This follows the universal pointer rule: it is a pointer <code>*</code> to a function signature type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Variadic Function Pointer</b>   </td><td class="markdownTableBodyLeft"><code>*(&lt;fixed_args&gt;; &lt;variadic_args&gt;) -&gt; &lt;return_type&gt;)</code>   </td><td class="markdownTableBodyLeft">A pointer to a variadic function. This follows the universal pointer rule: it is a pointer <code>*</code> to a function signature type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Annotations</b>   </td><td class="markdownTableBodyLeft"><code>"name" &lt;type_or_signature&gt;</code>   </td><td class="markdownTableBodyLeft">Optional string literal prefixes that provide additional ABI details. Standardized annotations include <code>"stdcall"</code>, <code>"cdecl"</code>, and <code>"fastcall"</code>. Interpretation of other annotations is implementation-defined.   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md175"></a>
Part 3: Examples, Best Practices, and Usage</h2>
<h3><a class="anchor" id="autotoc_md176"></a>
3.1 Syntax Showcase</h3>
<p>This table provides a wide variety of examples to demonstrate the expressiveness and clarity of the signature format.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">FFI Signature   </th><th class="markdownTableHeadLeft">Breakdown    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>int</code>   </td><td class="markdownTableBodyLeft">A standard C signed integer, typically 32 bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>*char</code>   </td><td class="markdownTableBodyLeft">A pointer to a standard C signed character.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>**void</code>   </td><td class="markdownTableBodyLeft">A pointer to a generic <code>void</code> pointer. Often used for out-parameters.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>[16:char]</code>   </td><td class="markdownTableBodyLeft">An array of 16 signed characters.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>*[16:char]</code>   </td><td class="markdownTableBodyLeft">A pointer to an array of 16 signed characters.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>{int, float}</code>   </td><td class="markdownTableBodyLeft">An anonymous struct containing an <code>int</code> followed by a <code>float</code>, with platform-default alignment.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>{id:uint64, score:double}</code>   </td><td class="markdownTableBodyLeft">An anonymous struct with two named fields, a <code>uint64</code> and a <code>double</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>!{id:uint16, status:char}</code>   </td><td class="markdownTableBodyLeft">A packed struct (1-byte alignment) with two named fields. <code>status</code> will be at offset 2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>!4:{a:char, b:longlong}</code>   </td><td class="markdownTableBodyLeft">A packed struct with 4-byte alignment. <code>b</code> will be padded to start at an offset of 4.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>{a:int, nested:{b:char, c:char}}</code>   </td><td class="markdownTableBodyLeft">A struct containing a nested anonymous struct.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>&lt;int, float64&gt;</code>   </td><td class="markdownTableBodyLeft">An anonymous union that can hold either an <code>int</code> or a 64-bit <code>float64</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>&lt;as_int:int32, as_ptr:*void&gt;</code>   </td><td class="markdownTableBodyLeft">An anonymous union with two named fields, a 32-bit <code>int</code> and a generic pointer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>() -&gt; void</code>   </td><td class="markdownTableBodyLeft">A function that takes no arguments and returns nothing.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>(*char, int) -&gt; int</code>   </td><td class="markdownTableBodyLeft">A function that takes a <code>*char</code> and an <code>int</code>, and returns an <code>int</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>(*char; int, double) -&gt; int</code>   </td><td class="markdownTableBodyLeft">A variadic call to <code>printf("%d %f", ...)</code> taking a <code>*char</code>, an <code>int</code>, and a <code>double</code>. The semicolon <code>;</code> marks the start of the variadic part.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>"stdcall" (*void, uint32) -&gt; int</code>   </td><td class="markdownTableBodyLeft">A Windows API-style function using the <code>stdcall</code> calling convention.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>e:int</code>   </td><td class="markdownTableBodyLeft">An anonymous enum whose underlying ABI type is <code>int</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>e&lt;Color&gt;:uint8</code>   </td><td class="markdownTableBodyLeft">The definition of a named enum <code>Color</code> whose underlying ABI type is <code>uint8</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>struct&lt;<a class="el" href="structPoint.html" title="A simple struct with two doubles. Small enough to be passed in registers on some ABIs.">Point</a>&gt;{x:float, y:float}</code>   </td><td class="markdownTableBodyLeft">The definition of a named struct <code><a class="el" href="structPoint.html" title="A simple struct with two doubles. Small enough to be passed in registers on some ABIs.">Point</a></code> with two float fields.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>*struct&lt;<a class="el" href="structPoint.html" title="A simple struct with two doubles. Small enough to be passed in registers on some ABIs.">Point</a>&gt;</code>   </td><td class="markdownTableBodyLeft">A pointer to a previously-defined <code>struct&lt;<a class="el" href="structPoint.html" title="A simple struct with two doubles. Small enough to be passed in registers on some ABIs.">Point</a>&gt;</code>. This is the "reference" form.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>union&lt;Value&gt;&lt;as_int:int, as_ptr:*void&gt;</code>   </td><td class="markdownTableBodyLeft">The definition of a named union <code>Value</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>*union&lt;Value&gt;</code>   </td><td class="markdownTableBodyLeft">A pointer to a previously-defined <code>union&lt;Value&gt;</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>*((int, int) -&gt; int)</code>   </td><td class="markdownTableBodyLeft">A pointer to a function that takes two <code>int</code>s and returns an <code>int</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>struct&lt;Ctx&gt;{ data:*void, callback:*( (int) -&gt; void ) }</code>   </td><td class="markdownTableBodyLeft">A struct with a function pointer field named <code>callback</code>. The callback takes an <code>int</code> and returns <code>void</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>c[float]</code>   </td><td class="markdownTableBodyLeft">A C <code>float _Complex</code> number, with the same memory layout as <code>[2:float]</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>v[4:float]</code>   </td><td class="markdownTableBodyLeft">A 128-bit SIMD vector containing four 32-bit floats (e.g., SSE <code>__m128</code>).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>v[4:double]</code>   </td><td class="markdownTableBodyLeft">A 256-bit SIMD vector containing four 64-bit doubles (e.g., AVX <code>__m256d</code>). Requires AVX support to be enabled.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md177"></a>
3.2 Architectural Pattern: Define and Use</h3>
<p>This example demonstrates the "define once, use by reference" pattern that the stateless FFI architecture enables.</p>
<ul>
<li><b>C Code:</b> <code>c enum Status { OK, PENDING, ERROR }; struct Result { long long id; enum Status status; }; int process_results(struct Result results[], int count); </code></li>
<li><b>Step 1: Conceptually Define Types in a User-Space Registry</b> <code>javascript // A simple key-value map in the user's application const type_registry = { "Status": "e&lt;Status&gt;:int", "Result": "struct&lt;Result&gt;{id:longlong, status:e&lt;Status&gt;}" }; </code></li>
<li><b>Step 2: Define the Function Signature Using References</b><ul>
<li><b>High-Level Signature:</b> <code>(*struct&lt;Result&gt;, int) -&gt; int</code></li>
</ul>
</li>
<li><b>Step 3: Resolve the Final Signature String</b><ul>
<li>The user's wrapper code resolves the references, producing a complete, self-contained string to pass to the FFI.</li>
<li><b>Final Resolved Signature:</b> <code>(*struct&lt;Result&gt;{id:longlong, status:e&lt;Status&gt;:int}, int) -&gt; int</code></li>
</ul>
</li>
<li><b>Step 4: Pass to the Stateless FFI Core</b><ul>
<li>The FFI core receives this final string, parses it, and prepares the call without needing any external context.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md178"></a>
3.3 Common Pitfalls and Solutions</h3>
<ol type="1">
<li><b>Pitfall: <code>long double</code> Ambiguity</b><ul>
<li><b>Problem:</b> A library is compiled with GCC on Linux, where <code>long double</code> is an 80-bit float. The user writes the signature as <code>double</code>, assuming it's 64 bits. This causes a stack corruption.</li>
<li><b>Solution:</b> The signature must describe the <b>target library's ABI</b>, not the host's. The user must be explicit and use the correct Tier 2 type. For a GCC Linux library, the correct signature is <code>float80</code>. For an MSVC Windows library, the correct signature is <code>float64</code> (or <code>double</code>).</li>
</ul>
</li>
<li><b>Pitfall: Pointer Ownership and Memory Leaks</b><ul>
<li><b>Problem:</b> A C function <code>char* create_message()</code> returns a newly allocated string, but this is not captured in the signature, leading to memory leaks.</li>
<li><b>Solution:</b> While a full ownership system is beyond the scope of this v1.0 specification, the <code>"owned"</code> and <code>"borrowed"</code> annotations are reserved for this purpose. An FFI implementation can use them to provide safer memory management. For example, a binding generator seeing <code>() -&gt; "owned" *char</code> could automatically generate code to free the string's memory when it is no longer in use.</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md179"></a>
3.4 Benefits for Tooling and Mental Modeling</h3>
<ul>
<li><b>Introspection:</b> This format is a machine-readable schema. A tool can parse <code>!{id:uint16, data:[16:uint8]}</code> and instantly calculate its size, determine field offsets, generate GUIs, or create safe, high-level object bindings in the host language.</li>
<li><b>Mental Model:</b> The linear, left-to-right syntax allows a developer to reason about complex C types without cognitive overhead. The signature <code>*([16:*{...}])</code> is read simply as "a pointer to an array of 16 pointers to a struct." This replaces the error-prone "[spiral rule](https://c-faq.com/decl/spiral.anderson.html)" of C with a simple, declarative description of the type.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md180"></a>
Part 4: Technical Specification and Design Rationale</h1>
<h3><a class="anchor" id="autotoc_md181"></a>
4.1 Whitespace and Comments</h3>
<p>Insignificant whitespace (spaces, tabs, newlines) is permitted between any two tokens and should be ignored by a compliant parser. Comments begin with a hash symbol (<code>#</code>) and continue to the end of the line.</p>
<h3><a class="anchor" id="autotoc_md182"></a>
4.2 EBNF Grammar</h3>
<p>This Extended Backus-Naur Form grammar formally defines the signature format.</p>
<div class="fragment"><div class="line">signature           ::= function_type | value_type</div>
<div class="line"> </div>
<div class="line">value_type          ::= pointer_type | array_type | aggregate_type | enum_type | primitive_type | grouped_type</div>
<div class="line"> </div>
<div class="line">pointer_type        ::= &#39;*&#39; value_type</div>
<div class="line">array_type          ::= &#39;[&#39; Integer &#39;:&#39; value_type &#39;]&#39;</div>
<div class="line">grouped_type        ::= &#39;(&#39; value_type &#39;)&#39;</div>
<div class="line"> </div>
<div class="line">aggregate_type      ::= struct_type | union_type | packed_struct_type</div>
<div class="line">struct_type         ::= ( &#39;struct&#39; &#39;&lt;&#39; Identifier &#39;&gt;&#39; )? &#39;{&#39; member_list? &#39;}&#39;</div>
<div class="line">union_type          ::= ( &#39;union&#39; &#39;&lt;&#39; Identifier &#39;&gt;&#39; )? &#39;&lt;&#39; member_list? &#39;&gt;&#39;</div>
<div class="line">packed_struct_type  ::= &#39;packed&#39; &#39;(&#39; Integer &#39;,&#39; Integer &#39;)&#39; &#39;struct&#39; &#39;{&#39; packed_member_list? &#39;}&#39;</div>
<div class="line">member_list         ::= member ( &#39;,&#39; member )*</div>
<div class="line">packed_member_list  ::= packed_member ( &#39;,&#39; packed_member )*</div>
<div class="line">member              ::= ( Identifier &#39;:&#39; )? value_type</div>
<div class="line">packed_member       ::= ( Identifier &#39;:&#39; )? value_type &#39;@&#39; Integer</div>
<div class="line"> </div>
<div class="line">enum_type           ::= &#39;e&#39; ( &#39;&lt;&#39; Identifier &#39;&gt;&#39; )? &#39;:&#39; primitive_type</div>
<div class="line"> </div>
<div class="line">function_type       ::= &#39;(&#39; arg_list? &#39;)&#39; &#39;-&gt;&#39; value_type</div>
<div class="line">arg_list            ::= arg ( &#39;,&#39; arg )* ( &#39;,&#39; &#39;...&#39; )?</div>
<div class="line">arg                 ::= ( Identifier &#39;:&#39; )? value_type</div>
<div class="line"> </div>
<div class="line">primitive_type      ::= &#39;void&#39; | &#39;bool&#39; | &#39;char&#39; | &#39;uchar&#39; | &#39;short&#39; | &#39;ushort&#39; | &#39;int&#39; | &#39;uint&#39; | &#39;long&#39; | &#39;ulong&#39; | &#39;longlong&#39; | &#39;ulonglong&#39; | &#39;float&#39; | &#39;double&#39; | &#39;long_double&#39; | &#39;int8&#39; | &#39;uint8&#39; | &#39;int16&#39; | &#39;uint16&#39; | &#39;int32&#39; | &#39;uint32&#39; | &#39;int64&#39; | &#39;uint64&#39; | &#39;int128&#39; | &#39;uint128&#39; | &#39;float32&#39; | &#39;float64&#39; | &#39;float80&#39; | &#39;float128&#39;</div>
<div class="line"> </div>
<div class="line">Identifier          ::= [a-zA-Z_] [a-zA-Z0-9_]*</div>
<div class="line">Integer             ::= [0-9]+</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md183"></a>
4.3 Design Rationale: Why This Syntax?</h3>
<ol type="1">
<li><b>The Two-Tier Type System over a Single-Character Encoding:</b> Our two-tier system (<code>int</code> vs. <code>int32</code>) directly maps to the developer's intent: "Do I want this to be portable or do I need a specific layout?" This is more explicit and readable than a machine-first encoding like the Itanium ABI's (<code>i</code> vs. <code>x</code>).</li>
<li><b>Universal Prefix Modifiers and Delimited Constructors:</b> C's syntax complexity stems from the precedence battle between prefix <code>*</code> and postfix <code>[]</code> and <code>()</code>. Our system uses a pure prefix approach for pointers (<code>*</code>) and clear delimiter-based approaches for all other composites, eliminating ambiguity and allowing for simple, linear parsing.</li>
<li><b>Body vs. Alias Principle:</b> The syntax distinguishes between types defined by a body and types that are semantic aliases. Types with a member list (<code>struct</code>, <code>union</code>) use a full keyword when named. Types that are aliases for an underlying type (<code>enum</code>) use a concise symbolic constructor (<code>e</code>).</li>
</ol>
<h3><a class="anchor" id="autotoc_md184"></a>
4.4 Comparison with Other Systems</h3>
<ul>
<li><b>vs. Itanium C++ ABI:</b> Itanium is a "write-only" format designed for linkers. It is maximally compact but unreadable. Our system is designed for humans to read and write, making a deliberate trade-off in verbosity for a massive gain in clarity.</li>
<li><b>vs. Python's <code>ctypes</code>:</b> <code>ctypes</code> uses a programmatic, object-oriented approach. Our format is a standalone, declarative string that can be used by <em>any</em> language to generate bindings. It is a universal schema, not a language-specific implementation.</li>
<li><b>vs. <code>dyncall</code>'s Signature Format:</b> The <code>dyncall</code> library's signature format is a prime example of a minimalist, machine-centric design. <code>dyncall</code> is what inspired me to write <code>infix</code>.<ul>
<li><b>Philosophy:</b> <code>dyncall</code>'s format is a flat string of single characters (e.g., <code>iSl)d</code>). This prioritizes brevity and parsing efficiency. Our system prioritizes human readability (<code>(int, ushort, longlong) -&gt; double</code>).</li>
<li><b>Expressiveness:</b> The <code>dyncall</code> signature can only describe primitive types. It cannot describe the layout of a struct, the size of an array, or the signature of a function pointer.</li>
<li><b>Our Advantage:</b> Our system treats complex data structures as first-class citizens. The signature <code>!{id:uint16, data:[16:uint8]}</code> is a complete schema. <code>dyncall</code> answers, "Which registers do I put these primitives into?" Our format answers, "What is the complete data contract for this function, including the shape of all its related data structures?"</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md185"></a>
4.5 Rationale for Advanced Data Types</h3>
<ol type="1">
<li><b>SIMD Vectors:</b> The <code>v[&lt;N&gt;:&lt;type&gt;]</code> syntax was adopted because it is highly descriptive. The leading <code>v</code> acts as a crucial flag to the FFI implementation, indicating that this is a value destined for a SIMD register. The array-like portion provides the rich metadata needed for both ABI correctness and high-level binding generation.</li>
<li><b>Complex Numbers:</b> The <code>c[&lt;type&gt;]</code> syntax was adopted because it creates a direct, logical parallel with the <code>v[...]</code> syntax for SIMD vectors, establishing a consistent "family" of specialized numeric constructors. The mnemonic <code>c</code> for "complex" is exceptionally strong, making the syntax highly readable despite its conciseness. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
