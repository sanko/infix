<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>infix FFI Library: infix FFI: Internals Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">infix FFI Library<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">infix FFI: Internals Documentation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md89"></a> This document provides a deep dive into the architecture and internal workings of <code>infix</code>. It's a little disorganized but is intended for maintainers and developers looking to contribute or understand the library's design philosophy.</p>
<h1><a class="anchor" id="autotoc_md90"></a>
Core Design Philosophy</h1>
<p>The architecture of <code>infix</code> is the result of deliberate design choices aimed at balancing performance, security, and developer ergonomics.</p>
<ol type="1">
<li><b>Security First:</b> An FFI library with a JIT engine is a prime target for security vulnerabilities. We proactively defend against these with a multi-layered approach: strict W^X memory, hardened integer arithmetic against overflows, guard pages for freed code, and read-only callback contexts. All complex components are subjected to continuous fuzz testing.</li>
<li><b>Performance by Design:</b> FFI overhead must be minimal. The API is intentionally designed to separate the expensive, one-time <b>generation cost</b> from the near-zero <b>call-time cost</b>. This encourages users to cache trampolines, making the FFI overhead negligible in high-performance applications.</li>
<li><b>Abstraction and Portability:</b> Platform- and ABI-specific logic is strictly isolated behind a clean internal interface (the "ABI spec" v-tables). This allows the core trampoline engine to remain platform-agnostic, which dramatically simplifies maintenance and makes porting to new architectures a clear, well-defined process.</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md92"></a>
Architectural Overview</h1>
<p>The library can be broken down into five main layers:</p>
<ol type="1">
<li><b>Public API Layer (<code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code>, <code><a class="el" href="signature_8c.html" title="Implements the high-level v1.0 signature string parser.">signature.c</a></code>)**: The user-facing interface, providing both a high-level Signature API and a low-level Core API.</b></li>
<li><b> **Type System (<code><a class="el" href="types_8c.html" title="Implements the FFI type system for creating and managing type descriptions.">types.c</a></code>)**: Describes the data types used in function signatures.</b></li>
<li><b> **Executable Memory Manager (<code><a class="el" href="executor_8c.html" title="Implements the OS-level memory management and the internal callback dispatcher.">executor.c</a></code>)**: Handles the allocation and protection of memory for JIT-compiled code.</b></li>
<li><b> **ABI Abstraction Layer (<code><a class="el" href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a></code>, <code><a class="el" href="structinfix__reverse__abi__spec.html">infix_reverse_abi_spec</a></code>)**: A pair of v-table interfaces that define how to handle a specific calling convention.</b></li>
<li><b> **Trampoline Generator (<code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code>)**: The core engine that uses the other layers to build the final machine code.</b></li>
</ol>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md93"></a>
1. API Layers: Core vs. Signature</h2>
<p><b></b></p>
<p><b><code>infix</code> provides two distinct APIs for creating trampolines. Understanding their trade-offs is key to using the library effectively.</b></p>
<p><b></b></p>
<h3><a class="anchor" id="autotoc_md94"></a>
The Core API (&lt;tt&gt;infix_type_create_*&lt;/tt&gt;, &lt;tt&gt;infix_forward_create_manual&lt;/tt&gt;)</h3>
<p><b></b></p>
<p><b>This is the foundational, low-level API. It offers maximum power and flexibility and is designed for performance-critical applications or dynamic environments where type information is not known until runtime.</b></p>
<p><b></p><ul>
<li><b>Purpose</b>: To programmatically construct C types at runtime. This is essential for language bindings that introspect C headers or for dynamically marshalling data.</li>
<li><b>Mechanism</b>: The user acts as a "builder," creating <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> objects for primitives and composing them into more complex aggregates like structs, unions, and arrays.</li>
<li><b>Memory Management</b>: <b>Exclusively Arena-Based</b>. To eliminate a major class of memory management bugs, the Manual API <em>requires</em> an <code>infix_arena_t*</code>. All <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> objects created for a given task are allocated from this arena. The user is responsible for calling <code>infix_arena_destroy</code> once to free all associated memory. The old, error-prone <code>infix_type_destroy</code> function is no longer part of the public API.</li>
</ul>
<p></b></p>
<p><b><b>Core API Example: Describing a Packed Struct</b></b></p>
<p><b></p><div class="fragment"><div class="line"><span class="preprocessor">#pragma pack(push, 1)</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ uint16_t id; <span class="keywordtype">char</span> name; uint32_t flags; } PackedData;</div>
<div class="line"><span class="preprocessor">#pragma pack(pop)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// To describe this with the Core API:</span></div>
<div class="line"><a class="code hl_struct" href="structinfix__type.html">infix_type</a>* create_packed_data_type(<a class="code hl_struct" href="structinfix__arena__t.html">infix_arena_t</a>* arena) {</div>
<div class="line">    <span class="comment">// 1. Create the inner array type first, from the arena.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__type.html">infix_type</a>* char_array_type = NULL;</div>
<div class="line">    <a class="code hl_function" href="infix_8h.html#a9f0d8a41015262d2dcffc97cf5f87772">infix_type_create_array</a>(arena, &amp;char_array_type, <a class="code hl_function" href="infix_8h.html#ae323d599fbc081976a99a1e3b726a0b8">infix_type_create_primitive</a>(<a class="code hl_enumvalue" href="group__high__level__api.html#ga2cd7b00c1f2606249654a8e8b7cbc044a5d897112e15ba7badb572aade813f056">INFIX_PRIMITIVE_UINT8</a>), 10);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Allocate the list of members from the arena.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__struct__member.html">infix_struct_member</a>* members = <a class="code hl_function" href="group__high__level__api.html#gabb32fed25010a3111812c8dfacd4cf40">infix_arena_alloc</a>(arena, <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structinfix__struct__member.html">infix_struct_member</a>) * 3, _Alignof(<a class="code hl_struct" href="structinfix__struct__member.html">infix_struct_member</a>));</div>
<div class="line">    members = <a class="code hl_function" href="infix_8h.html#aed99b57de2c839a66eb54c9e82d703d9">infix_type_create_member</a>(NULL, <a class="code hl_function" href="infix_8h.html#ae323d599fbc081976a99a1e3b726a0b8">infix_type_create_primitive</a>(<a class="code hl_enumvalue" href="group__high__level__api.html#ga2cd7b00c1f2606249654a8e8b7cbc044a00f3ad839a27dadb46f08930a0b9a0d9">INFIX_PRIMITIVE_UINT16</a>), offsetof(PackedData, <span class="keywordtype">id</span>));</div>
<div class="line">    members = <a class="code hl_function" href="infix_8h.html#aed99b57de2c839a66eb54c9e82d703d9">infix_type_create_member</a>(NULL, char_array_type, offsetof(PackedData, name));</div>
<div class="line">    members = <a class="code hl_function" href="infix_8h.html#aed99b57de2c839a66eb54c9e82d703d9">infix_type_create_member</a>(NULL, <a class="code hl_function" href="infix_8h.html#ae323d599fbc081976a99a1e3b726a0b8">infix_type_create_primitive</a>(<a class="code hl_enumvalue" href="group__high__level__api.html#ga2cd7b00c1f2606249654a8e8b7cbc044a0643805a9348d3270494e6573fa20553">INFIX_PRIMITIVE_UINT32</a>), offsetof(PackedData, flags));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Create the final packed struct type, also from the arena.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__type.html">infix_type</a>* packed_type = NULL;</div>
<div class="line">    <a class="code hl_function" href="infix_8h.html#a013ec0163fd36e611251d1a0897f773e">infix_type_create_packed_struct</a>(arena, &amp;packed_type, <span class="keyword">sizeof</span>(PackedData), _Alignof(PackedData), members, 3);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> packed_type; <span class="comment">// This pointer is valid only for the lifetime of the arena.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__high__level__api_html_ga2cd7b00c1f2606249654a8e8b7cbc044a00f3ad839a27dadb46f08930a0b9a0d9"><div class="ttname"><a href="group__high__level__api.html#ga2cd7b00c1f2606249654a8e8b7cbc044a00f3ad839a27dadb46f08930a0b9a0d9">INFIX_PRIMITIVE_UINT16</a></div><div class="ttdeci">@ INFIX_PRIMITIVE_UINT16</div><div class="ttdoc">unsigned short, uint16_t</div><div class="ttdef"><b>Definition</b> infix.h:202</div></div>
<div class="ttc" id="agroup__high__level__api_html_ga2cd7b00c1f2606249654a8e8b7cbc044a0643805a9348d3270494e6573fa20553"><div class="ttname"><a href="group__high__level__api.html#ga2cd7b00c1f2606249654a8e8b7cbc044a0643805a9348d3270494e6573fa20553">INFIX_PRIMITIVE_UINT32</a></div><div class="ttdeci">@ INFIX_PRIMITIVE_UINT32</div><div class="ttdoc">unsigned int, uint32_t</div><div class="ttdef"><b>Definition</b> infix.h:204</div></div>
<div class="ttc" id="agroup__high__level__api_html_ga2cd7b00c1f2606249654a8e8b7cbc044a5d897112e15ba7badb572aade813f056"><div class="ttname"><a href="group__high__level__api.html#ga2cd7b00c1f2606249654a8e8b7cbc044a5d897112e15ba7badb572aade813f056">INFIX_PRIMITIVE_UINT8</a></div><div class="ttdeci">@ INFIX_PRIMITIVE_UINT8</div><div class="ttdoc">unsigned char, uint8_t</div><div class="ttdef"><b>Definition</b> infix.h:200</div></div>
<div class="ttc" id="agroup__high__level__api_html_gabb32fed25010a3111812c8dfacd4cf40"><div class="ttname"><a href="group__high__level__api.html#gabb32fed25010a3111812c8dfacd4cf40">infix_arena_alloc</a></div><div class="ttdeci">c23_nodiscard void * infix_arena_alloc(infix_arena_t *, size_t, size_t)</div><div class="ttdoc">Allocates a block of memory from the arena with a specific alignment.</div><div class="ttdef"><b>Definition</b> arena.c:99</div></div>
<div class="ttc" id="ainfix_8h_html_a013ec0163fd36e611251d1a0897f773e"><div class="ttname"><a href="infix_8h.html#a013ec0163fd36e611251d1a0897f773e">infix_type_create_packed_struct</a></div><div class="ttdeci">c23_nodiscard infix_status infix_type_create_packed_struct(infix_arena_t *, infix_type **, size_t, size_t, infix_struct_member *, size_t)</div><div class="ttdoc">Creates a new infix_type for a packed struct from an arena.</div><div class="ttdef"><b>Definition</b> types.c:371</div></div>
<div class="ttc" id="ainfix_8h_html_a9f0d8a41015262d2dcffc97cf5f87772"><div class="ttname"><a href="infix_8h.html#a9f0d8a41015262d2dcffc97cf5f87772">infix_type_create_array</a></div><div class="ttdeci">c23_nodiscard infix_status infix_type_create_array(infix_arena_t *, infix_type **, infix_type *, size_t)</div><div class="ttdoc">Creates a new infix_type for a fixed-size array from an arena.</div><div class="ttdef"><b>Definition</b> types.c:561</div></div>
<div class="ttc" id="ainfix_8h_html_ae323d599fbc081976a99a1e3b726a0b8"><div class="ttname"><a href="infix_8h.html#ae323d599fbc081976a99a1e3b726a0b8">infix_type_create_primitive</a></div><div class="ttdeci">c23_nodiscard infix_type * infix_type_create_primitive(infix_primitive_type_id)</div><div class="ttdoc">Creates an infix_type descriptor for a primitive C type.</div><div class="ttdef"><b>Definition</b> types.c:107</div></div>
<div class="ttc" id="ainfix_8h_html_aed99b57de2c839a66eb54c9e82d703d9"><div class="ttname"><a href="infix_8h.html#aed99b57de2c839a66eb54c9e82d703d9">infix_type_create_member</a></div><div class="ttdeci">infix_struct_member infix_type_create_member(const char *, infix_type *, size_t)</div><div class="ttdoc">A factory function to create an infix_struct_member.</div><div class="ttdef"><b>Definition</b> types.c:420</div></div>
<div class="ttc" id="astructinfix__arena__t_html"><div class="ttname"><a href="structinfix__arena__t.html">infix_arena_t</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:114</div></div>
<div class="ttc" id="astructinfix__struct__member_html"><div class="ttname"><a href="structinfix__struct__member.html">infix_struct_member</a></div><div class="ttdoc">Describes a single member of an aggregate type (struct or union).</div></div>
<div class="ttc" id="astructinfix__type_html"><div class="ttname"><a href="structinfix__type.html">infix_type</a></div><div class="ttdoc">The central structure for describing any data type in the FFI system.</div></div>
</div><!-- fragment --><p></b></p>
<p><b></b></p>
<h3><a class="anchor" id="autotoc_md95"></a>
The Signature API (&lt;tt&gt;infix_forward_create&lt;/tt&gt;, &lt;tt&gt;infix_reverse_create&lt;/tt&gt;)</h3>
<p><b></b></p>
<p><b>This is the high-level API, designed for convenience, readability, and safety. It is the recommended choice for over 99% of use cases.</b></p>
<p><b></p><ul>
<li><b>Purpose</b>: To create trampolines from a concise, declarative string when the C function's signature is known at compile-time or can be determined from configuration.</li>
<li>**Mechanism: It uses a self-contained mini-language to describe C types. The <code>infix_signature_parse</code> and <code>infix_type_from_signature</code> functions implement a recursive-descent parser that translates this string into the required <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> object graph.</li>
<li><b>Memory Management</b>: <b>Automatic</b>. The parser allocates all necessary <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> objects from a temporary internal arena. The high-level <code>infix_forward_create</code> and <code>infix_reverse_create</code> functions create this arena, use it to generate the trampoline, and then immediately destroy the arena, freeing all the blueprint objects. The user never has to manage <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> memory.</li>
</ul>
<p></b></p>
<p><b><b>Signature API Example: Describing the Same Packed Struct</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// To describe the same struct with the Signature API:</span></div>
<div class="line"><span class="keywordtype">char</span>* create_packed_data_signature() {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">char</span> signature;</div>
<div class="line">    <span class="comment">// Note the primitive codes: t=ushort, c=char, j=uint</span></div>
<div class="line">    snprintf(signature, <span class="keyword">sizeof</span>(signature), <span class="stringliteral">&quot;p(%zu,%zu){t@%zu,c@%zu,j@%zu}&quot;</span>,</div>
<div class="line">             <span class="keyword">sizeof</span>(PackedData), _Alignof(PackedData),</div>
<div class="line">             offsetof(PackedData, <span class="keywordtype">id</span>), offsetof(PackedData, name), offsetof(PackedData, flags));</div>
<div class="line">    <span class="keywordflow">return</span> signature;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A trampoline can then be created in one line for a function taking a pointer to it:</span></div>
<div class="line"><span class="comment">// infix_forward_create(&amp;t, strcat(create_packed_data_signature(), &quot;*=&gt;y&quot;));</span></div>
<div class="ttc" id="ainfix_8h_html"><div class="ttname"><a href="infix_8h.html">infix.h</a></div><div class="ttdoc">The main public header for the infix FFI library.</div></div>
</div><!-- fragment --><p> The comparison clearly shows that the Signature API is far more productive and less error-prone for any signature that can be expressed as a string.</b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md96"></a>
2. The Signature Parser (&lt;tt&gt;signature.c&lt;/tt&gt;)</h2>
<p><b></b></p>
<p><b>This component is the engine behind the Signature API.</b></p>
<p><b></p><ul>
<li><b>Strategy</b>: It uses a recursive-descent approach. The main entry point, <code>parse_type</code>, acts as a dispatcher based on the current character in the signature string (e.g., <code>[</code> calls <code>parse_array</code>, <code>{</code> calls <code>parse_aggregate</code>). This allows for natural handling of complex nested types.</li>
<li><b>Named Fields</b>: The aggregate parsers use a lookahead technique to distinguish between an unnamed type (<code>{i,d}</code>) and a named field (<code>{id:i,val:d}</code>). It tentatively parses an identifier, then peeks at the next character. If it's a colon (<code>:</code>), it's a named field; otherwise, it rewinds and parses the identifier as part of a type.</li>
<li><b>Function Pointer Parsing</b>: When the parser encounters a function pointer signature like <code>(i=&gt;v)</code>, it performs a recursive parse. It isolates the inner signature string (<code>i=&gt;v</code>) and calls the main <code>infix_signature_parse</code> function on that substring. The result is a detailed <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> of category <code>INFIX_TYPE_REVERSE_TRAMPOLINE</code>, which contains the full type information for the function pointer's arguments and return value. For ABI purposes, this <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> still has the size and alignment of a standard <code>void*</code>.</li>
</ul>
<p></b></p>
<p><b></b></p>
<h3><a class="anchor" id="autotoc_md97"></a>
Parser Error Handling and Security</h3>
<p><b> The parser is a primary attack surface and is hardened accordingly.</p><ul>
<li><b>Sticky Errors</b>: A <code>parser_state_t</code> struct is passed through all parsing functions. If any function encounters a syntax error, it sets <code>state-&gt;error</code> and returns <code>NULL</code>. All other functions check this flag on entry and abort immediately if it's set, ensuring a clean and fast failure.</li>
<li><b>Recursion Guard</b>: To prevent stack overflow vulnerabilities from maliciously crafted signatures (e.g., <code>{{{{...}}}}</code>), all recursive parsing functions (<code>parse_type</code>, <code>parse_aggregate</code>, etc.) track their current recursion depth. If the depth exceeds the <code>MAX_RECURSION_DEPTH</code> constant, parsing is aborted with an error. This vulnerability was discovered and fixed thanks to fuzz testing.</li>
</ul>
<p></b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md98"></a>
3. The Type System (&lt;tt&gt;types.c&lt;/tt&gt;)</h2>
<p><b></b></p>
<p><b>The <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> struct is the cornerstone of the library. It provides the generator with the metadata (size, alignment, and composition) needed to correctly handle arguments and return values.</b></p>
<p><b></p><ul>
<li><b>Static vs. Dynamic Types</b>: Primitives (<code>int</code>, <code>float</code>, <code>void*</code>) are represented by static, singleton <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> instances to avoid allocations. Complex types (structs, unions, arrays) are dynamically allocated from an arena and must not be freed individually.</li>
<li><b>Rich Pointers</b>: A pointer type contains a <code>pointee_type</code> field, allowing the type system to represent not just a generic pointer, but a <code>pointer to int</code> or a <code>pointer to struct</code>, which is crucial for introspection.</li>
<li><b>Compiler-Specific Nuances</b>: The type system is aware of compiler-specific type aliases. For example, it knows that <code>long double</code> on MSVC and Clang for Windows is an 8-byte alias for <code>double</code>, and returns the canonical <code>double</code> type to ensure correct ABI classification.</li>
<li><b>Security</b>: The type creation functions (<code>infix_type_create_struct</code>, etc.) contain explicit checks to prevent integer overflows.</li>
</ul>
<p></b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md99"></a>
4. Executable Memory Management and Security (&lt;tt&gt;executor.c&lt;/tt&gt;)</h2>
<p><b></b></p>
<p><b>The library implements multiple layers of security to protect against common JIT vulnerabilities.</b></p>
<p><b></b></p>
<h4><a class="anchor" id="autotoc_md100"></a>
Write XOR Execute (W^X)</h4>
<p><b> A memory region is never simultaneously writable and executable. The implementation strategy varies by platform for maximum security and compatibility:</b></p>
<p><b></p><div class="fragment"><div class="line">---</div>
<div class="line">config:</div>
<div class="line">  layout: elk</div>
<div class="line">  theme: dark</div>
<div class="line">---</div>
<div class="line">graph</div>
<div class="line">    A[infix_executable_alloc] --&gt; B{OS?};</div>
<div class="line">    B --&gt;|Windows| C[VirtualAlloc with PAGE_READWRITE];</div>
<div class="line">    B --&gt;|macOS / Termux / OpenBSD| D[&quot;mmap with PROT_READ | PROT_WRITE&quot;];</div>
<div class="line">    B --&gt;|Linux / Other BSDs| E[shm_open_anonymous + ftruncate];</div>
<div class="line"> </div>
<div class="line">    C --&gt; F[Write Code];</div>
<div class="line">    D --&gt; F;</div>
<div class="line">    E --&gt; G[mmap RW view] --&gt; F;</div>
<div class="line">    E --&gt; H[mmap RX view];</div>
<div class="line"> </div>
<div class="line">    F --&gt; I[infix_executable_make_executable];</div>
<div class="line">    I --&gt; J{OS?};</div>
<div class="line">    J --&gt;|Windows| K[VirtualProtect to PAGE_EXECUTE_READ];</div>
<div class="line">    J --&gt;|macOS / Termux / OpenBSD| L[&quot;mprotect to PROT_READ | PROT_EXEC&quot;];</div>
<div class="line">    J --&gt;|Linux / Other BSDs| M[No-op: RX view is already executable];</div>
<div class="line"> </div>
<div class="line">    K --&gt; N[Return RX pointer];</div>
<div class="line">    L --&gt; N;</div>
<div class="line">    M --&gt; N;</div>
<div class="line">    H --&gt; N;</div>
<div class="line"> </div>
<div class="line">    subgraph &quot;Linux/BSD Dual-Mapping&quot;</div>
<div class="line">      E; G; H; M;</div>
<div class="line">    end</div>
<div class="line">    subgraph &quot;Windows/macOS/etc. Single-Mapping&quot;</div>
<div class="line">      C; D; K; L;</div>
<div class="line">    end</div>
</div><!-- fragment --><p></b></p>
<p><b></b></p>
<h4><a class="anchor" id="autotoc_md101"></a>
Guard Pages for Freed Trampolines</h4>
<p><b> To mitigate use-after-free vulnerabilities, <code>infix_executable_free</code> does not immediately release the memory. Instead, it changes its protection to <code>PROT_NONE</code> (no read/write/execute). This turns a subtle vulnerability into a safe, immediate, and obvious crash if a dangling function pointer is ever called.</b></p>
<p><b></b></p>
<h4><a class="anchor" id="autotoc_md102"></a>
Read-Only Callback Contexts</h4>
<p><b> The <code><a class="el" href="structinfix__reverse__t.html">infix_reverse_t</a></code> struct contains function pointers that could be targeted by memory corruption attacks. After a callback context is fully initialized, the memory page containing it is made read-only using <code>mprotect</code>/<code>VirtualProtect</code>.</b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md103"></a>
5. The ABI Abstraction Layer and Trampoline Generator (&lt;tt&gt;trampoline.c&lt;/tt&gt;)</h2>
<p><b></b></p>
<p><b>The core of the library's portability is the separation of concerns via two v-table structs: <code><a class="el" href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a></code> and <code><a class="el" href="structinfix__reverse__abi__spec.html">infix_reverse_abi_spec</a></code>. The <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code> engine is the consumer of these specs. It orchestrates the entire JIT process, from classifying the signature to emitting the final machine code.</b></p>
<p><b></b></p>
<h3><a class="anchor" id="autotoc_md104"></a>
Trampoline Generation Flow</h3>
<p><b></b></p>
<p><b></b></p>
<h4><a class="anchor" id="autotoc_md105"></a>
Forward Call Trampoline</h4>
<p><b></b></p>
<p><b></p><div class="fragment"><div class="line">graph TD</div>
<div class="line">    subgraph &quot;Setup Phase (infix_forward_create_manual)&quot;</div>
<div class="line">        A[User calls API] --&gt; B(Get Forward ABI Spec);</div>
<div class="line">        B --&gt; C{prepare_forward_call_frame};</div>
<div class="line">        C --&gt; D[Generate Prologue];</div>
<div class="line">        D --&gt; E[Generate Argument Moves];</div>
<div class="line">        E --&gt; F[Generate Hardened Call];</div>
<div class="line">        F --&gt; G[Generate Epilogue];</div>
<div class="line">        G --&gt; H[Copy code to executable memory];</div>
<div class="line">        H --&gt; I[Return callable cif_func];</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph &quot;Call Phase (cif_func(...)&quot;</div>
<div class="line">        J[User calls cif_func] --&gt; K(Prologue: Set up stack);</div>
<div class="line">        K --&gt; L(Argument Moves);</div>
<div class="line">        L --&gt; M(Validate target_func != NULL);</div>
<div class="line">        M --&gt; N[call native_func];</div>
<div class="line">        N --&gt; O(Epilogue: Handle return, restore stack);</div>
<div class="line">        O --&gt; P[Return to User];</div>
<div class="line">    end</div>
</div><!-- fragment --><p></b></p>
<p><b></b></p>
<h4><a class="anchor" id="autotoc_md106"></a>
Reverse Call Trampoline (Callbacks)</h4>
<p><b></b></p>
<p><b></p><div class="fragment"><div class="line">graph TD</div>
<div class="line">    subgraph &quot;Setup Phase: infix_reverse_create_manual()&quot;</div>
<div class="line">        A[User provides handler &amp; signature] --&gt; B;</div>
<div class="line">        B(Create context struct in protected memory) --&gt; C;</div>
<div class="line">        C[Generate and CACHE a FORWARD trampoline for the user&#39;s handler] --&gt; D;</div>
<div class="line">        D(Get Reverse ABI Spec) --&gt; E;</div>
<div class="line">        E{5-Stage Generation} --&gt; F[1. prepare_reverse_call_frame];</div>
<div class="line">        F --&gt; G[2. generate_reverse_prologue];</div>
<div class="line">        G --&gt; H[3. generate_reverse_argument_marshalling];</div>
<div class="line">        H --&gt; I[4. generate_reverse_dispatcher_call];</div>
<div class="line">        I --&gt; J[5. generate_reverse_epilogue];</div>
<div class="line">        J --&gt; K[Copy JIT stub code to executable memory];</div>
<div class="line">        K --&gt; L[Make context read-only &amp; return native function pointer];</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph &quot;Call Phase: Native code calls the function pointer&quot;</div>
<div class="line">        M[External code calls pointer] --&gt; N[JIT Stub Executes];</div>
<div class="line">        N --&gt; O[Prologue: Set up stack];</div>
<div class="line">        O --&gt; P[Marshal Arguments: Save native args to generic `void**` array on stub&#39;s stack];</div>
<div class="line">        P --&gt; Q[&quot;call infix_internal_dispatch_callback_fn_impl&quot;];</div>
<div class="line">        Q --&gt; R[&quot;C Dispatcher prepares a **new arg list** with the context* pointer prepended and uses the CACHED forward trampoline to call the user&#39;s C handler&quot;];</div>
<div class="line">        R --&gt; S[Return from user handler];</div>
<div class="line">        S --&gt; T[Unmarshal Return Value: Load value from buffer into native return registers];</div>
<div class="line">        T --&gt; U[Epilogue: Restore stack];</div>
<div class="line">        U --&gt; V[ret to native caller];</div>
<div class="line">    end</div>
</div><!-- fragment --><p></b></p>
<p><b></b></p>
<h1><a class="anchor" id="autotoc_md107"></a>
A Note on the "Unity" Build</h1>
<p><b></b></p>
<p><b><code>infix</code> is designed to be built as a single translation unit (a "unity build"). The top-level <code><a class="el" href="infix_8c.html" title="The unity build source file for the infix library.">src/infix.c</a></code> file does not contain logic; it is simply a list of <code>#include</code> directives for all the other <code>.c</code> files in the <code>src/core/</code> directory.</b></p>
<p><b><b>Why use a unity build?</b></b></p>
<p><b></p><ol type="1">
<li><b>Simplicity of Integration:</b> It makes compiling the library trivial. A user can simply add <code><a class="el" href="infix_8c.html" title="The unity build source file for the infix library.">infix.c</a></code> and the <code>include</code> directory to their project, and it will build without any complex makefiles or build scripts.</li>
<li><b>Potential for Optimization:</b> Compiling the entire library as a single unit gives the compiler maximum visibility. This can enable more aggressive inlining and interprocedural optimizations, potentially leading to a smaller and faster final library.</li>
<li><b>Encapsulation:</b> Because all functions can be declared <code>static</code> within their respective files (except for the public API), we avoid polluting the global namespace of the final object file. The only symbols exported are the public <code>infix_*</code> functions. The <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code> file is a key part of this, as it includes the ABI-specific <code>.c</code> files directly, ensuring their internal functions remain private to the library.</li>
</ol>
<p></b></p>
<p><b></p><hr  />
<p></b></p>
<p><b></b></p>
<h1><a class="anchor" id="autotoc_md109"></a>
infix ABI Internals</h1>
<p><b></b></p>
<p><b>This document provides a low-level technical comparison of the Application Binary Interfaces (ABIs) supported by infix. It is intended for maintainers and contributors working within the <code>abi/</code> directory.</b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md110"></a>
Comparative Overview</h2>
<p><b></b></p>
<p><b>The following table summarizes the key differences in calling conventions between the supported 64-bit ABIs.</b></p>
<p><b></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature   </th><th class="markdownTableHeadNone">System V AMD64 (Linux, macOS)   </th><th class="markdownTableHeadNone">Windows x64   </th><th class="markdownTableHeadNone">AArch64 (ARM64)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Integer/Pointer Args</b>   </td><td class="markdownTableBodyNone">6 GPRs: <code>RDI, RSI, RDX, RCX, R8, R9</code>   </td><td class="markdownTableBodyNone">4 GPRs: <code>RCX, RDX, R8, R9</code> (Shared slots)   </td><td class="markdownTableBodyNone">8 GPRs: <code>X0</code> - <code>X7</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Floating-Point Args</b>   </td><td class="markdownTableBodyNone">8 XMMs: <code>XMM0</code> - <code>XMM7</code> (Separate pool)   </td><td class="markdownTableBodyNone">4 XMMs: <code>XMM0</code> - <code>XMM3</code> (Shared slots)   </td><td class="markdownTableBodyNone">8 VPRs: <code>V0</code> - <code>V7</code> (Separate pool)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Struct/Union Passing</b>   </td><td class="markdownTableBodyNone"><b>Recursive Classification</b>. Passed in GPRs, XMMs, or both.   </td><td class="markdownTableBodyNone"><b>By Reference</b> if size is not 1, 2, 4, or 8 bytes.   </td><td class="markdownTableBodyNone"><b>By Reference</b> if size &gt; 16 bytes. HFAs passed in VPRs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Return by Hidden Pointer</b>   </td><td class="markdownTableBodyNone">If struct &gt; 16 bytes or classified as MEMORY. Pointer in <code>RDI</code>.   </td><td class="markdownTableBodyNone">If struct size is not 1, 2, 4, or 8. Pointer in <code>RCX</code>.   </td><td class="markdownTableBodyNone">If struct &gt; 16 bytes. Pointer in <code>X8</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Return Value Registers</b>   </td><td class="markdownTableBodyNone"><code>RAX</code> (int), <code>RAX:RDX</code> (int pair), <code>XMM0</code> (float), <code>st(0)</code> (ld)   </td><td class="markdownTableBodyNone"><code>RAX</code> (int/struct), <code>XMM0</code> (float)   </td><td class="markdownTableBodyNone"><code>X0</code> (int), <code>X0:X1</code> (int pair), <code>V0</code> (float/HFA)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Variadic <code>printf</code> Rule</b>   </td><td class="markdownTableBodyNone"><code>AL</code> must contain the number of XMM registers used.   </td><td class="markdownTableBodyNone">Floating-point variadic args are passed in GPRs <em>and</em> XMMs.   </td><td class="markdownTableBodyNone">Standard: <code>AL</code> rule. Apple: All variadic args on the stack.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Stack Alignment</b>   </td><td class="markdownTableBodyNone">16-byte boundary before <code>call</code>.   </td><td class="markdownTableBodyNone">16-byte boundary before <code>call</code>.   </td><td class="markdownTableBodyNone">16-byte boundary.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Shadow Space</b>   </td><td class="markdownTableBodyNone">No. Has a 128-byte "red zone" below <code>RSP</code>.   </td><td class="markdownTableBodyNone">Yes, caller allocates 32 bytes on stack for the callee.   </td><td class="markdownTableBodyNone">No.   </td></tr>
</table>
<p></b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md111"></a>
Deep Dive: System V AMD64 Aggregate Classification</h2>
<p><b></b></p>
<p><b><em>File: <code><a class="el" href="abi__sysv__x64_8c.html" title="Implements the FFI logic for the System V AMD64 ABI.">abi_sysv_x64.c</a></code></em></b></p>
<p><b>The System V ABI has the most complex rules for passing aggregates (structs/unions). The logic is implemented in <code>classify_aggregate_sysv</code> and <code>classify_recursive</code>.</b></p>
<p><b></p><ul>
<li><b>Eightbytes</b>: An aggregate up to 16 bytes is conceptually split into one or two 8-byte chunks called "eightbytes".</li>
<li><b>Classification</b>: Each field of the struct is examined recursively. Its type determines the class of the eightbyte(s) it falls into.<ul>
<li><code>INTEGER</code>: The eightbyte contains integer types, pointers, or a mix of integer and float. It will be passed in a GPR.</li>
<li><code>SSE</code>: The eightbyte contains only <code>float</code> or <code>double</code> types. It will be passed in an XMM register.</li>
<li><code>MEMORY</code>: The aggregate is too large (&gt; 16 bytes), contains unaligned fields, or contains special types like <code>long double</code>. It must be passed on the stack.</li>
</ul>
</li>
<li><b>Result</b>: This classification can result in a single struct being passed across two different register types (e.g., one GPR and one XMM), which is handled by the <code>ARG_LOCATION_GPR_SSE_PAIR</code> logic.</li>
</ul>
<p></b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md112"></a>
Deep Dive: Windows x64 By-Reference Rule</h2>
<p><b></b></p>
<p><b><em>File: <code><a class="el" href="abi__win__x64_8c.html" title="Implements the FFI logic for the Windows x64 calling convention.">abi_win_x64.c</a></code></em></b></p>
<p><b>The Windows x64 ABI uses a much simpler rule for aggregates, implemented in the <code>is_passed_by_reference</code> helper.</b></p>
<p><b></p><ul>
<li><b>Power-of-Two Rule</b>: An aggregate (or even a primitive like <code>long double</code>) is passed <b>by reference</b> (a pointer is passed in a GPR) if its size in bytes is <b>not</b> 1, 2, 4, or 8.</li>
<li><b>Shared Slots</b>: The first four argument "slots" are used for both GPRs and XMMs. For a function <code>void(int, double, int, double)</code>, the arguments are passed in <code>RCX</code>, <code>XMM1</code>, <code>R8</code>, and <code>XMM3</code>. <code>RDX</code> (the second GPR slot) and <code>XMM0</code> (the first XMM slot) are skipped because the slots were consumed by arguments of a different type.</li>
</ul>
<p></b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md113"></a>
Deep Dive: AArch64 Homogeneous Floating-point Aggregates (HFA)</h2>
<p><b></b></p>
<p><b><em>File: <code><a class="el" href="abi__arm64_8c.html" title="Implements the FFI logic for the AArch64 (ARM64) architecture following the AAPCS64 calling conventio...">abi_arm64.c</a></code></em></b></p>
<p><b>The ARM64 ABI has a special rule for compact structs containing only floating-point types, implemented in the <code>is_hfa</code> function.</b></p>
<p><b></p><ul>
<li><b>Definition</b>: An HFA is a struct or array containing 1 to 4 elements of the <em>exact same</em> floating-point type (<code>float</code> or <code>double</code>), even if nested. For example, <code>struct <a class="el" href="structPoint.html" title="A simple struct with two doubles. Small enough to be passed in registers on some ABIs.">Point</a> { double x, y; }; struct Line { <a class="el" href="structPoint.html" title="A simple struct with two doubles. Small enough to be passed in registers on some ABIs.">Point</a> p1; <a class="el" href="structPoint.html" title="A simple struct with two doubles. Small enough to be passed in registers on some ABIs.">Point</a> p2; }</code> is an HFA of four <code>double</code>s.</li>
<li><b>Passing</b>: If a type is identified as an HFA, it is passed directly in up to four consecutive Vector/FP Registers (<code>V0</code>-<code>V7</code>), instead of by reference. This is a significant performance optimization.</li>
<li><b>Apple ABI Divergence</b>: A critical platform-specific rule is handled for macOS on AArch64: all variadic arguments are passed on the stack. The standard AAPCS64 passes them in registers if available. This is handled by a preprocessor check in <code>prepare_forward_call_frame_arm64</code>.</li>
</ul>
<p></b></p>
<p><b></p><hr  />
<p></b></p>
<p><b></b></p>
<h1><a class="anchor" id="autotoc_md115"></a>
The Debugging Guide</h1>
<p><b></b></p>
<p><b>This guide is for library maintainers and advanced contributors who need to debug the low-level machine code generated by <code>infix</code>.</b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md116"></a>
Introduction</h2>
<p><b></b></p>
<p><b>Debugging Just-In-Time compiled code can feel like black magic. The code you're stepping through doesn't exist in any source file; it's a raw sequence of bytes in an executable memory page. However, with the right tools and techniques, it's entirely manageable.</b></p>
<p><b>This guide covers the two primary methods for inspecting the machine code generated by infix: using the built-in <code>infix_dump_hex</code> utility and stepping through the code live with a debugger like GDB or WinDbg.</b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md117"></a>
Method 1: Static Analysis with &lt;tt&gt;infix_dump_hex&lt;/tt&gt;</h2>
<p><b></b></p>
<p><b>The simplest way to see what the JIT is producing is to print it. infix provides a <code>infix_dump_hex</code> utility (in <code><a class="el" href="utility_8h.html" title="A header for debugging utilities that are conditionally compiled.">utility.h</a></code>) that is enabled in debug builds.</b></p>
<p><b>After you generate a trampoline, you can access its internal <code>exec</code> handle and print the contents of its executable memory region.</b></p>
<p><b></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="utility_8h.html">utility.h</a>&gt;</span> <span class="comment">// Required for infix_dump_hex</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The handle is opaque in the public API, but for debugging, you can</span></div>
<div class="line"><span class="comment">// temporarily expose the infix_forward_t struct in infix.h</span></div>
<div class="line"><span class="keywordflow">if</span> (trampoline) {</div>
<div class="line">    infix_dump_hex(trampoline-&gt;<a class="code hl_variable" href="structinfix__forward__t.html#a2acff8531f53fd864fcb68aa3a5db6e1">exec</a>.<a class="code hl_variable" href="structinfix__executable__t.html#a50e15399f44c62193a85a674ae393b3f">rx_ptr</a>, trampoline-&gt;<a class="code hl_variable" href="structinfix__forward__t.html#a2acff8531f53fd864fcb68aa3a5db6e1">exec</a>.<a class="code hl_variable" href="structinfix__executable__t.html#a0fb7198de8f0b15b94a5b526c9f07c92">size</a>, <span class="stringliteral">&quot;My Trampoline&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="astructinfix__executable__t_html_a0fb7198de8f0b15b94a5b526c9f07c92"><div class="ttname"><a href="structinfix__executable__t.html#a0fb7198de8f0b15b94a5b526c9f07c92">infix_executable_t::size</a></div><div class="ttdeci">size_t size</div><div class="ttdoc">The total size of the allocated memory region in bytes.</div><div class="ttdef"><b>Definition</b> infix_internals.h:46</div></div>
<div class="ttc" id="astructinfix__executable__t_html_a50e15399f44c62193a85a674ae393b3f"><div class="ttname"><a href="structinfix__executable__t.html#a50e15399f44c62193a85a674ae393b3f">infix_executable_t::rx_ptr</a></div><div class="ttdeci">void * rx_ptr</div><div class="ttdoc">A pointer to the memory with Read+Execute permissions. This is the callable address.</div><div class="ttdef"><b>Definition</b> infix_internals.h:43</div></div>
<div class="ttc" id="astructinfix__forward__t_html_a2acff8531f53fd864fcb68aa3a5db6e1"><div class="ttname"><a href="structinfix__forward__t.html#a2acff8531f53fd864fcb68aa3a5db6e1">infix_forward_t::exec</a></div><div class="ttdeci">infix_executable_t exec</div><div class="ttdoc">Handle to the executable JIT-compiled stub.</div><div class="ttdef"><b>Definition</b> infix_internals.h:79</div></div>
<div class="ttc" id="autility_8h_html"><div class="ttname"><a href="utility_8h.html">utility.h</a></div><div class="ttdoc">A header for debugging utilities that are conditionally compiled.</div></div>
</div><!-- fragment --><p> This will produce a detailed hexdump of the generated machine code, which you can then compare against an instruction set reference for your architecture (e.g., the Intel/AMD developer manuals or the ARM Architecture Reference Manual).</b></p>
<p><b></p><div class="fragment"><div class="line"># My Forward Trampoline (size: 78 bytes)</div>
<div class="line">#   0x0000: 55 48 89 e5 41 54 41 55  41 56 41 57 49 89 cc 49 | UH..ATAUAVAWI..I</div>
<div class="line">#   0x0010: 89 d5 4d 89 c6 48 81 ec  20 00 00 00 4c 89 e9 4d | ..M..H.. ...L..M</div>
<div class="line">#   ...</div>
</div><!-- fragment --><p></b></p>
<p><b></b></p>
<h2><a class="anchor" id="autotoc_md118"></a>
Method 2: Live Debugging with GDB (Linux/macOS)</h2>
<p><b></b></p>
<p><b>This is the most powerful method. It allows you to step through the JIT'd code one instruction at a time and inspect the state of the CPU registers.</b></p>
<p><b>Let's say you've found a failure that you think is a bug in infix itself. Let's imagine a trampoline that wraps <code>int(int, int)</code> is failing. The arguments seem to be corrupted. These are the steps I would take:</b></p>
<p><b></p><ol type="1">
<li><p class="startli"><b>Get the Address</b>: Print the address of the executable code right after it's generated.</p>
<p class="startli"><code>c infix_cif_func cif_func = (infix_cif_func)infix_forward_get_code(trampoline); printf("DEBUG: Trampoline generated at address: %p\n", (void*)cif_func); fflush(stdout); </code></p>
</li>
<li><b>Run Under GDB</b>: <code>gdb ./my_test_executable</code></li>
<li><p class="startli"><b>Set Breakpoint</b>: Use the address you printed in step 1 to set a breakpoint. The <code>*</code> is crucialâ€”it tells GDB to set a breakpoint on the memory address itself, not on a symbol.</p>
<p class="startli">```gdb (gdb) run </p>
</li>
</ol>
<p></b></p>
<h1><a class="anchor" id="autotoc_md119"></a>
Your program will run and print the address</h1>
<p><b> DEBUG: Trampoline generated at address: 0x7ffff7fde000</b></p>
<p><b></b></p>
<h1><a class="anchor" id="autotoc_md120"></a>
Now, set the breakpoint</h1>
<p><b> (gdb) b *0x7ffff7fde000 Breakpoint 1 at 0x7ffff7fde000 ``<code></p><ol type="1">
<li><p class="startli">**Trigger and Disassemble**: Run the program. When it breaks, usedisassemble` to view the JIT code.</p>
<p class="startli"><code>gdb @section autotoc_md121 After the cif_func() is called in your C code... Breakpoint 1, 0x00007ffff7fde000 in ?? () (gdb) disassemble Dump of assembler code for function 0x7ffff7fde000: =&gt; 0x00007ffff7fde000: push rbp 0x00007ffff7fde001: mov rsp,rbp 0x00007ffff7fde004: push r12 ... End of assembler dump. </code></p>
</li>
<li><p class="startli"><b>Step and Verify</b>: Use <code>stepi</code> (step instruction) and <code>info registers</code> to walk through the code and check register values before the <code>call</code> instruction. At that point, all the argument registers (<code>rdi</code>, <code>rsi</code>, <code>xmm0</code>, etc.) should contain the correct values you passed in.</p>
<p class="startli"><code>gdb (gdb) # ... stepi until you are right before the call ... (gdb) info registers rdi rsi rdi 0x2a 42 rsi 0x64 100 @section autotoc_md122 If the values here are correct, your trampoline code is likely correct. @section autotoc_md123 If they are wrong, you can step backward to see where the wrong value was loaded. </code></p>
</li>
</ol>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md124"></a>
Method 3: Live Debugging with WinDbg (Windows)</h3>
<p><b><code></code></b></p>
<p><b><code>The process on Windows is conceptually identical but uses different commands (<code>bp</code> to set breakpoint, <code>u</code> to unassemble, <code>r</code> to view registers, <code>t</code> to trace/step).</code></b></p>
<p><b><code></p><ol type="1">
<li><b>Get the Address</b>: Same as with GDB, print the address of the trampoline.</li>
<li><b>Run Under WinDbg</b>: <code>windbg.exe my_failing_test.exe</code></li>
<li><p class="startli"><b>Set a Breakpoint</b>: Use the <code>bp</code> command.</p>
<p class="startli"><code> 0:000&gt; g ; Go until the address is printed DEBUG: Trampoline generated at address: 0x1ff0a70000 0:000&gt; bp 0x1ff0a70000 </code></p>
</li>
<li><b>Trigger the Trampoline</b>: Let the program continue with <code>g</code>. It will break at your JIT code's entry point.</li>
<li><p class="startli"><b>Unassemble and Inspect</b>: Use <code>u</code> (unassemble) to view the code and <code>r</code> (registers) to view the CPU state.</p>
<p class="startli"><code> 0:000&gt; u . my_failing_test!0x1ff0a70000: 000001ff`0a700000 55 push rbp 000001ff`0a700001 4889e5 mov rbp,rsp ... 0:000&gt; r rax=... rcx=... rdx=... </code></p>
</li>
<li><b>Step</b>: Use <code>t</code> (trace) to step through one instruction at a time. Check the argument registers (<code>rcx</code>, <code>rdx</code>, <code>r8</code>, <code>r9</code>, <code>xmm0-3</code>) right before the final <code>call</code> instruction.</li>
</ol>
<p></code></b></p>
<p><b><code>By using these techniques, you can demystify the JIT compilation process and effectively debug even the most complex ABI and code generation issues.</code></b></p>
<p><b><code></p><hr  />
<p></code></b></p>
<p><b><code></code></b></p>
<h2><a class="anchor" id="autotoc_md126"></a>
External ABI Documentation</h2>
<p><b><code></code></b></p>
<p><b><code>The current <code>infix</code> implementations are based on the official ABI documents for each platform.</code></b></p>
<p><b><code></p><ul>
<li><b>System V AMD64 ABI:</b><ul>
<li><a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf">Main Specification (PDF)</a></li>
</ul>
</li>
<li><b>Microsoft Windows x64 ABI:</b><ul>
<li><a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention">Official Microsoft Documentation</a></li>
</ul>
</li>
<li><b>ARM 64-bit (AArch64) ABI (AAPCS64):</b><ul>
<li><a href="https://github.com/ARM-software/abi-aa/releases/download/2025Q1/aapcs32.pdf">Official ARM Developer Documentation</a></li>
<li><a href="https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms">Writing ARM64 code for Apple platforms</a></li>
</ul>
</li>
</ul>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md127"></a>
A Cross-Language Type Reference</h3>
<p><b><code></code></b></p>
<p><b><code>Getting the types right is the most critical part of FFI. A mismatch between the <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> you describe and the actual type used by the library function can lead to stack corruption, crashes, or silent data corruption.</code></b></p>
<p><b><code><b>The Golden Rule</b>: Always use explicit, fixed-width types when possible. <code>&lt;stdint.h&gt;</code> in C is your best friend. Relying on types like <code>long</code> is risky, as it can be 32-bit on some 64-bit platforms (like Windows) and 64-bit on others (like Linux).</code></b></p>
<p><b><code>The following table maps infix's primitive type enums to their corresponding types in C and other common languages.</code></b></p>
<p><b><code></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">infix <code>infix_primitive_type_id</code>   </th><th class="markdownTableHeadNone">C (<code>&lt;stdint.h&gt;</code>)   </th><th class="markdownTableHeadNone">C++   </th><th class="markdownTableHeadNone">Rust   </th><th class="markdownTableHeadNone">Go (<code>import "C"</code>)   </th><th class="markdownTableHeadNone">Swift   </th><th class="markdownTableHeadNone">Zig   </th><th class="markdownTableHeadNone">Fortran (<code>iso_c_binding</code>)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_BOOL</code>   </td><td class="markdownTableBodyNone"><code>_Bool</code>   </td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"><code>C.bool</code>   </td><td class="markdownTableBodyNone"><code>CBool</code>   </td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"><code>logical(c_bool)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_SINT8</code>   </td><td class="markdownTableBodyNone"><code>int8_t</code>   </td><td class="markdownTableBodyNone"><code>int8_t</code>   </td><td class="markdownTableBodyNone"><code>i8</code>   </td><td class="markdownTableBodyNone"><code>C.schar</code>   </td><td class="markdownTableBodyNone"><code>CChar</code>   </td><td class="markdownTableBodyNone"><code>i8</code>   </td><td class="markdownTableBodyNone"><code>integer(c_signed_char)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_UINT8</code>   </td><td class="markdownTableBodyNone"><code>uint8_t</code>   </td><td class="markdownTableBodyNone"><code>uint8_t</code>   </td><td class="markdownTableBodyNone"><code>u8</code>   </td><td class="markdownTableBodyNone"><code>C.uchar</code>   </td><td class="markdownTableBodyNone"><code>CUnsignedChar</code>   </td><td class="markdownTableBodyNone"><code>u8</code>   </td><td class="markdownTableBodyNone"><code>integer(c_char)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_SINT16</code>   </td><td class="markdownTableBodyNone"><code>int16_t</code>   </td><td class="markdownTableBodyNone"><code>int16_t</code>   </td><td class="markdownTableBodyNone"><code>i16</code>   </td><td class="markdownTableBodyNone"><code>C.short</code>   </td><td class="markdownTableBodyNone"><code>CShort</code>   </td><td class="markdownTableBodyNone"><code>i16</code>   </td><td class="markdownTableBodyNone"><code>integer(c_short)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_UINT16</code>   </td><td class="markdownTableBodyNone"><code>uint16_t</code>   </td><td class="markdownTableBodyNone"><code>uint16_t</code>   </td><td class="markdownTableBodyNone"><code>u16</code>   </td><td class="markdownTableBodyNone"><code>C.ushort</code>   </td><td class="markdownTableBodyNone"><code>CUnsignedShort</code>   </td><td class="markdownTableBodyNone"><code>u16</code>   </td><td class="markdownTableBodyNone"><code>integer(c_unsigned_short)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_SINT32</code>   </td><td class="markdownTableBodyNone"><code>int32_t</code>   </td><td class="markdownTableBodyNone"><code>int32_t</code>   </td><td class="markdownTableBodyNone"><code>i32</code>   </td><td class="markdownTableBodyNone"><code>C.int</code>   </td><td class="markdownTableBodyNone"><code>CInt</code>   </td><td class="markdownTableBodyNone"><code>i32</code>   </td><td class="markdownTableBodyNone"><code>integer(c_int)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_UINT32</code>   </td><td class="markdownTableBodyNone"><code>uint32_t</code>   </td><td class="markdownTableBodyNone"><code>uint32_t</code>   </td><td class="markdownTableBodyNone"><code>u32</code>   </td><td class="markdownTableBodyNone"><code>C.uint</code>   </td><td class="markdownTableBodyNone"><code>CUnsignedInt</code>   </td><td class="markdownTableBodyNone"><code>u32</code>   </td><td class="markdownTableBodyNone"><code>integer(c_unsigned_int)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_SINT64</code>   </td><td class="markdownTableBodyNone"><code>int64_t</code>   </td><td class="markdownTableBodyNone"><code>int64_t</code>   </td><td class="markdownTableBodyNone"><code>i64</code>   </td><td class="markdownTableBodyNone"><code>C.longlong</code>   </td><td class="markdownTableBodyNone"><code>CLongLong</code>   </td><td class="markdownTableBodyNone"><code>i64</code>   </td><td class="markdownTableBodyNone"><code>integer(c_long_long)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_UINT64</code>   </td><td class="markdownTableBodyNone"><code>uint64_t</code>   </td><td class="markdownTableBodyNone"><code>uint64_t</code>   </td><td class="markdownTableBodyNone"><code>u64</code>   </td><td class="markdownTableBodyNone"><code>C.ulonglong</code>   </td><td class="markdownTableBodyNone"><code>CUnsignedLongLong</code>   </td><td class="markdownTableBodyNone"><code>u64</code>   </td><td class="markdownTableBodyNone"><code>integer(c_unsigned_long_long)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_SINT128</code>Ã‚Â¹   </td><td class="markdownTableBodyNone"><code>__int128_t</code>   </td><td class="markdownTableBodyNone"><code>__int128_t</code>   </td><td class="markdownTableBodyNone"><code>i128</code>   </td><td class="markdownTableBodyNone"><b>N/A</b>   </td><td class="markdownTableBodyNone"><b>N/A</b>   </td><td class="markdownTableBodyNone"><code>i128</code>   </td><td class="markdownTableBodyNone"><b>N/A</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_UINT128</code>Ã‚Â¹   </td><td class="markdownTableBodyNone"><code>__uint128_t</code>   </td><td class="markdownTableBodyNone"><code>__uint128_t</code>   </td><td class="markdownTableBodyNone"><code>u128</code>   </td><td class="markdownTableBodyNone"><b>N/A</b>   </td><td class="markdownTableBodyNone"><b>N/A</b>   </td><td class="markdownTableBodyNone"><code>u128</code>   </td><td class="markdownTableBodyNone"><b>N/A</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_FLOAT</code>   </td><td class="markdownTableBodyNone"><code>float</code>   </td><td class="markdownTableBodyNone"><code>float</code>   </td><td class="markdownTableBodyNone"><code>f32</code>   </td><td class="markdownTableBodyNone"><code>C.float</code>   </td><td class="markdownTableBodyNone"><code>CFloat</code>   </td><td class="markdownTableBodyNone"><code>f32</code>   </td><td class="markdownTableBodyNone"><code>real(c_float)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_DOUBLE</code>   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone"><code>f64</code>   </td><td class="markdownTableBodyNone"><code>C.double</code>   </td><td class="markdownTableBodyNone"><code>CDouble</code>   </td><td class="markdownTableBodyNone"><code>f64</code>   </td><td class="markdownTableBodyNone"><code>real(c_double)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INFIX_PRIMITIVE_LONG_DOUBLE</code>Ã‚Â²   </td><td class="markdownTableBodyNone"><code>long double</code>   </td><td class="markdownTableBodyNone"><code>long double</code>   </td><td class="markdownTableBodyNone"><b>N/A</b>   </td><td class="markdownTableBodyNone"><code>C.longdouble</code>   </td><td class="markdownTableBodyNone"><code>CLongDouble</code>   </td><td class="markdownTableBodyNone"><code>f80</code>/<code>f128</code>   </td><td class="markdownTableBodyNone"><code>real(c_long_double)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Pointer Type</b>   </td><td class="markdownTableBodyNone"><code>void*</code>   </td><td class="markdownTableBodyNone"><code>void*</code>   </td><td class="markdownTableBodyNone"><code>*mut T</code> / <code>*const T</code>   </td><td class="markdownTableBodyNone"><code>unsafe.Pointer</code>   </td><td class="markdownTableBodyNone"><code>UnsafeMutableRawPointer</code>   </td><td class="markdownTableBodyNone"><code>*T</code>   </td><td class="markdownTableBodyNone"><code>type(c_ptr)</code>   </td></tr>
</table>
<p></code></b></p>
<p><b><code></code></b></p>
<h4><a class="anchor" id="autotoc_md128"></a>
Common Windows Type Definitions</h4>
<p><b><code></code></b></p>
<p><b><code>The Windows API uses a large number of <code>typedef</code>s for C primitives. This table helps map them to the correct infix types. All types are for 64-bit Windows.</code></b></p>
<p><b><code></p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Windows Type   </th><th class="markdownTableHeadNone">Underlying C Type   </th><th class="markdownTableHeadNone">Recommended infix <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code>   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>HANDLE</code>   </td><td class="markdownTableBodyNone"><code>void*</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="infix_8h.html#a58f759e56e12c39603c391886dd6857f" title="Creates an infix_type descriptor for a generic void* pointer.">infix_type_create_pointer()</a></code>   </td><td class="markdownTableBodyNone">Base type for most OS objects (files, processes, etc.).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>HMODULE</code>   </td><td class="markdownTableBodyNone"><code>HANDLE</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="infix_8h.html#a58f759e56e12c39603c391886dd6857f" title="Creates an infix_type descriptor for a generic void* pointer.">infix_type_create_pointer()</a></code>   </td><td class="markdownTableBodyNone">Handle to a loaded DLL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>HWND</code>   </td><td class="markdownTableBodyNone"><code>HANDLE</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="infix_8h.html#a58f759e56e12c39603c391886dd6857f" title="Creates an infix_type descriptor for a generic void* pointer.">infix_type_create_pointer()</a></code>   </td><td class="markdownTableBodyNone">Handle to a window.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>HCALL</code>   </td><td class="markdownTableBodyNone"><code>HANDLE</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="infix_8h.html#a58f759e56e12c39603c391886dd6857f" title="Creates an infix_type descriptor for a generic void* pointer.">infix_type_create_pointer()</a></code>   </td><td class="markdownTableBodyNone">A generic handle type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>DWORD</code>   </td><td class="markdownTableBodyNone"><code>unsigned long</code> (32-bit)   </td><td class="markdownTableBodyNone"><code>infix_type_create_primitive(INFIX_PRIMITIVE_UINT32)</code>   </td><td class="markdownTableBodyNone">A 32-bit unsigned integer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>UINT</code>   </td><td class="markdownTableBodyNone"><code>unsigned int</code> (32-bit)   </td><td class="markdownTableBodyNone"><code>infix_type_create_primitive(INFIX_PRIMITIVE_UINT32)</code>   </td><td class="markdownTableBodyNone">A 32-bit unsigned integer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>HRESULT</code>   </td><td class="markdownTableBodyNone"><code>long</code> (32-bit)   </td><td class="markdownTableBodyNone"><code>infix_type_create_primitive(INFIX_PRIMITIVE_SINT32)</code>   </td><td class="markdownTableBodyNone">A 32-bit signed integer for success/failure codes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SIZE_T</code>   </td><td class="markdownTableBodyNone"><code>unsigned __int64</code> (64-bit)   </td><td class="markdownTableBodyNone"><code>infix_type_create_primitive(INFIX_PRIMITIVE_UINT64)</code>   </td><td class="markdownTableBodyNone">The native unsigned integer for sizes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>LPCSTR</code>   </td><td class="markdownTableBodyNone"><code>const char*</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="infix_8h.html#a58f759e56e12c39603c391886dd6857f" title="Creates an infix_type descriptor for a generic void* pointer.">infix_type_create_pointer()</a></code>   </td><td class="markdownTableBodyNone">Pointer to a null-terminated 8-bit ANSI string.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>LPCWSTR</code>   </td><td class="markdownTableBodyNone"><code>const wchar_t*</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="infix_8h.html#a58f759e56e12c39603c391886dd6857f" title="Creates an infix_type descriptor for a generic void* pointer.">infix_type_create_pointer()</a></code>   </td><td class="markdownTableBodyNone">Pointer to a null-terminated 16-bit UTF-16 string.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>UINT128</code>   </td><td class="markdownTableBodyNone"><code>struct { uint64_t, uint64_t }</code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> for a struct of two <code>UINT64</code>s.   </td><td class="markdownTableBodyNone">This is <b>not</b> a primitive. It must be described as a struct.   </td></tr>
</table>
<p></code></b></p>
<p><b><code><b>Notes &amp; Pitfalls:</b></code></b></p>
<p><b><code></p><ol type="1">
<li><b>128-bit Integers</b>: <code>__int128_t</code> is a non-standard compiler extension, primarily available in GCC and Clang. It is not supported by MSVC. Many other languages do not have a C-compatible 128-bit integer type.</li>
<li>**<code>long double</code>**: This is the most dangerous type for FFI. Its size and representation vary wildly:<ul>
<li>On x86-64 Linux, it's typically an 80-bit extended-precision float.</li>
<li>On AArch64 Linux, it's a 128-bit quadruple-precision float.</li>
<li>On Windows (MSVC and Clang), it is simply an alias for <code>double</code> (64 bits).</li>
<li>On macOS (x86-64 and AArch64), it is also just an alias for <code>double</code>. infix's <code>infix_type_create_primitive</code> correctly aliases it to <code>DOUBLE</code> on platforms where they are the same, but you must be certain the library you are calling uses a distinct <code>long double</code> type.</li>
</ul>
</li>
<li><b>Variadic <code>float</code></b>: When you call a variadic C function (one with <code>...</code>), any <code>float</code> argument is automatically <b>promoted</b> to a <code>double</code>. You must use <code>INFIX_PRIMITIVE_DOUBLE</code> in your infix type signature for that argument.</li>
</ol>
<p></code></b></p>
<p><b><code></p><hr  />
<p></code></b></p>
<p><b><code></code></b></p>
<h2><a class="anchor" id="autotoc_md130"></a>
Core Design Philosophy</h2>
<p><b><code></code></b></p>
<p><b><code>The architecture of <code>infix</code> is not accidental. It is the result of a series of deliberate design choices aimed at balancing performance, security, and developer ergonomics. This section explains the "why" behind some of the most important architectural decisions.</code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md131"></a>
Guiding Principles</h3>
<p><b><code></code></b></p>
<p><b><code>Three high-level principles guide the library's development:</code></b></p>
<p><b><code></p><ol type="1">
<li><b>Security First:</b> An FFI library, especially one with a JIT engine, is a prime target for security vulnerabilities. We proactively defend against these with a multi-layered approach, including strict W^X memory, hardened integer arithmetic against overflows, guard pages for freed code, and read-only callback contexts. All complex components are subjected to continuous fuzz testing.</li>
<li><b>Performance by Design:</b> We recognize that FFI overhead must be minimal. The API is intentionally designed to separate the expensive, one-time <b>generation cost</b> from the near-zero <b>call-time cost</b>. This encourages users to cache trampolines, making the FFI overhead negligible in high-performance applications.</li>
<li><b>Abstraction and Portability:</b> Platform- and ABI-specific logic is strictly isolated behind a clean internal interface (the "ABI spec" v-tables). This allows the core trampoline engine to remain platform-agnostic, which dramatically simplifies maintenance and makes porting to new architectures a clear, well-defined process.</li>
</ol>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md132"></a>
API Naming: The &lt;tt&gt;infix_&lt;/tt&gt; Prefix</h3>
<p><b><code></code></b></p>
<p><b><code><b>The Decision:</b> All public symbols (functions, typedefs, enums, macros) exposed by <code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code> use the <code>infix_</code> or <code>INFIX_</code> prefix.</code></b></p>
<p><b><code><b>The Rationale:</b> This choice is primarily for <b>safety and responsible ecosystem citizenship</b>.</p><ul>
<li><b>Avoiding Namespace Collisions:</b> The most popular C FFI library is <code>libffi</code>. It is a system-level component on many platforms and is used internally by the runtimes of Python, Ruby, Go, and others. <code>libffi</code> uses the <code>ffi_</code> prefix for all its symbols (e.g., <code>ffi_type</code>, <code>ffi_prep_cif</code>). If <code>infix</code> also used the <code>ffi_</code> prefix, it would create a high risk of name clashes and ODR (One Definition Rule) violations in any project that happened to link against both <code>infix</code> and a library that depends on <code>libffi</code>. This would lead to subtle, difficult-to-diagnose crashes and stack corruption.</li>
<li><b>Clarity and Branding:</b> Using <code>infix_</code> makes the code self-documenting. When a developer sees <code>infix_forward_create</code>, they know exactly which library is providing that function. It also enhances discoverability in IDEs with code completion.</li>
</ul>
<p></code></b></p>
<p><b><code><b>The Trade-off:</b> The <code>infix_</code> prefix is slightly more verbose than a shorter alternative. This is an insignificant cost compared to the enormous benefit of guaranteeing namespace safety.</code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md133"></a>
Memory Safety by Default: The Arena-Based Manual API</h3>
<p><b><code></code></b></p>
<p><b><code><b>The Decision:</b> The low-level, "manual" API for creating <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> objects is <b>exclusively arena-based</b>. The old, <code>malloc</code>-based functions with their complex ownership semantics have been removed from the public API.</code></b></p>
<p><b><code><b>The Rationale:</b> The single most dangerous part of a complex C API is manual memory management. The old ruleâ€”"the library takes ownership of pointers on success, but the caller owns them on failure"â€”is a well-known and notorious source of memory leaks and double-frees.</p><ul>
<li><b>Eliminating User Error:</b> By forcing the use of an arena, we eliminate this entire class of bugs. The user's responsibility is simplified to a single pattern: create an arena, perform all type creations, use the types to generate a trampoline, and then destroy the arena. It is no longer possible to leak an individual <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> object.</li>
<li><b>Consistency:</b> This decision makes the manual API's memory model consistent with the high-level Signature API, which already used an arena internally. The entire library now operates on the same, simple memory philosophy.</li>
<li><b>Performance:</b> For creating complex type graphs, arena allocation is significantly faster than repeated calls to <code>malloc</code>.</li>
</ul>
<p></code></b></p>
<p><b><code><b>The Trade-off:</b> The user must now manage an <code><a class="el" href="structinfix__arena__t.html">infix_arena_t</a></code> object. This is a small price to pay for guaranteed memory safety and a simpler API.</code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md134"></a>
Callbacks: The Power of the Universal Context</h3>
<p><b><code></code></b></p>
<p><b><code><b>The Decision:</b> All user-provided C callback handlers <b>always</b> receive a pointer to their <code><a class="el" href="structinfix__reverse__t.html">infix_reverse_t</a></code> (aliased as <code>infix_context_t</code>) as their first argument. There is no "stateless" callback mode.</code></b></p>
<p><b><code><b>The Rationale:</b> This decision prioritizes power and API simplicity over minor syntactic convenience.</p><ul>
<li><b>Power by Default:</b> The context-passing model is a strict superset of a stateless model. It allows every callback to be stateful by default, which is essential for adapting to C libraries that don't provide a <code>void* user_data</code> parameter. A stateless handler can be trivially implemented by simply ignoring the context argument.</li>
<li><b>API Simplicity and Safety:</b> Providing a single, consistent pattern for all callbacks is far safer and easier to learn than offering two different modes (<code>callback</code> vs. <code>closure</code>). A dual API would inevitably lead to users providing the wrong kind of handler for the creation function they called, resulting in guaranteed stack corruption. The universal context pattern eliminates this entire class of bugs.</li>
<li><b>Industry Precedent:</b> This closure-based model is the standard pattern used by all major FFI libraries (<code>libffi</code>, <code>dyncall</code>, etc.) because it is the only one powerful enough for real-world use cases. <code>infix</code>'s choice to pass the context as the <em>first</em> argument (rather than last) is a deliberate ergonomic choice that mirrors the <code>this</code>/<code>self</code> convention in object-oriented programming.</li>
</ul>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md135"></a>
ABI Dispatch: V-Tables for Cross-Platform Fuzzing</h3>
<p><b><code></code></b></p>
<p><b><code><b>The Decision:</b> The core <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code> engine dispatches to ABI-specific logic via a v-table (a struct of function pointers, <code><a class="el" href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a></code>). It does not use <code>#ifdef</code> blocks to compile in only one ABI's implementation at a time.</code></b></p>
<p><b><code><b>The Rationale:</b> While a "true unity build" that uses the preprocessor to select a single implementation of a function like <code>prepare_forward_call_frame</code> might seem simpler, it has one massive, deal-breaking drawback: it destroys our ability to easily test all ABIs on a single platform.</p><ul>
<li><b>Enabling Cross-Platform Testing:</b> The v-table design allows us to compile the library on a single Linux machine with the logic for the <b>Windows x64 ABI</b>, the <b>System V AMD64 ABI</b>, and the <b>AArch64 ABI</b> all present in the same binary. Our test suite can then use the <code>INFIX_FORCE_ABI_*</code> macros to dynamically select which v-table to use for a given test.</li>
<li><b>High-Value Fuzzing:</b> This means we can run our fuzzers on a Linux CI server and have them continuously test for bugs in the Windows and AArch64 ABI classification and code-generation logic without ever needing to spin up a Windows or ARM build agent. This is an incredibly powerful and efficient way to ensure the entire library is robust and secure across all supported platforms.</li>
</ul>
<p></code></b></p>
<p><b><code><b>The Trade-off:</b> This approach adds a single layer of indirection (a function pointer call) in the <em>trampoline generation</em> code and makes <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code> slightly more verbose. This has zero impact on the performance of the final JIT-compiled code and is a tiny price to pay for the massive strategic advantage of comprehensive, multi-platform testing in a single environment.</code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md136"></a>
The Self-Contained Object Model: Trading Memory for Safety</h3>
<p><b><code></code></b></p>
<p><b><code><b>The Decision:</b> Both <code><a class="el" href="structinfix__forward__t.html">infix_forward_t</a></code> and <code><a class="el" href="structinfix__reverse__t.html">infix_reverse_t</a></code> are designed as <b>self-contained objects</b>. When a trampoline is created, it performs a <b>deep copy</b> of all the <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> metadata it needs into its own private, internal memory arena.</code></b></p>
<p><b><code><b>The Rationale:</b> This architecture is a deliberate trade-off that prioritizes memory safety and API simplicity above all else.</code></b></p>
<p><b><code></p><ol type="1">
<li><b>Elimination of Use-After-Free:</b> The primary motivation is to solve a critical dangling pointer problem. Without this model, a user would create types in a temporary arena, create a trampoline that points to them, and then destroy the arena, leaving the trampoline in a dangerously invalid state. By making an internal copy, the trampoline's lifetime is completely decoupled from the user's temporary data. The user can and should destroy their arena immediately after creation.</li>
<li><b>Enabling Safe Introspection:</b> The introspection API (<code>infix_forward_get_arg_type</code>, etc.) would not be possible without this model. It can only work if the type information is guaranteed to be valid for the entire lifetime of the trampoline handle.</li>
<li><b>Simplified Memory Management for the User:</b> The user's responsibility is clear: they manage their own arenas for type creation, and they manage the trampoline handles. The two are independent.</li>
</ol>
<p></code></b></p>
<p><b><code><b>The Trade-off: Memory Overhead</b></code></b></p>
<p><b><code>The cost of this safety is a higher memory footprint per trampoline. Each handle now contains its own private arena (which automatically adjusts to usage) to store the type graph. For several hundred trampolines, this can add a few megabytes to the application's memory usage.</code></b></p>
<p><b><code>This is considered an acceptable cost for the vast majority of applications (desktop, server, language runtimes) where the benefit of guaranteed memory safety far outweighs the modest increase in RAM usage. For highly constrained embedded environments, future versions of the library may offer a "tuned" creation function that allows the user to specify a smaller internal arena size.</code></b></p>
<p><b><code></p><hr  />
<p></code></b></p>
<p><b><code></code></b></p>
<h2><a class="anchor" id="autotoc_md138"></a>
Design Philosophy: A Stable Public API</h2>
<p><b><code></code></b></p>
<p><b><code>A core design goal of <code>infix</code> is to provide a stable, clean, and professional public API. A key part of this is the strict separation between the library's <b>public contract</b> and its <b>internal implementation details</b>.</code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md139"></a>
Platform Macros: An Internal Affair</h3>
<p><b><code></code></b></p>
<p><b><code>In previous versions, the main public header, <code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code>, contained a large and complex block of preprocessor macros for detecting the operating system, CPU architecture, and compiler (e.g., <code>INFIX_OS_WINDOWS</code>, <code>INFIX_ARCH_X64</code>).</code></b></p>
<p><b><code><b>This logic has been moved out of the public API and into an internal header, <code><a class="el" href="infix__config_8h.html" title="Internal-only header for platform, architecture, and ABI detection.">src/common/infix_config.h</a></code>.</b></code></b></p>
<p><b><code><b>Rationale:</b></code></b></p>
<p><b><code></p><ol type="1">
<li><b>The Public API is a Contract:</b> The functions and types in <code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code> are a promise to the user. We guarantee their stability across minor versions. The internal platform-detection macros, however, are an implementation detail. We must reserve the right to change, rename, or refactor them as we discover better detection methods or add new platforms. Exposing them in the public header would effectively make them part of our public contract, making the library brittle and harder to maintain.</li>
<li><b>Preventing Tight Coupling:</b> A user's application should not be dependent on its dependencies' internal logic. If a user needs to write platform-specific code, they should use their own project's detection mechanisms, not piggyback on ours. Forcing them to do so leads to a healthier, more decoupled software ecosystem. For example, a user should never be encouraged to write <code>#if defined(INFIX_OS_LINUX)</code> in their own code.</li>
<li><b>Minimizing API Surface Area:</b> A clean public header is easier to read, understand, and use. It should contain only what the consumer of the library needs to know. Hiding hundreds of lines of preprocessor logic makes the API much less intimidating for a new developer.</li>
</ol>
<p></code></b></p>
<p><b><code><b>For Contributors:</b></code></b></p>
<p><b><code>Library contributors <b>should</b> use these internal macros for writing ABI- and platform-specific code. They are made available to all internal <code>.c</code> files via the <code><a class="el" href="infix__internals_8h_source.html">infix_internals.h</a></code> header, which includes <code><a class="el" href="infix__config_8h.html" title="Internal-only header for platform, architecture, and ABI detection.">infix_config.h</a></code>. The primary macros available are:</p><ul>
<li><b>OS:</b> <code>INFIX_OS_WINDOWS</code>, <code>INFIX_OS_MACOS</code>, <code>INFIX_OS_LINUX</code>, etc.</li>
<li><b>Architecture:</b> <code>INFIX_ARCH_X64</code>, <code>INFIX_ARCH_AARCH64</code>.</li>
<li><b>ABI:</b> <code>INFIX_ABI_WINDOWS_X64</code>, <code>INFIX_ABI_SYSV_X64</code>, <code>INFIX_ABI_AAPCS64</code>.</li>
<li><b>Compiler:</b> <code>INFIX_COMPILER_MSVC</code>, <code>INFIX_COMPILER_CLANG</code>, <code>INFIX_COMPILER_GCC</code>.</li>
</ul>
<p></code></b></p>
<p><b><code></p><hr  />
<p></code></b></p>
<p><b><code></code></b></p>
<h2><a class="anchor" id="autotoc_md141"></a>
Core Design Philosophy: The JIT Compiler vs. The Call VM</h2>
<p><b><code></code></b></p>
<p><b><code>A key architectural choice in <code>infix</code> is its use of a Just-in-Time (JIT) compiler to generate trampolines, rather than using a set of pre-compiled assembly stubs, a model often called a "Call VM" or "Interpreter" and used by libraries like <code>dyncall</code>. This decision was deliberate and has profound implications for the library's API design, performance characteristics, and intended use cases.</code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md142"></a>
The Alternative: The Call VM / Interpreter Model (e.g., &lt;tt&gt;dyncall&lt;/tt&gt;)</h3>
<p><b><code></code></b></p>
<p><b><code>In a Call VM model, the library provides a set of low-level functions to build a function call piece by piece. The process typically looks like this:</p><ol type="1">
<li>Create a "call virtual machine" object.</li>
<li>Push arguments one by one (<code>dcArgInt(...)</code>, <code>dcArgDouble(...)</code>, etc.).</li>
<li>Execute the call (<code>dcCallInt(...)</code>, <code>dcCallDouble(...)</code>, etc.).</li>
<li>Reset the VM so that it's ready for the next call.</li>
</ol>
<p></code></b></p>
<p><b><code><b>Pros:</b></p><ul>
<li><b>Simplicity:</b> The core engine can be smaller and simpler.</li>
<li><b>No Executable Memory:</b> This approach doesn't require allocating memory with <code>rwx</code> permissions, which can be an advantage in highly restrictive environments.</li>
</ul>
<p></code></b></p>
<p><b><code><b>Cons:</b></p><ul>
<li><b>Per-Call Overhead:</b> The logic to read the argument list and place values into the correct registers or on the stack is executed <b>every single time</b> the function is called. This interpretive overhead can be significant in hot loops.</li>
<li><b>The Type System Duplication Problem:</b> This is the most significant ergonomic drawback. To handle complex types like structs, the user must describe the struct's layout to the FFI library using a series of API calls (e.g., <code>dcNewAggr</code>, <code>dcAggrField</code>). The user is now forced to maintain <b>two parallel representations of the same data structure</b>: the native C <code>struct</code> definition in their code, and a description of that <code>struct</code> built manually for the FFI library. Keeping these two representations in sync is tedious and a major source of bugs.</li>
</ul>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md143"></a>
The &lt;tt&gt;infix&lt;/tt&gt; Approach: The JIT Compiler Model</h3>
<p><b><code></code></b></p>
<p><b><code><code>infix</code> takes a different approach. It uses its <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> system as a <b>single source of truth</b>.</p><ol type="1">
<li>The user describes the <em>entire</em> function signature once, either via a signature string or the manual API.</li>
<li><code>infix</code> analyzes this complete signature and JIT-compiles a tiny, highly-specialized C functionâ€”the trampolineâ€”that is purpose-built for that exact signature.</li>
</ol>
<p></code></b></p>
<p><b><code><b>Pros:</b></p><ul>
<li><b>Extremely Low Call-Time Overhead:</b> Once generated, calling an <code>infix</code> trampoline is nearly as fast as a direct C function call. All the complex logic for argument placement is compiled into efficient, native machine code. The overhead is paid once, at generation time.</li>
<li><b>A Single Source of Truth for Types:</b> The <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> system is the cornerstone of the entire library. The same <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> graph used to generate the trampoline can also be used for <b>introspection</b>. This completely solves the type system duplication problem. A developer can write a single function that takes an <code>infix_type*</code> and can use it to:<ul>
<li>Generate a trampoline.</li>
<li>Dynamically pack data from a scripting language into a C struct buffer.</li>
<li>Generate a schema for a user interface or a serializer.</li>
<li>Validate data.</li>
</ul>
</li>
<li><b>Ergonomics:</b> For the end-user, the complexity is hidden behind a single call: <code>infix_forward_create("({int, *double}, *char) -&gt; int", ...)</code>`.</li>
</ul>
<p></code></b></p>
<p><b><code><b>The Trade-off:</b> The upfront cost of trampoline generation is higher than a single interpreted call, and it requires allocating executable memory. This makes <code>infix</code>'s design philosophy clear: it is optimized for applications where a trampoline is <b>generated once and called many times</b>, and for systems that benefit from a <b>powerful, introspectable type system</b>.</code></b></p>
<p><b><code></p><hr  />
<p></code></b></p>
<p><b><code></code></b></p>
<h2><a class="anchor" id="autotoc_md145"></a>
Code Generation and Emitters</h2>
<p><b><code></code></b></p>
<p><b><code>The actual machine code is generated by a set of low-level "emitter" functions, specific to each architecture (e.g., <code><a class="el" href="abi__x64__emitters_8c.html" title="Implements the internal helper functions for emitting x86-64 machine code.">abi_x64_emitters.c</a></code>, <code>abi_riscv64_emitters.c</code>).</code></b></p>
<p><b><code></p><ul>
<li><b>Encapsulation:</b> The emitters completely encapsulate the complexity of machine code encoding. The higher-level ABI logic (e.g., <code><a class="el" href="abi__sysv__x64_8c.html" title="Implements the FFI logic for the System V AMD64 ABI.">abi_sysv_x64.c</a></code>) does not deal with opcodes, ModR/M bytes, or REX prefixes. It thinks in terms of abstract operations like "move this register to memory."</li>
<li><b>Clarity:</b> Emitter function names map directly to the assembly instruction they produce (e.g., <code>emit_mov_reg_mem</code> generates <code>mov r64, [mem]</code>).</li>
<li><b>Safety:</b> The emitters operate on a <code><a class="el" href="structcode__buffer.html" title="An utility structure for dynamically building machine code in memory. @This is not part of the public...">code_buffer</a></code> struct, which handles automatic resizing of the memory buffer, preventing buffer overflows during JIT compilation.</li>
</ul>
<p></code></b></p>
<p><b><code><b>Example: Emitting <code>mov rax, [rbp - 16]</code> on x86-64</b></code></b></p>
<p><b><code></p><div class="fragment"><div class="line"><span class="comment">// In the ABI logic (e.g., abi_sysv_x64.c):</span></div>
<div class="line"><a class="code hl_function" href="abi__x64__emitters_8c.html#a3bc0def8574505550e37a9879ed04620">emit_mov_reg_mem</a>(buf, <a class="code hl_enumvalue" href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95aa7084485e4390b99030433e9bdee2505">RAX_REG</a>, <a class="code hl_enumvalue" href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95a87e3aff8654e88ae2f05459caf6ecff1">RBP_REG</a>, -16);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Inside abi_x64_emitters.c, this function assembles the bytes:</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="abi__x64__emitters_8c.html#a3bc0def8574505550e37a9879ed04620">emit_mov_reg_mem</a>(<a class="code hl_struct" href="structcode__buffer.html">code_buffer</a>* buf, <a class="code hl_enumeration" href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95">x64_gpr</a> dest, <a class="code hl_enumeration" href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95">x64_gpr</a> src_base, int32_t offset) {</div>
<div class="line">    <span class="comment">// 1. Emit REX prefix for 64-bit operation and extended registers.</span></div>
<div class="line">    <a class="code hl_function" href="abi__x64__emitters_8c.html#a877fb1f8f0703500d3c1210976a4f98e">emit_rex_prefix</a>(buf, 1, dest &gt;= <a class="code hl_enumvalue" href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95a10b597de1ddb4cf1c84ea703d8706917">R8_REG</a>, 0, src_base &gt;= <a class="code hl_enumvalue" href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95a10b597de1ddb4cf1c84ea703d8706917">R8_REG</a>);</div>
<div class="line">    <span class="comment">// 2. Emit the MOV opcode.</span></div>
<div class="line">    emit_byte(buf, 0x8B);</div>
<div class="line">    <span class="comment">// 3. Emit the ModR/M byte to specify the registers and addressing mode.</span></div>
<div class="line">    <a class="code hl_function" href="abi__x64__emitters_8c.html#afbe0ce8d2a6b21fd4662133b077106c1">emit_modrm</a>(buf, ...);</div>
<div class="line">    <span class="comment">// 4. Emit the 8-bit or 32-bit displacement (offset).</span></div>
<div class="line">    emit_int32(buf, offset);</div>
<div class="line">}</div>
<div class="ttc" id="aabi__x64__common_8h_html_a6a330aede6810e701de0834d5d0e0d95"><div class="ttname"><a href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95">x64_gpr</a></div><div class="ttdeci">x64_gpr</div><div class="ttdoc">Enumerates the 64-bit General-Purpose Registers (GPRs) for x86-64.</div><div class="ttdef"><b>Definition</b> abi_x64_common.h:41</div></div>
<div class="ttc" id="aabi__x64__common_8h_html_a6a330aede6810e701de0834d5d0e0d95a10b597de1ddb4cf1c84ea703d8706917"><div class="ttname"><a href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95a10b597de1ddb4cf1c84ea703d8706917">R8_REG</a></div><div class="ttdeci">@ R8_REG</div><div class="ttdoc">Volatile. Used for the 3rd integer argument on Windows x64, or the 5th on System V.</div><div class="ttdef"><b>Definition</b> abi_x64_common.h:53</div></div>
<div class="ttc" id="aabi__x64__common_8h_html_a6a330aede6810e701de0834d5d0e0d95a87e3aff8654e88ae2f05459caf6ecff1"><div class="ttname"><a href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95a87e3aff8654e88ae2f05459caf6ecff1">RBP_REG</a></div><div class="ttdeci">@ RBP_REG</div><div class="ttdef"><b>Definition</b> abi_x64_common.h:49</div></div>
<div class="ttc" id="aabi__x64__common_8h_html_a6a330aede6810e701de0834d5d0e0d95aa7084485e4390b99030433e9bdee2505"><div class="ttname"><a href="abi__x64__common_8h.html#a6a330aede6810e701de0834d5d0e0d95aa7084485e4390b99030433e9bdee2505">RAX_REG</a></div><div class="ttdeci">@ RAX_REG</div><div class="ttdoc">Volatile (caller-saved). Typically used for the primary integer/pointer return value in both ABIs.</div><div class="ttdef"><b>Definition</b> abi_x64_common.h:42</div></div>
<div class="ttc" id="aabi__x64__emitters_8c_html_a3bc0def8574505550e37a9879ed04620"><div class="ttname"><a href="abi__x64__emitters_8c.html#a3bc0def8574505550e37a9879ed04620">emit_mov_reg_mem</a></div><div class="ttdeci">void emit_mov_reg_mem(code_buffer *buf, x64_gpr dest, x64_gpr src_base, int32_t offset)</div><div class="ttdoc">Emits an x86-64 mov r64, [r64 + offset] instruction.</div><div class="ttdef"><b>Definition</b> abi_x64_emitters.c:152</div></div>
<div class="ttc" id="aabi__x64__emitters_8c_html_a877fb1f8f0703500d3c1210976a4f98e"><div class="ttname"><a href="abi__x64__emitters_8c.html#a877fb1f8f0703500d3c1210976a4f98e">emit_rex_prefix</a></div><div class="ttdeci">void emit_rex_prefix(code_buffer *buf, bool w, bool r, bool x, bool b)</div><div class="ttdoc">Emits an x86-64 REX prefix byte.</div><div class="ttdef"><b>Definition</b> abi_x64_emitters.c:1076</div></div>
<div class="ttc" id="aabi__x64__emitters_8c_html_afbe0ce8d2a6b21fd4662133b077106c1"><div class="ttname"><a href="abi__x64__emitters_8c.html#afbe0ce8d2a6b21fd4662133b077106c1">emit_modrm</a></div><div class="ttdeci">void emit_modrm(code_buffer *buf, uint8_t mod, uint8_t reg_opcode, uint8_t rm)</div><div class="ttdoc">Emits an x86-64 ModR/M byte.</div><div class="ttdef"><b>Definition</b> abi_x64_emitters.c:1058</div></div>
<div class="ttc" id="astructcode__buffer_html"><div class="ttname"><a href="structcode__buffer.html">code_buffer</a></div><div class="ttdoc">An utility structure for dynamically building machine code in memory. @This is not part of the public...</div><div class="ttdef"><b>Definition</b> infix_internals.h:128</div></div>
</div><!-- fragment --><p></code></b></p>
<p><b><code>This separation makes the ABI logic easier to read and allows the low-level encoding details to be managed and verified in one place.</code></b></p>
<p><b><code></code></b></p>
<h2><a class="anchor" id="autotoc_md146"></a>
Design Philosophy: Key Architectural Decisions</h2>
<p><b><code></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md147"></a>
The Unity Build</h3>
<p><b><code></code></b></p>
<p><b><code><code>infix</code> is designed to be built as a single translation unit. The top-level <code><a class="el" href="infix_8c.html" title="The unity build source file for the infix library.">src/infix.c</a></code> file simply <code>#include</code>s all other core <code>.c</code> files.</code></b></p>
<p><b><code></p><ul>
<li><b>Rationale</b>:<ol type="1">
<li><b>Simplicity of Integration:</b> A user can add <code><a class="el" href="infix_8c.html" title="The unity build source file for the infix library.">infix.c</a></code> and the <code>include</code> directory to their project, and it will build without complex makefiles.</li>
<li><b>Potential for Optimization:</b> Compiling the entire library as a single unit gives the compiler maximum visibility, enabling more aggressive inlining and interprocedural optimizations.</li>
<li><b>Encapsulation:</b> Because most functions are declared <code>static</code>, we avoid polluting the global namespace of the final object file. The <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code> file is key, as it includes the ABI-specific <code>.c</code> files directly, ensuring their internal functions remain private.</li>
</ol>
</li>
</ul>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md148"></a>
API Naming: The &lt;tt&gt;infix_&lt;/tt&gt; Prefix</h3>
<p><b><code></code></b></p>
<p><b><code></p><ul>
<li><b>The Decision:</b> All public symbols use the <code>infix_</code> or <code>INFIX_</code> prefix.</li>
<li><b>Rationale:</b> This is for <b>safety and responsible ecosystem citizenship</b>. The most popular C FFI library, <code>libffi</code>, uses the <code>ffi_</code> prefix. By using a distinct prefix, <code>infix</code> guarantees it will never cause name clashes or ODR (One Definition Rule) violations in projects that link against both libraries. This prevents a class of subtle, difficult-to-diagnose crashes.</li>
</ul>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md149"></a>
Memory Safety by Default: The Arena-Based Manual API</h3>
<p><b><code></code></b></p>
<p><b><code></p><ul>
<li><b>The Decision:</b> The low-level, "manual" API for creating <code><a class="el" href="structinfix__type.html" title="The central structure for describing any data type in the FFI system.">infix_type</a></code> objects is <b>exclusively arena-based</b>.</li>
<li><b>Rationale:</b> The old ruleâ€”"the library takes ownership on success, the caller owns on failure"â€”is a notorious source of memory leaks. By forcing the use of an arena, we eliminate this entire class of bugs. The user's responsibility is simplified to a single pattern: create an arena, perform all type creations, and destroy the arena once. This is safer, more consistent, and often faster than repeated calls to <code>malloc</code>.</li>
</ul>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md150"></a>
Callbacks: The Power of the Universal Context</h3>
<p><b><code></code></b></p>
<p><b><code></p><ul>
<li><b>The Decision:</b> All user-provided C callback handlers <b>always</b> receive a pointer to their <code>infix_context_t</code> as their first argument.</li>
<li><b>Rationale:</b> This prioritizes power and API simplicity.<ol type="1">
<li><b>Power by Default:</b> It allows every callback to be stateful, which is essential for adapting to C libraries that don't provide a <code>void* user_data</code> parameter. A stateless handler can simply ignore the context.</li>
<li><b>API Safety:</b> A single, consistent pattern for all callbacks is safer and easier to learn than offering two different modes (<code>callback</code> vs. <code>closure</code>), which would inevitably lead to users providing the wrong kind of handler and causing stack corruption.</li>
<li><b>Industry Precedent:</b> This closure-based model is the standard pattern used by all major FFI libraries because it is the only one powerful enough for real-world use cases.</li>
</ol>
</li>
</ul>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md151"></a>
ABI Dispatch: V-Tables for Cross-Platform Fuzzing</h3>
<p><b><code></code></b></p>
<p><b><code></p><ul>
<li><b>The Decision:</b> The core <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code> engine dispatches to ABI-specific logic via a v-table (a struct of function pointers like <code><a class="el" href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a></code>).</li>
<li><b>Rationale:</b> While using <code>#ifdef</code> blocks to compile in only one ABI seems simpler, it destroys our ability to easily test all ABIs on a single platform. The v-table design allows us to compile the library on a single Linux machine with the logic for the <b>Windows x64</b>, <b>System V AMD64</b>, and <b>AArch64</b> ABIs all present in the same binary. Our fuzzers can then use the <code>INFIX_FORCE_ABI_*</code> macros to dynamically select which v-table to test. This is an incredibly powerful and efficient way to ensure the entire library is robust across all supported platforms.</li>
</ul>
<p></code></b></p>
<p><b><code></code></b></p>
<h3><a class="anchor" id="autotoc_md152"></a>
Platform Macros: An Internal Affair</h3>
<p><b><code></code></b></p>
<p><b><code></p><ul>
<li><b>The Decision:</b> All platform-detection logic has been moved out of the public <code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code> and into an internal header, <code><a class="el" href="infix__config_8h.html" title="Internal-only header for platform, architecture, and ABI detection.">src/common/infix_config.h</a></code>.</li>
<li><b>Rationale:</b><ol type="1">
<li><b>Public API is a Contract:</b> The functions in <code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code> are a stable promise. The internal detection macros are an implementation detail that we must be free to change without breaking user code.</li>
<li><b>Preventing Tight Coupling:</b> A user's application should use its own detection mechanisms, not piggyback on ours. This leads to a healthier, decoupled ecosystem.</li>
<li><b>Minimizing API Surface Area:</b> A clean public header is easier to read and understand.</li>
</ol>
</li>
</ul>
<p></code></b></p>
<p><b><code></p><hr  />
<p></code></b></p>
<p><b><code></code></b></p>
<h1><a class="anchor" id="autotoc_md154"></a>
License and Legal</h1>
<p><b><code></code></b></p>
<p><b><code>Copyright (c) 2025 Sanko Robinson</code></b></p>
<p><b><code>This documentation is licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0). You are free to share and adapt this material for any purpose, provided you give appropriate credit.</code></b></p>
<p><b><code>For the full license text, see the [LICENSE-CC](LICENSE-CC) file or visit <a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>. </code></b></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
