<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>infix FFI Library: Porting &lt;tt&gt;infix&lt;/tt&gt; to a New Platform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">infix FFI Library<span id="projectnumber">&#160;0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Porting &lt;tt&gt;infix&lt;/tt&gt; to a New Platform</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md153"></a> This guide outlines the steps required to add support for a new CPU architecture or Application Binary Interface (ABI) to the infix FFI library. We will use <b>RISC-V 64-bit (RV64GC)</b> with the standard <b>LP64D ABI</b> as a practical example.</p>
<p>The library is designed to be highly portable, with a clean separation between platform-agnostic logic and ABI-specific implementations.</p>
<h1><a class="anchor" id="autotoc_md154"></a>
Step 0: Research and Preparation</h1>
<p>This is the most critical step. Before writing any code, you must understand the target ABI. For RISC-V, this means studying the official specification (e.g., <a href="https://riscv.org/wp-content/uploads/2024/12/riscv-calling.pdf">https://riscv.org/wp-content/uploads/2024/12/riscv-calling.pdf</a>).</p>
<p>You need to answer these key questions:</p>
<ul>
<li><b>Integer Argument Registers:</b> Which registers are used for integer and pointer arguments?<ul>
<li><em>RISC-V Answer:</em> <code>a0</code> through <code>a7</code> (also known by their ABI names <code>x10</code> through <code>x17</code>).</li>
</ul>
</li>
<li><b>Floating-Point Argument Registers:</b> Which registers are used for <code>float</code> and <code>double</code> arguments?<ul>
<li><em>RISC-V Answer:</em> <code>fa0</code> through <code>fa7</code> (also known as <code>f10</code> through <code>f17</code>).</li>
</ul>
</li>
<li><b>Return Value Registers:</b> Where are integer and floating-point values returned?<ul>
<li><em>RISC-V Answer:</em> <code>a0</code> and <code>a1</code> for integers/pointers up to 128 bits. <code>fa0</code> and <code>fa1</code> for floats/doubles.</li>
</ul>
</li>
<li><b>Aggregate Passing Rules (Structs/Unions):</b><ul>
<li>How are small structs passed? Can they be split across multiple registers?</li>
<li><em>RISC-V Answer:</em> Small aggregates that fit into two registers (GPRs or FPRs depending on content) are passed by value in registers.</li>
<li>When are they passed by reference (a pointer is passed instead)?</li>
<li><em>RISC-V Answer:</em> Aggregates that are too large or have a non-trivial layout are passed by reference.</li>
</ul>
</li>
<li><b>Callee-Saved Registers:</b> Which registers must be preserved by a called function?<ul>
<li><em>RISC-V Answer:</em> The frame pointer (<code>s0</code>/<code>fp</code>), the return address (<code>ra</code>), and the saved registers <code>s1</code> through <code>s11</code>.</li>
</ul>
</li>
<li><b>Stack Alignment:</b> What is the required stack alignment?<ul>
<li><em>RISC-V Answer:</em> The stack must be 16-byte aligned.</li>
</ul>
</li>
</ul>
<p>If you can answer these questions, you're well on your way to implementing the new ABI.</p>
<h1><a class="anchor" id="autotoc_md155"></a>
Step 1: Platform Detection (&lt;tt&gt;infix.h&lt;/tt&gt;)</h1>
<p>The first step is to teach the library how to recognize the new platform. Open <code><a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a></code> and locate the "Host Platform and Architecture Detection" section.</p>
<ol type="1">
<li><p class="startli"><b>Add Architecture Macro</b>: Add a new <code>#define INFIX_ARCH_*</code> macro. The standard compiler macro for RISC-V is <code>__riscv</code>, and the bit width is checked with <code>__riscv_xlen</code>.</p>
<p class="startli"><code>c // In <a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a>, after the x86-64 and AArch64 checks... #elif defined(__riscv) &amp;&amp; __riscv_xlen == 64 #define INFIX_ARCH_RISCV64 #else #error "Unsupported architecture." #endif </code></p>
</li>
<li><p class="startli"><b>Add ABI Macro</b>: In the "Target ABI Logic Selection" section, define a new <code>INFIX_ABI_*</code> macro based on the combination of OS and architecture. For RISC-V 64-bit, the standard ABI is LP64D.</p>
<p class="startli"><code>c // In <a class="el" href="infix_8h.html" title="The main public header for the infix FFI library.">infix.h</a>, inside the #ifndef INFIX_ABI_FORCED block... #if defined(INFIX_ARCH_AARCH64) // ... #elif defined(INFIX_ARCH_RISCV64) #define INFIX_ABI_LP64D #elif defined(INFIX_ARCH_X64) // ... #endif </code></p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md156"></a>
Step 2: Implement the ABI Specification</h1>
<p>This is the core of the porting effort. You must provide a concrete implementation of the two ABI "specification" structs: <code><a class="el" href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a></code> and <code><a class="el" href="structinfix__reverse__abi__spec.html">infix_reverse_abi_spec</a></code>.</p>
<ol type="1">
<li><b>Create New Files</b>: In the <code>abi/riscv/</code> directory, create the necessary files:<ul>
<li><code>abi_riscv64.c</code></li>
<li><code>abi_riscv64_common.h</code></li>
<li><code>abi_riscv64_emitters.c</code></li>
<li><code>abi_riscv64_emitters.h</code></li>
</ul>
</li>
<li>**Define Register Enums (<code>abi_riscv64_common.h</code>)**: Create enums for the general-purpose registers (GPRs) and floating-point registers (FPRs). This makes the code readable and type-safe.</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// In abi_riscv64_common.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// General-Purpose Registers (GPRs)</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    ZERO_REG = 0, RA_REG = 1, <a class="code hl_enumvalue" href="abi__arm64__common_8h.html#a7c1f154648630ca0306ce870180092b1a779a5703a710b6df83d92df2d80a9bff">SP_REG</a> = 2, GP_REG = 3, TP_REG = 4,</div>
<div class="line">    T0_REG = 5, T1_REG = 6, T2_REG = 7,</div>
<div class="line">    S0_FP_REG = 8, S1_REG = 9,</div>
<div class="line">    A0_REG = 10, A1_REG = 11, A2_REG = 12, A3_REG = 13,</div>
<div class="line">    A4_REG = 14, A5_REG = 15, A6_REG = 16, A7_REG = 17,</div>
<div class="line">    S2_REG = 18, S3_REG = 19, <span class="comment">/* ... s4-s11 ... */</span></div>
<div class="line">    T3_REG = 28, T4_REG = 29, T5_REG = 30, T6_REG = 31</div>
<div class="line">} riscv_gpr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Floating-Point Registers (FPRs)</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    FT0_REG = 0, <span class="comment">/* ... ft0-ft7 ... */</span></div>
<div class="line">    FS0_REG = 8, FS1_REG = 9,</div>
<div class="line">    FA0_REG = 10, FA1_REG = 11, FA2_REG = 12, FA3_REG = 13,</div>
<div class="line">    FA4_REG = 14, FA5_REG = 15, FA6_REG = 16, FA7_REG = 17,</div>
<div class="line">    FS2_REG = 18, <span class="comment">/* ... fs2-fs11 ... */</span></div>
<div class="line">    FT8_REG = 28, <span class="comment">/* ... ft8-ft11 ... */</span></div>
<div class="line">} riscv_fpr;</div>
<div class="ttc" id="aabi__arm64__common_8h_html_a7c1f154648630ca0306ce870180092b1a779a5703a710b6df83d92df2d80a9bff"><div class="ttname"><a href="abi__arm64__common_8h.html#a7c1f154648630ca0306ce870180092b1a779a5703a710b6df83d92df2d80a9bff">SP_REG</a></div><div class="ttdeci">@ SP_REG</div><div class="ttdoc">Stack Pointer (SP). In some instructions, encoding 31 refers to the Zero Register (XZR/WZR).</div><div class="ttdef"><b>Definition</b> abi_arm64_common.h:75</div></div>
</div><!-- fragment --><ol type="1">
<li>**Implement ABI Logic (<code>abi_riscv64.c</code>)**: Define your spec v-tables and implement the ten required functions. The most critical function is <code>prepare_forward_call_frame_riscv64</code>. Your implementation must correctly apply the LP64D ABI rules:<ul>
<li>The first 8 integer/pointer arguments are passed in GPRs <code>a0</code>-<code>a7</code> (<code>x10</code>-<code>x17</code>).</li>
<li>The first 8 floating-point arguments are passed in FPRs <code>fa0</code>-<code>fa7</code> (<code>f10</code>-<code>f17</code>).</li>
<li>Small aggregates (&lt;= 16 bytes) are passed by value, potentially in two GPRs (<code>a0</code>, <code>a1</code>).</li>
<li>Larger aggregates are passed by reference.</li>
<li>Return values are passed in <code>a0</code>/<code>a1</code> for integers/structs and <code>fa0</code>/<code>fa1</code> for floats. Larger structs are returned via a hidden pointer passed by the caller in <code>a0</code>.</li>
</ul>
</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;abi_riscv_common.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;abi_riscv_emitters.h&quot;</span> <span class="comment">// We will create this next</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Forward Declarations for all required functions</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Forward Spec</span></div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> prepare_forward_call_frame_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> generate_forward_prologue_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> generate_forward_argument_moves_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> generate_forward_epilogue_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reverse Spec</span></div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> prepare_reverse_call_frame_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> generate_reverse_prologue_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> generate_reverse_argument_marshalling_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> generate_reverse_dispatcher_call_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> generate_reverse_epilogue_riscv(<span class="comment">/*...*/</span>&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ABI Specification Instances</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a> g_riscv_forward_spec = {</div>
<div class="line">    .prepare_forward_call_frame      = prepare_forward_call_frame_riscv,</div>
<div class="line">    .generate_forward_prologue       = generate_forward_prologue_riscv,</div>
<div class="line">    .generate_forward_argument_moves = generate_forward_argument_moves_riscv,</div>
<div class="line">    .generate_forward_epilogue       = generate_forward_epilogue_riscv</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structinfix__reverse__abi__spec.html">infix_reverse_abi_spec</a> g_riscv_reverse_spec = {</div>
<div class="line">    .prepare_reverse_call_frame            = prepare_reverse_call_frame_riscv,</div>
<div class="line">    .generate_reverse_prologue             = generate_reverse_prologue_riscv,</div>
<div class="line">    .generate_reverse_argument_marshalling = generate_reverse_argument_marshalling_riscv,</div>
<div class="line">    .generate_reverse_dispatcher_call      = generate_reverse_dispatcher_call_riscv,</div>
<div class="line">    .generate_reverse_epilogue             = generate_reverse_epilogue_riscv</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implementation Skeletons</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> prepare_forward_call_frame_riscv(<span class="comment">/*...*/</span>) {</div>
<div class="line">    <span class="comment">// This is the core classification logic.</span></div>
<div class="line">    <span class="comment">// 1. Allocate the infix_call_frame_layout struct.</span></div>
<div class="line">    <span class="comment">// 2. Check if the return type is a large aggregate passed by reference. If so,</span></div>
<div class="line">    <span class="comment">//    the first argument register (a0) is now consumed by a hidden pointer.</span></div>
<div class="line">    <span class="comment">// 3. Iterate through each argument infix_type:</span></div>
<div class="line">    <span class="comment">//    - Classify it as integer, float, or aggregate.</span></div>
<div class="line">    <span class="comment">//    - If there are available registers (a0-a7, fa0-fa7), assign the argument</span></div>
<div class="line">    <span class="comment">//      to one and increment the corresponding register counter.</span></div>
<div class="line">    <span class="comment">//    - If no registers are left, assign it to a stack offset.</span></div>
<div class="line">    <span class="comment">// 4. Calculate the total stack space needed, ensuring 16-byte alignment.</span></div>
<div class="line">    <span class="comment">// 5. Populate and return the completed layout struct.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_enumeration" href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a> generate_forward_prologue_riscv(<a class="code hl_struct" href="structcode__buffer.html">code_buffer</a>* buf, <span class="comment">/*...*/</span>) {</div>
<div class="line">    <span class="comment">// Emit RISC-V assembly for:</span></div>
<div class="line">    <span class="comment">// 1. `addi sp, sp, -stack_size` (allocate stack frame)</span></div>
<div class="line">    <span class="comment">// 2. `sd ra, offset(sp)` (save return address)</span></div>
<div class="line">    <span class="comment">// 3. `sd s0, offset(sp)` (save frame pointer)</span></div>
<div class="line">    <span class="comment">// 4. `mv s0, sp` (establish new frame pointer)</span></div>
<div class="line">    <span class="comment">// 5. Save any other callee-saved registers that will be used by the trampoline.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... implement all other required functions ...</span></div>
<div class="ttc" id="ainfix_8h_html"><div class="ttname"><a href="infix_8h.html">infix.h</a></div><div class="ttdoc">The main public header for the infix FFI library.</div></div>
<div class="ttc" id="ainfix_8h_html_a8643667be6ea1ef9269c2e46d8f11ff7"><div class="ttname"><a href="infix_8h.html#a8643667be6ea1ef9269c2e46d8f11ff7">infix_status</a></div><div class="ttdeci">infix_status</div><div class="ttdoc">An enumeration of all possible success or failure codes from the public API.</div><div class="ttdef"><b>Definition</b> infix.h:363</div></div>
<div class="ttc" id="astructcode__buffer_html"><div class="ttname"><a href="structcode__buffer.html">code_buffer</a></div><div class="ttdoc">An utility structure for dynamically building machine code in memory. @This is not part of the public...</div><div class="ttdef"><b>Definition</b> infix_internals.h:122</div></div>
<div class="ttc" id="astructinfix__forward__abi__spec_html"><div class="ttname"><a href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:217</div></div>
<div class="ttc" id="astructinfix__reverse__abi__spec_html"><div class="ttname"><a href="structinfix__reverse__abi__spec.html">infix_reverse_abi_spec</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:230</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md157"></a>
Step 3: Implement the Instruction Emitters</h1>
<p>In <code>abi_riscv64_emitters.c</code>, you will write functions to generate the 32-bit RISC-V machine code instructions.</p>
<p>For example, to emit <code>ld rd, offset(rs1)</code> (load 64-bit value), which uses the I-Type instruction format:</p>
<div class="fragment"><div class="line"><span class="comment">// In abi_riscv64_emitters.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;abi_riscv64_common.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> emit_riscv64_addi(<a class="code hl_struct" href="structcode__buffer.html">code_buffer</a>* buf, riscv_gpr rd, riscv_gpr rs1, int16_t imm);</div>
<div class="line"><span class="keywordtype">void</span> emit_riscv64_ld(<a class="code hl_struct" href="structcode__buffer.html">code_buffer</a>* buf, riscv_gpr rd, riscv_gpr base, int16_t offset);</div>
<div class="line"><span class="keywordtype">void</span> emit_riscv64_sd(<a class="code hl_struct" href="structcode__buffer.html">code_buffer</a>* buf, riscv_gpr src, riscv_gpr base, int16_t offset);</div>
<div class="line"><span class="keywordtype">void</span> emit_riscv64_jalr(<a class="code hl_struct" href="structcode__buffer.html">code_buffer</a>* buf, riscv_gpr rd, riscv_gpr rs1, int16_t imm);</div>
<div class="line"><span class="comment">// ... and so on for fld, fsd, mv, etc.</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// In abi_riscv64_emitters.c</span></div>
<div class="line"><span class="comment">// Example implementation for an I-type instructions</span></div>
<div class="line"><span class="keywordtype">void</span> emit_riscv_addi(<a class="code hl_struct" href="structcode__buffer.html">code_buffer</a>* buf, riscv_gpr rd, riscv_gpr rs1, int16_t imm) {</div>
<div class="line">    <span class="comment">// The RISC-V ISA specifies the bit fields for each instruction type.</span></div>
<div class="line">    <span class="comment">// This function combines the parts into a single 32-bit word.</span></div>
<div class="line">    <span class="comment">// I-type: [imm(11:0)] [rs1] [funct3] [rd] [opcode]</span></div>
<div class="line">    uint32_t instruction = 0;</div>
<div class="line">    instruction |= ((uint32_t)imm &amp; 0xFFF) &lt;&lt; 20; <span class="comment">// imm[11:0]</span></div>
<div class="line">    instruction |= ((uint32_t)rs1 &amp; 0x1F) &lt;&lt; 15;  <span class="comment">// rs1</span></div>
<div class="line">    instruction |= (0b000) &lt;&lt; 12;                 <span class="comment">// funct3 for ADDI</span></div>
<div class="line">    instruction |= ((uint32_t)rd &amp; 0x1F) &lt;&lt; 7;    <span class="comment">// rd</span></div>
<div class="line">    instruction |= 0b0010011;                     <span class="comment">// Opcode for addi (add immediate0 arithmetic</span></div>
<div class="line">    emit_int32(buf, instruction);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> emit_riscv64_ld(<a class="code hl_struct" href="structcode__buffer.html">code_buffer</a>* buf, riscv_gpr rd, riscv_gpr rs1, int16_t offset) {</div>
<div class="line">    <span class="comment">// I-Type format: | imm[11:0] | rs1 | funct3 | rd | opcode |</span></div>
<div class="line">    uint32_t instruction = 0;</div>
<div class="line">    instruction |= ((uint32_t)offset &amp; 0xFFF) &lt;&lt; 20; <span class="comment">// imm[11:0]</span></div>
<div class="line">    instruction |= ((uint32_t)rs1 &amp; 0x1F) &lt;&lt; 15;     <span class="comment">// rs1</span></div>
<div class="line">    instruction |= (0b011) &lt;&lt; 12;                    <span class="comment">// funct3 for ld</span></div>
<div class="line">    instruction |= ((uint32_t)rd &amp; 0x1F) &lt;&lt; 7;       <span class="comment">// rd</span></div>
<div class="line">    instruction |= 0b0000011;                        <span class="comment">// opcode for LOAD</span></div>
<div class="line">    emit_int32(buf, instruction);</div>
<div class="line">}</div>
</div><!-- fragment --><p> You will need to create similar emitters for <code>sd</code> (store), <code>jalr</code> (jump and link register for calls), and other necessary instructions.</p>
<h1><a class="anchor" id="autotoc_md158"></a>
Step 4: Integrate the New ABI</h1>
<ol type="1">
<li><b>Declare Extern Specs</b>: In <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code>, add an <code>extern</code> declaration for your new spec structs inside a new <code>#if defined(INFIX_ABI_LP64D)</code> block.</li>
<li><p class="startli"><b>Update <code>get_current_*_abi_spec()</code></b>: In <code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a></code>, add your new ABI to the <code>get_current_forward_abi_spec()</code> and <code>get_current_reverse_abi_spec()</code> functions.</p>
<p class="startli">```c // In <a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a> // Add extern declarations at the top of the file if defined(INFIX_ABI_RISCV64) extern const <a class="el" href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a> g_riscv_forward_spec; extern const <a class="el" href="structinfix__reverse__abi__spec.html">infix_reverse_abi_spec</a> g_riscv_reverse_spec; #endif</p>
<p class="startli">// Update the get_current_forward_abi_spec function static const <a class="el" href="structinfix__forward__abi__spec.html">infix_forward_abi_spec</a> * get_current_forward_abi_spec() { // ... #elif defined(INFIX_ABI_AAPCS64) return &amp;g_arm64_forward_spec; #elif defined(INFIX_ABI_RISCV64) return &amp;g_riscv_forward_spec; #else return NULL; #endif }</p>
<p class="startli">// Do the same for get_current_reverse_abi_spec ``<code></code></p>
</li>
<li><p class="startli"><code> **Unity Build**: At the bottom of</code><a class="el" href="trampoline_8c.html" title="The core engine for JIT compiling FFI trampolines.">trampoline.c</a><code>, add an</code>#include<code>for your new</code>.c` files.</p>
<p class="startli"><code>c #elif defined(INFIX_ABI_LP64D) #include "abi_riscv64.c" #include "abi_riscv64_emitters.c" #endif </code></p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md159"></a>
Step 5: Testing</h1>
<p>This is the most important step. You must compile and run the entire test suite on your new target platform, either on real hardware or an emulator like QEMU.</p>
<div class="fragment"><div class="line"># From the build directory on your RISC-V system</div>
<div class="line">make test</div>
</div><!-- fragment --><p>All tests should pass. Pay special attention to tests for aggregate passing (<code><a class="el" href="101__by__value_8c.html" title="Tests passing and returning small aggregate types (structs) by value.">101_by_value.c</a></code>, <code><a class="el" href="102__by__reference_8c.html" title="Tests passing and returning aggregates that are handled by reference.">102_by_reference.c</a></code>). You should add a new subtest to <code><a class="el" href="101__by__value_8c.html" title="Tests passing and returning small aggregate types (structs) by value.">101_by_value.c</a></code> that specifically verifies the passing of a 16-byte struct in the <code>a0</code> and <code>a1</code> registers, as this is a key feature of the RISC-V ABI.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md161"></a>
License and Legal</h1>
<p>Copyright (c) 2025 Sanko Robinson</p>
<p>This documentation is licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0). You are free to share and adapt this material for any purpose, provided you give appropriate credit.</p>
<p>For the full license text, see the [LICENSE-CC](LICENSE-CC) file or visit <a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
