<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>infix: The &lt;tt&gt;infix&lt;/tt&gt; FFI Cookbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">infix
   </div>
   <div id="projectbrief">A JIT-Powered FFI Library for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2cookbook.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The &lt;tt&gt;infix&lt;/tt&gt; FFI Cookbook</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md35"></a> This guide provides practical, real-world examples to help you solve common FFI problems and leverage the full power of the <code>infix</code> library. Where the <code>README.md</code> covers concepts, this cookbook provides the code.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note:</b> For a complete reference on the string format used in these examples (e.g., <code>"int"</code>, <code>"{double, double}"</code>, <code>"*char"</code>), please see the <b><a class="el" href="md_docs_2signatures.html">Signature Language Reference</a></b>. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md36"></a>
Table of Contents</h1>
<ul>
<li><b>Chapter 1: The Basics (Forward Calls)</b><ul>
<li>Recipe: Calling a Simple C Function</li>
<li>Recipe: Passing and Receiving Pointers</li>
<li>Recipe: Working with &quot;Out&quot; Parameters</li>
<li>Recipe: Working with Opaque Pointers (Incomplete Types)</li>
</ul>
</li>
<li><b>Chapter 2: Handling Complex Data Structures</b><ul>
<li>Recipe: Small Structs Passed by Value</li>
<li>Recipe: Receiving a Struct from a Function</li>
<li>Recipe: Large Structs Passed by Reference</li>
<li>Recipe: Working with Packed Structs</li>
<li>Recipe: Working with Structs that Contain Bitfields</li>
<li>Recipe: Working with Unions</li>
<li>Recipe: Working with Fixed-Size Arrays</li>
<li>Recipe: Working with Complex Numbers</li>
<li>Recipe: Working with SIMD Vectors</li>
<li>Recipe: Working with Enums</li>
</ul>
</li>
<li><b>Chapter 3: The Power of Callbacks (Reverse Calls)</b><ul>
<li>Recipe: Creating a Stateless Callback for `qsort`</li>
<li>Recipe: Creating a Stateful Callback</li>
</ul>
</li>
<li><b>Chapter 4: Advanced Techniques</b><ul>
<li>Recipe: Calling Variadic Functions like `printf`</li>
<li>Recipe: Receiving and Calling a Function Pointer</li>
<li>Recipe: Calling a Function Pointer from a Struct (V-Table Emulation)</li>
<li>Recipe: Handling `long double`</li>
<li>Recipe: Proving Reentrancy with Nested FFI Calls</li>
<li>Recipe: Proving Thread Safety</li>
</ul>
</li>
<li><b>Chapter 5: Interoperability with Other Languages</b><ul>
<li>The Universal Principle: The C ABI</li>
<li>Recipe: Interfacing with a C++ Class (Directly)</li>
<li>Recipe: Interfacing with C++ Templates</li>
<li>The Pattern for Other Compiled Languages<ul>
<li>Rust</li>
<li>Zig</li>
<li>Go</li>
<li>Swift</li>
<li>Dlang</li>
<li>Fortran</li>
<li>Assembly</li>
</ul>
</li>
</ul>
</li>
<li><b>Chapter 6: Dynamic Libraries &amp; System Calls</b><ul>
<li>Recipe: Calling Native System Libraries without Linking</li>
<li>Recipe: Reading and Writing Global Variables</li>
<li>Recipe: Handling Library Dependencies</li>
</ul>
</li>
<li><b>Chapter 7: Introspection for Data Marshalling</b><ul>
<li>Recipe: Dynamic Struct Marshalling with the Signature Parser</li>
<li>Recipe: Building a Signature String at Runtime</li>
<li>Recipe: Introspecting a Trampoline for a Wrapper</li>
</ul>
</li>
<li><b>Chapter 8: Performance &amp; Memory Management</b><ul>
<li>Best Practice: Caching Trampolines</li>
<li>Recipe: Using a Custom Arena for a Group of Types</li>
<li>Recipe: Using Custom Memory Allocators</li>
</ul>
</li>
<li><b>Chapter 9: Common Pitfalls &amp; Troubleshooting</b><ul>
<li>Mistake: Passing a Value Instead of a Pointer in `args[]`</li>
<li>Mistake: `infix` Signature Mismatch</li>
<li>Pitfall: Function Pointer Syntax</li>
</ul>
</li>
<li><b>Chapter 10: A Comparative Look: `infix` vs. `libffi` and `dyncall`</b></li>
<li><b>Chapter 11: Building Language Bindings</b><ul>
<li>The Four Pillars of a Language Binding</li>
<li>Recipe: Porting a Python Binding from `dyncall` to `infix`</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md38"></a>
Chapter 1: The Basics (Forward Calls)</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Recipe: Calling a Simple C Function</h2>
<p><b>Problem</b>: You want to call a standard C function, like <code>atan2</code> from the math library. <b>Solution</b>: Describe the function's signature, prepare pointers to your arguments, and invoke the function through a generated trampoline. An "unbound" trampoline is ideal when you want to call multiple functions that share the same signature.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_simple_forward_call() {</div>
<div class="line">    <span class="comment">// 1. Describe the signature: double atan2(double y, double x);</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(double, double) -&gt; double&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Create an unbound trampoline. The function to call is not specified yet.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga524a8ccebd24c9232d30cb2f79aee5a5">infix_forward_create_unbound</a>(&amp;trampoline, signature, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Get the callable function pointer.</span></div>
<div class="line">    <a class="code hl_typedef" href="group__public__api.html#ga48f7ee868576f525269902fc953887bd">infix_unbound_cif_func</a> cif = <a class="code hl_function" href="group__introspection__api.html#ga5f3559908e6a7bcc72103c52937d67ad">infix_forward_get_unbound_code</a>(trampoline);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Prepare arguments. The args array must hold *pointers* to the values.</span></div>
<div class="line">    <span class="keywordtype">double</span> y = 1.0, x = 1.0;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;y, &amp;x };</div>
<div class="line">    <span class="keywordtype">double</span> result;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Invoke the call, passing the target function `atan2` as the first argument.</span></div>
<div class="line">    cif((<span class="keywordtype">void</span>*)atan2, &amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;atan2(1.0, 1.0) = %f (PI/4)\n&quot;</span>, result);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 6. Clean up.</span></div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(trampoline);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__high__level__api_html_ga524a8ccebd24c9232d30cb2f79aee5a5"><div class="ttname"><a href="group__high__level__api.html#ga524a8ccebd24c9232d30cb2f79aee5a5">infix_forward_create_unbound</a></div><div class="ttdeci">c23_nodiscard infix_status infix_forward_create_unbound(infix_forward_t **, const char *, infix_registry_t *)</div><div class="ttdoc">Generates an unbound forward-call trampoline from a signature string.</div><div class="ttdef"><b>Definition</b> signature.c:1189</div></div>
<div class="ttc" id="agroup__introspection__api_html_ga5f3559908e6a7bcc72103c52937d67ad"><div class="ttname"><a href="group__introspection__api.html#ga5f3559908e6a7bcc72103c52937d67ad">infix_forward_get_unbound_code</a></div><div class="ttdeci">c23_nodiscard infix_unbound_cif_func infix_forward_get_unbound_code(infix_forward_t *)</div><div class="ttdoc">Retrieves the executable code pointer from an unbound forward trampoline.</div><div class="ttdef"><b>Definition</b> trampoline.c:213</div></div>
<div class="ttc" id="agroup__manual__api_html_gad87a8882dec00b89a4bc5c87db2fc032"><div class="ttname"><a href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a></div><div class="ttdeci">void infix_forward_destroy(infix_forward_t *)</div><div class="ttdoc">Frees a forward trampoline and its associated executable memory.</div><div class="ttdef"><b>Definition</b> trampoline.c:400</div></div>
<div class="ttc" id="agroup__public__api_html_ga48f7ee868576f525269902fc953887bd"><div class="ttname"><a href="group__public__api.html#ga48f7ee868576f525269902fc953887bd">infix_unbound_cif_func</a></div><div class="ttdeci">void(* infix_unbound_cif_func)(void *, void *, void **)</div><div class="ttdoc">The signature for a generic &quot;unbound&quot; forward-call trampoline.</div><div class="ttdef"><b>Definition</b> infix.h:334</div></div>
<div class="ttc" id="ainfix_8h_html"><div class="ttname"><a href="infix_8h.html">infix.h</a></div></div>
<div class="ttc" id="astructinfix__forward__t_html"><div class="ttname"><a href="structinfix__forward__t.html">infix_forward_t</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:72</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
Recipe: Passing and Receiving Pointers</h2>
<p><b>Problem</b>: You need to call a C function that takes a pointer as an argument and returns a pointer, like <code>strchr</code>. <b>Solution</b>: Use the <code>*</code> prefix for pointer types. The value in the <code>args</code> array for a pointer argument is the address of your pointer variable.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_pointer_args_and_return() {</div>
<div class="line">    <span class="comment">// Signature for: const char* strchr(const char* s, int c);</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(*char, int) -&gt; *char&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;trampoline, signature, (<span class="keywordtype">void</span>*)strchr, NULL);</div>
<div class="line">    <a class="code hl_typedef" href="group__public__api.html#ga3042690c20cccd4137f134154bd62e1a">infix_cif_func</a> cif = <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(trampoline);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack = <span class="stringliteral">&quot;hello-world&quot;</span>;</div>
<div class="line">    <span class="keywordtype">int</span> needle = <span class="charliteral">&#39;-&#39;</span>;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;haystack, &amp;needle };</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* result_ptr = NULL;</div>
<div class="line"> </div>
<div class="line">    cif(&amp;result_ptr, args);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (result_ptr) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;strchr found: &#39;%s&#39;\n&quot;</span>, result_ptr); <span class="comment">// Expected: &quot;-world&quot;</span></div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(trampoline);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__high__level__api_html_ga5362b6f6976298aebefdb2a487e72e36"><div class="ttname"><a href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a></div><div class="ttdeci">c23_nodiscard infix_status infix_forward_create(infix_forward_t **, const char *, void *, infix_registry_t *)</div><div class="ttdoc">Generates a bound forward-call trampoline from a signature string.</div><div class="ttdef"><b>Definition</b> signature.c:1202</div></div>
<div class="ttc" id="agroup__introspection__api_html_ga32fc7e60dd474cebc4ac082e49ac9ea8"><div class="ttname"><a href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a></div><div class="ttdeci">c23_nodiscard infix_cif_func infix_forward_get_code(infix_forward_t *)</div><div class="ttdoc">Retrieves the executable code pointer from a bound forward trampoline.</div><div class="ttdef"><b>Definition</b> trampoline.c:223</div></div>
<div class="ttc" id="agroup__public__api_html_ga3042690c20cccd4137f134154bd62e1a"><div class="ttname"><a href="group__public__api.html#ga3042690c20cccd4137f134154bd62e1a">infix_cif_func</a></div><div class="ttdeci">void(* infix_cif_func)(void *, void **)</div><div class="ttdoc">The signature for a &quot;bound&quot; forward-call trampoline.</div><div class="ttdef"><b>Definition</b> infix.h:354</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md41"></a>
Recipe: Working with "Out" Parameters</h2>
<p><b>Problem</b>: You need to call a C function that doesn't use its return value for its primary output. Instead, it takes a pointer to a variable and writes the result into it. This is a very common pattern for functions that need to return multiple values or an error code.</p>
<p><b>Solution</b>: The signature is straightforward. The "out" parameter is simply a pointer type (<code>*&lt;type&gt;</code>). In your calling code, you create a local variable and pass its address in the <code>args</code> array.</p>
<div class="fragment"><div class="line"><span class="comment">// Native C function to be called:</span></div>
<div class="line"><span class="comment">// bool get_user_stats(int user_id, int* out_posts, double* out_score);</span></div>
<div class="line"><span class="keywordtype">bool</span> get_user_stats(<span class="keywordtype">int</span> user_id, <span class="keywordtype">int</span>* out_posts, <span class="keywordtype">double</span>* out_score) {</div>
<div class="line">    <span class="keywordflow">if</span> (user_id == 123) {</div>
<div class="line">        <span class="keywordflow">if</span>(out_posts) *out_posts = 50;</div>
<div class="line">        <span class="keywordflow">if</span>(out_score) *out_score = 99.8;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_out_parameters() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(int, *int, *double) -&gt; bool&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)get_user_stats, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> user_id = 123;</div>
<div class="line">    <span class="comment">// These are our &quot;out&quot; variables. They will be modified by the C function.</span></div>
<div class="line">    <span class="keywordtype">int</span> post_count = 0;</div>
<div class="line">    <span class="keywordtype">double</span> score = 0.0;</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The args array contains pointers to our local variables.</span></div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;user_id, &amp;post_count, &amp;score };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;success, args);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (success) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;User stats: Posts=%d, Score=%.1f\n&quot;</span>, post_count, score); <span class="comment">// Expected: 50, 99.8</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md42"></a>
Recipe: Working with Opaque Pointers (Incomplete Types)</h2>
<p><b>Problem</b>: You need to interact with a C library that uses opaque pointers or handles (e.g., <code>FILE*</code>, <code>sqlite3*</code>) where the internal structure is hidden. <b>Solution</b>: Use the <code>*void</code> signature. This is the canonical representation for any generic handle. Using a registry to create a type alias like <code>@FileHandle = *void;</code> can make your signatures more readable.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_opaque_pointers() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__registry__t.html">infix_registry_t</a>* reg = <a class="code hl_function" href="group__registry__api.html#gac808273483db7a9db2bc275c41b13296">infix_registry_create</a>();</div>
<div class="line">    <a class="code hl_function" href="group__registry__api.html#ga4ece2363948c40fe528826bf65dac280">infix_register_types</a>(reg, <span class="stringliteral">&quot;@FileHandle = *void;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> *t_fopen, *t_fputs, *t_fclose;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t_fopen, <span class="stringliteral">&quot;(*char, *char) -&gt; @FileHandle&quot;</span>, (<span class="keywordtype">void</span>*)fopen, reg);</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t_fputs, <span class="stringliteral">&quot;(*char, @FileHandle) -&gt; int&quot;</span>, (<span class="keywordtype">void</span>*)fputs, reg);</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t_fclose, <span class="stringliteral">&quot;(@FileHandle) -&gt; int&quot;</span>, (<span class="keywordtype">void</span>*)fclose, reg);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* file_handle = NULL; <span class="comment">// This will hold our opaque FILE*</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = <span class="stringliteral">&quot;test.txt&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* mode = <span class="stringliteral">&quot;w&quot;</span>;</div>
<div class="line">    <span class="keywordtype">void</span>* fopen_args[] = { &amp;filename, &amp;mode };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t_fopen)(&amp;file_handle, fopen_args);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (file_handle) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* content = <span class="stringliteral">&quot;Written by infix!&quot;</span>;</div>
<div class="line">        <span class="keywordtype">void</span>* fputs_args[] = { &amp;content, &amp;file_handle };</div>
<div class="line">        <span class="keywordtype">int</span> result;</div>
<div class="line">        <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t_fputs)(&amp;result, fputs_args);</div>
<div class="line">        <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t_fclose)(&amp;result, &amp;file_handle);</div>
<div class="line">        printf(<span class="stringliteral">&quot;Successfully wrote to test.txt\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t_fopen);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t_fputs);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t_fclose);</div>
<div class="line">    <a class="code hl_function" href="group__registry__api.html#ga4c3b0c1f77732fc2f8aa0a8de62f8a1a">infix_registry_destroy</a>(reg);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__registry__api_html_ga4c3b0c1f77732fc2f8aa0a8de62f8a1a"><div class="ttname"><a href="group__registry__api.html#ga4c3b0c1f77732fc2f8aa0a8de62f8a1a">infix_registry_destroy</a></div><div class="ttdeci">void infix_registry_destroy(infix_registry_t *registry)</div><div class="ttdoc">Frees a type registry and all type definitions and metadata contained within it.</div><div class="ttdef"><b>Definition</b> type_registry.c:166</div></div>
<div class="ttc" id="agroup__registry__api_html_ga4ece2363948c40fe528826bf65dac280"><div class="ttname"><a href="group__registry__api.html#ga4ece2363948c40fe528826bf65dac280">infix_register_types</a></div><div class="ttdeci">c23_nodiscard infix_status infix_register_types(infix_registry_t *, const char *)</div><div class="ttdoc">Implementation of the public infix_register_types function.</div><div class="ttdef"><b>Definition</b> type_registry.c:233</div></div>
<div class="ttc" id="agroup__registry__api_html_gac808273483db7a9db2bc275c41b13296"><div class="ttname"><a href="group__registry__api.html#gac808273483db7a9db2bc275c41b13296">infix_registry_create</a></div><div class="ttdeci">c23_nodiscard infix_registry_t * infix_registry_create(void)</div><div class="ttdoc">Creates a new, empty type registry.</div><div class="ttdef"><b>Definition</b> type_registry.c:131</div></div>
<div class="ttc" id="astructinfix__registry__t_html"><div class="ttname"><a href="structinfix__registry__t.html">infix_registry_t</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:157</div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md44"></a>
Chapter 2: Handling Complex Data Structures</h1>
<div class="fragment"><div class="line"><span class="comment">// Common C struct used in this chapter&#39;s examples</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">double</span> x, y; } Point;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md45"></a>
Recipe: Small Structs Passed by Value</h2>
<p><b>Problem</b>: You need to call a function that takes a small <code>struct</code> that the ABI passes in registers. <b>Solution</b>: Use the struct syntax <code>({...})</code>. <code>infix</code> will automatically determine the correct ABI passing convention for the target platform.</p>
<div class="fragment"><div class="line">Point move_point(Point p, <span class="keywordtype">double</span> dx) { p.x += dx; <span class="keywordflow">return</span> p; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_pass_struct_by_value() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;({double, double}, double) -&gt; {double, double}&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;trampoline, signature, (<span class="keywordtype">void</span>*)move_point, NULL);</div>
<div class="line"> </div>
<div class="line">    Point start = { 10.0, 20.0 };</div>
<div class="line">    <span class="keywordtype">double</span> delta_x = 5.5;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;start, &amp;delta_x };</div>
<div class="line">    Point end;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(trampoline)(&amp;end, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Moved point has x = %f\n&quot;</span>, end.x); <span class="comment">// Should be 15.5</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(trampoline);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md46"></a>
Recipe: Receiving a Struct from a Function</h2>
<p><b>Problem</b>: You need to call a function that <em>returns</em> a struct by value. <b>Solution</b>: <code>infix</code> handles the ABI details, whether the struct is returned in registers or via a hidden pointer passed by the caller.</p>
<div class="fragment"><div class="line">Point make_point(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) { <span class="keywordflow">return</span> (Point){x, y}; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_return_struct() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(double, double) -&gt; {double, double}&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;trampoline, signature, (<span class="keywordtype">void</span>*)make_point, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> x = 100.0, y = 200.0;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;x, &amp;y };</div>
<div class="line">    Point result;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(trampoline)(&amp;result, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Received point: {x=%.1f, y=%.1f}\n&quot;</span>, result.x, result.y);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(trampoline);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md47"></a>
Recipe: Large Structs Passed by Reference</h2>
<p><b>Problem</b>: A function takes a struct that is too large to fit in registers. <b>Solution</b>: The process is identical to the small struct example. <code>infix</code>'s ABI logic will detect that the struct is large and automatically pass it by reference (the standard C ABI rule).</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">int</span> data; } LargeStruct;</div>
<div class="line"><span class="keywordtype">int</span> get_first_element(LargeStruct s) { <span class="keywordflow">return</span> s.data; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_large_struct() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;({[8:int]}) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)get_first_element, NULL);</div>
<div class="line"> </div>
<div class="line">    LargeStruct my_struct = { {123, -1, -1, -1, -1, -1, -1, -1} };</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;my_struct };</div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;First element of large struct: %d\n&quot;</span>, result); <span class="comment">// Should be 123</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
Recipe: Working with Packed Structs</h2>
<p><b>Problem</b>: You need to call a function that takes a <code>__attribute__((packed))</code> struct. <b>Solution</b>: Use the <code>!{...}</code> syntax for 1-byte alignment, or <code>!N:{...}</code> to specify a maximum alignment of <code>N</code> bytes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma pack(push, 1)</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">char</span> a; uint64_t b; } Packed; <span class="comment">// Total size is 9 bytes</span></div>
<div class="line"><span class="preprocessor">#pragma pack(pop)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> process_packed(Packed p) { <span class="keywordflow">return</span> (p.a == <span class="charliteral">&#39;X&#39;</span> &amp;&amp; p.b == 0x1122334455667788ULL) ? 42 : -1; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_packed_struct() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(!{char, uint64}) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)process_packed, NULL);</div>
<div class="line"> </div>
<div class="line">    Packed p = {<span class="charliteral">&#39;X&#39;</span>, 0x1122334455667788ULL};</div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = {&amp;p};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Packed struct result: %d\n&quot;</span>, result);  <span class="comment">// Expected: 42</span></div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md49"></a>
Recipe: Working with Structs that Contain Bitfields</h2>
<p><b>Problem</b>: You need to interact with a C struct that uses bitfields. <code>infix</code>'s signature language has no syntax for bitfields because their memory layout is implementation-defined and not portable. <b>Solution</b>: Treat the underlying integer that holds the bitfields as a single member in your signature. Then, use C's bitwise operators in your wrapper code to manually pack and unpack the values before and after the FFI call.</p>
<div class="fragment"><div class="line"><span class="comment">// The native C struct with bitfields.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint32_t a : 4; <span class="comment">// 4 bits</span></div>
<div class="line">    uint32_t b : 12;<span class="comment">// 12 bits</span></div>
<div class="line">    uint32_t c : 16;<span class="comment">// 16 bits</span></div>
<div class="line">} BitfieldStruct; <span class="comment">// Total size is sizeof(uint32_t)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The native function we want to call.</span></div>
<div class="line">uint32_t process_bitfields(BitfieldStruct s) {</div>
<div class="line">    <span class="keywordflow">return</span> s.a + s.b + s.c;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_bitfields() {</div>
<div class="line">    <span class="comment">// 1. Describe the struct by its underlying integer storage.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;({uint32}) -&gt; uint32&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)process_bitfields, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Manually pack the data into a uint32_t.</span></div>
<div class="line">    uint32_t packed_data = 0;</div>
<div class="line">    packed_data |= (15 &amp; 0xF) &lt;&lt; 0;  <span class="comment">// Field a = 15</span></div>
<div class="line">    packed_data |= (1000 &amp; 0xFFF) &lt;&lt; 4; <span class="comment">// Field b = 1000</span></div>
<div class="line">    packed_data |= (30000 &amp; 0xFFFF) &lt;&lt; 16; <span class="comment">// Field c = 30000</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. The FFI call sees a simple struct { uint32_t; }.</span></div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;packed_data };</div>
<div class="line">    uint32_t result;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Bitfield sum: %u\n&quot;</span>, result); <span class="comment">// Expected: 31015</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md50"></a>
Recipe: Working with Unions</h2>
<p><b>Problem</b>: You need to call a function that passes or returns a <code>union</code>. <b>Solution</b>: Use the <code>&lt;...&gt;</code> syntax to describe the union's members.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span>{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; } Number;</div>
<div class="line"><span class="keywordtype">int</span> process_number_as_int(Number n) { <span class="keywordflow">return</span> n.i * 2; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_union() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(&lt;int, float&gt;) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)process_number_as_int, NULL);</div>
<div class="line"> </div>
<div class="line">    Number num_val;</div>
<div class="line">    num_val.i = 21;</div>
<div class="line">    <span class="keywordtype">int</span> result = 0;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = {&amp;num_val};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Result: %d\n&quot;</span>, result);  <span class="comment">// Expected: 42</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md51"></a>
Recipe: Working with Fixed-Size Arrays</h2>
<p><b>Problem</b>: A function takes a fixed-size array, like <code>long long sum(long long arr[4]);</code>. <b>Solution</b>: In C, an array argument "decays" to a pointer to its first element. The signature must reflect this. To describe the array <em>itself</em> (e.g., inside a struct), use the <code>[N:type]</code> syntax.</p>
<div class="fragment"><div class="line"><span class="comment">// In C, a function parameter `arr[4]` is treated as a pointer `arr*`.</span></div>
<div class="line">int64_t sum_array_elements(<span class="keyword">const</span> int64_t* arr, <span class="keywordtype">size_t</span> count) {</div>
<div class="line">    int64_t sum = 0;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; count; ++i) sum += arr[i];</div>
<div class="line">    <span class="keywordflow">return</span> sum;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_array_decay() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(*sint64, sint64) -&gt; sint64&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)sum_array_elements, NULL);</div>
<div class="line"> </div>
<div class="line">    int64_t my_array[] = {10, 20, 30, 40};</div>
<div class="line">    <span class="keyword">const</span> int64_t* ptr_to_array = my_array;</div>
<div class="line">    int64_t count = 4; <span class="comment">// Using int64_t for sint64 signature</span></div>
<div class="line">    <span class="keywordtype">void</span>* args[] = {&amp;ptr_to_array, &amp;count};</div>
<div class="line">    int64_t result = 0;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Sum of array is: %lld\n&quot;</span>, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)result);  <span class="comment">// Expected: 100</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
Recipe: Working with Complex Numbers</h2>
<p><b>Problem</b>: You need to call a C function that uses <code>_Complex</code> types. <b>Solution</b>: Use the <code>c[&lt;base_type&gt;]</code> constructor in the signature string.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;complex.h&gt;</span></div>
<div class="line"><span class="keywordtype">double</span> complex c_square(<span class="keywordtype">double</span> complex z) { <span class="keywordflow">return</span> z * z; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_complex() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(c[double]) -&gt; c[double]&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)c_square, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> complex input = 3.0 + 4.0 * I;</div>
<div class="line">    <span class="keywordtype">double</span> complex result;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = {&amp;input};</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;The square of (3.0 + 4.0i) is (%.1f + %.1fi)\n&quot;</span>, creal(result), cimag(result));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md53"></a>
Recipe: Working with SIMD Vectors</h2>
<p><b>Problem</b>: You need to call a high-performance C function that uses SIMD vector types. <b>Solution</b>: Use the <code>v[&lt;elements&gt;:&lt;type&gt;]</code> syntax. The ABI logic will ensure the vector is passed in a SIMD register.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;emmintrin.h&gt;</span> <span class="comment">// For SSE2 intrinsics on x86/x64</span></div>
<div class="line">__m128d vector_add(__m128d a, __m128d b) { <span class="keywordflow">return</span> _mm_add_pd(a, b); }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_simd() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(v[2:double], v[2:double]) -&gt; v[2:double]&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)vector_add, NULL);</div>
<div class="line"> </div>
<div class="line">    __m128d a = _mm_set_pd(20.0, 10.0);</div>
<div class="line">    __m128d b = _mm_set_pd(22.0, 32.0);</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = {&amp;a, &amp;b};</div>
<div class="line">    __m128d result;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line">    <span class="keywordtype">double</span>* d = (<span class="keywordtype">double</span>*)&amp;result;</div>
<div class="line">    <span class="comment">// Note: The result of _mm_add_pd is {a[0]+b[0], a[1]+b[1]}, which is {10+32, 20+22}</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;SIMD vector result: [%.1f, %.1f]\n&quot;</span>, d[0], d[1]); <span class="comment">// Expected: [42.0, 42.0]</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md54"></a>
&lt;strong&gt;Recipe: Working with Enums&lt;/strong&gt;</h2>
<p><b>Problem</b>: You need to call a C function that takes an <code>enum</code>, but you want to ensure the underlying integer type is handled correctly for ABI purposes.</p>
<p><b>Solution</b>: Use the <code>e:&lt;type&gt;</code> syntax in the signature string. <code>infix</code> treats the enum identically to its underlying integer type for the FFI call, which is the correct behavior.</p>
<div class="fragment"><div class="line"><span class="comment">// Native C enum and function</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> { STATUS_OK = 0, STATUS_WARN = 1, STATUS_ERR = -1 } StatusCode;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* status_to_string(StatusCode code) {</div>
<div class="line">    <span class="keywordflow">switch</span> (code) {</div>
<div class="line">        <span class="keywordflow">case</span> STATUS_OK: <span class="keywordflow">return</span> <span class="stringliteral">&quot;OK&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> STATUS_WARN: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Warning&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> STATUS_ERR: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error&quot;</span>;</div>
<div class="line">        <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Unknown&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_enums() {</div>
<div class="line">    <span class="comment">// The C `enum` is based on `int`, so we describe it as `e:int`.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(e:int) -&gt; *char&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)status_to_string, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass the enum value as its underlying integer type.</span></div>
<div class="line">    <span class="keywordtype">int</span> code = STATUS_ERR;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* result_str = NULL;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;code };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result_str, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Status for code %d is &#39;%s&#39;\n&quot;</span>, code, result_str); <span class="comment">// Expected: &#39;Error&#39;</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md56"></a>
Chapter 3: The Power of Callbacks (Reverse Calls)</h1>
<h2><a class="anchor" id="autotoc_md57"></a>
Recipe: Creating a Stateless Callback for &lt;tt&gt;qsort&lt;/tt&gt;</h2>
<p><b>Problem</b>: You need to sort an array using C's <code>qsort</code>, which requires a function pointer for the comparison logic. <b>Solution</b>: Use a reverse trampoline. The handler's signature must accept <code>infix_context_t*</code> as its first argument.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> compare_integers_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a>* ctx, <span class="keyword">const</span> <span class="keywordtype">int</span>* a, <span class="keyword">const</span> <span class="keywordtype">int</span>* b) {</div>
<div class="line">    (void)ctx; <span class="comment">// Unused</span></div>
<div class="line">    <span class="keywordflow">return</span> (*a - *b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_qsort_callback() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a>* context = NULL;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* cmp_sig = <span class="stringliteral">&quot;(*void, *void) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga7d09d07b70706cb1a949e2efd5f5f471">infix_reverse_create</a>(&amp;context, cmp_sig, (<span class="keywordtype">void</span>*)compare_integers_handler, NULL, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> int (*compare_func_t)(<span class="keyword">const</span> <span class="keywordtype">void</span>*, <span class="keyword">const</span> <span class="keywordtype">void</span>*);</div>
<div class="line">    compare_func_t my_comparator = (compare_func_t)<a class="code hl_function" href="group__introspection__api.html#ga3b75e8481ac13d11faa15046fc4adb66">infix_reverse_get_code</a>(context);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> numbers[] = { 5, 1, 4, 2, 3 };</div>
<div class="line">    <span class="keywordtype">size_t</span> num_count = <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(numbers);</div>
<div class="line">    qsort(numbers, num_count, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), my_comparator);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Sorted numbers:&quot;</span>);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; num_count; ++i) {</div>
<div class="line">        printf(<span class="stringliteral">&quot; %d&quot;</span>, numbers[i]);</div>
<div class="line">    }</div>
<div class="line">    printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#ga00b101025663c423a28433e139be5d4e">infix_reverse_destroy</a>(context);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__high__level__api_html_ga7d09d07b70706cb1a949e2efd5f5f471"><div class="ttname"><a href="group__high__level__api.html#ga7d09d07b70706cb1a949e2efd5f5f471">infix_reverse_create</a></div><div class="ttdeci">c23_nodiscard infix_status infix_reverse_create(infix_reverse_t **, const char *, void *, void *, infix_registry_t *)</div><div class="ttdoc">Generates a reverse-call trampoline (callback) from a signature string.</div><div class="ttdef"><b>Definition</b> signature.c:1239</div></div>
<div class="ttc" id="agroup__introspection__api_html_ga3b75e8481ac13d11faa15046fc4adb66"><div class="ttname"><a href="group__introspection__api.html#ga3b75e8481ac13d11faa15046fc4adb66">infix_reverse_get_code</a></div><div class="ttdeci">c23_nodiscard void * infix_reverse_get_code(const infix_reverse_t *)</div><div class="ttdoc">Retrieves the executable code pointer from a reverse trampoline.</div><div class="ttdef"><b>Definition</b> trampoline.c:586</div></div>
<div class="ttc" id="agroup__manual__api_html_ga00b101025663c423a28433e139be5d4e"><div class="ttname"><a href="group__manual__api.html#ga00b101025663c423a28433e139be5d4e">infix_reverse_destroy</a></div><div class="ttdeci">void infix_reverse_destroy(infix_reverse_t *)</div><div class="ttdoc">Frees a reverse trampoline, its JIT-compiled stub, and its context.</div><div class="ttdef"><b>Definition</b> trampoline.c:607</div></div>
<div class="ttc" id="astructinfix__reverse__t_html"><div class="ttname"><a href="structinfix__reverse__t.html">infix_reverse_t</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:102</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md58"></a>
Recipe: Creating a Stateful Callback</h2>
<p><b>Problem</b>: A callback handler needs access to application state, but the C library API is stateless (it has no <code>void* user_data</code> parameter). <b>Solution</b>: <code>infix</code> automatically passes a pointer to the <code>infix_context_t</code> as the first argument to every handler. Store your application state in the context's <code>user_data</code> field.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> * name; <span class="keywordtype">int</span> sum; } AppContext;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_stateful_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a>* context, <span class="keywordtype">int</span> item_value) {</div>
<div class="line">    AppContext* ctx = (AppContext*)<a class="code hl_function" href="group__introspection__api.html#gab41c717a6e4e4198c62284e526e5d9b3">infix_reverse_get_user_data</a>(context);</div>
<div class="line">    ctx-&gt;sum += item_value;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> void (*item_processor_t)(int);</div>
<div class="line"><span class="keywordtype">void</span> process_list(<span class="keywordtype">int</span>* items, <span class="keywordtype">int</span> count, item_processor_t process_func) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i) process_func(items[i]);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_stateful_callback() {</div>
<div class="line">    AppContext ctx = {<span class="stringliteral">&quot;My List&quot;</span>, 0};</div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a>* rt = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga7d09d07b70706cb1a949e2efd5f5f471">infix_reverse_create</a>(&amp;rt, <span class="stringliteral">&quot;(int) -&gt; void&quot;</span>, (<span class="keywordtype">void</span>*)my_stateful_handler, &amp;ctx, NULL);</div>
<div class="line"> </div>
<div class="line">    item_processor_t processor_ptr = (item_processor_t)<a class="code hl_function" href="group__introspection__api.html#ga3b75e8481ac13d11faa15046fc4adb66">infix_reverse_get_code</a>(rt);</div>
<div class="line">    <span class="keywordtype">int</span> list[] = {10, 20, 30};</div>
<div class="line">    process_list(list, 3, processor_ptr);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Final sum for &#39;%s&#39;: %d\n&quot;</span>, ctx.name, ctx.sum);  <span class="comment">// Expected: 60</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#ga00b101025663c423a28433e139be5d4e">infix_reverse_destroy</a>(rt);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__introspection__api_html_gab41c717a6e4e4198c62284e526e5d9b3"><div class="ttname"><a href="group__introspection__api.html#gab41c717a6e4e4198c62284e526e5d9b3">infix_reverse_get_user_data</a></div><div class="ttdeci">c23_nodiscard void * infix_reverse_get_user_data(const infix_reverse_t *)</div><div class="ttdoc">Retrieves the user_data stored with a reverse trampoline.</div><div class="ttdef"><b>Definition</b> trampoline.c:596</div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md60"></a>
Chapter 4: Advanced Techniques</h1>
<h2><a class="anchor" id="autotoc_md61"></a>
Recipe: Calling Variadic Functions like &lt;tt&gt;printf&lt;/tt&gt;</h2>
<p><b>Problem</b>: You need to call a function with a variable number of arguments. <b>Solution</b>: Use the <code>;</code> token to separate fixed and variadic arguments. The signature must exactly match the types you are passing in a <em>specific call</em>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> recipe_variadic_printf() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(*char; int, double) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;trampoline, signature, (<span class="keywordtype">void</span>*)printf, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* fmt = <span class="stringliteral">&quot;Count: %d, Value: %.2f\n&quot;</span>;</div>
<div class="line">    <span class="keywordtype">int</span> count = 42;</div>
<div class="line">    <span class="keywordtype">double</span> value = 123.45;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;fmt, &amp;count, &amp;value };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(trampoline)(NULL, args);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(trampoline);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
Recipe: Receiving and Calling a Function Pointer</h2>
<p><b>Problem</b>: You need to call a C function that <em>takes</em> a function pointer as an argument, and pass it a callback you generate. <b>Solution</b>: The signature for a function pointer is <code>*((...) -&gt; ...)</code>. Generate your callback, get its native pointer, and pass that pointer as an argument.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> multiply_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a>* ctx, <span class="keywordtype">int</span> x) { (void)ctx; <span class="keywordflow">return</span> x * 10; }</div>
<div class="line"><span class="keywordtype">int</span> harness_func(<span class="keywordtype">int</span> (*worker_func)(<span class="keywordtype">int</span>), <span class="keywordtype">int</span> base_val) { <span class="keywordflow">return</span> worker_func(base_val); }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_callback_as_arg() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a>* inner_cb_ctx = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga7d09d07b70706cb1a949e2efd5f5f471">infix_reverse_create</a>(&amp;inner_cb_ctx, <span class="stringliteral">&quot;(int)-&gt;int&quot;</span>, (<span class="keywordtype">void</span>*)multiply_handler, NULL, NULL);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* harness_trampoline = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;harness_trampoline, <span class="stringliteral">&quot;(*((int)-&gt;int), int) -&gt; int&quot;</span>, (<span class="keywordtype">void</span>*)harness_func, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* inner_cb_ptr = <a class="code hl_function" href="group__introspection__api.html#ga3b75e8481ac13d11faa15046fc4adb66">infix_reverse_get_code</a>(inner_cb_ctx);</div>
<div class="line">    <span class="keywordtype">int</span> value = 7;</div>
<div class="line">    <span class="keywordtype">void</span>* harness_args[] = { &amp;inner_cb_ptr, &amp;value };</div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(harness_trampoline)(&amp;result, harness_args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Result from nested callback: %d\n&quot;</span>, result); <span class="comment">// Should be 70</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(harness_trampoline);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#ga00b101025663c423a28433e139be5d4e">infix_reverse_destroy</a>(inner_cb_ctx);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md63"></a>
Recipe: Calling a Function Pointer from a Struct (V-Table Emulation)</h2>
<p><b>Problem</b>: You have a pointer to a struct that contains function pointers, similar to a C implementation of an object's v-table. You need to read a function pointer from the struct and then call it. <b>Solution</b>: This is a two-step FFI process. First, read the function pointer value from the struct. Second, create a new trampoline for that function pointer's signature and call it. The Type Registry is perfect for making this clean.</p>
<div class="fragment"><div class="line"><span class="comment">// C equivalent of a simple &quot;object&quot; with a v-table.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">int</span> val; } Adder;</div>
<div class="line"><span class="keywordtype">int</span> vtable_add(Adder* self, <span class="keywordtype">int</span> amount) { <span class="keywordflow">return</span> self-&gt;val + amount; }</div>
<div class="line"><span class="keywordtype">void</span> vtable_destroy(Adder* self) { free(self); }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    int (*add)(Adder* self, <span class="keywordtype">int</span> amount);</div>
<div class="line">    void (*destroy)(Adder* self);</div>
<div class="line">} AdderVTable;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> AdderVTable VTABLE = { vtable_add, vtable_destroy };</div>
<div class="line">Adder* create_adder(<span class="keywordtype">int</span> base) {</div>
<div class="line">    Adder* a = malloc(<span class="keyword">sizeof</span>(Adder));</div>
<div class="line">    a-&gt;val = base;</div>
<div class="line">    <span class="keywordflow">return</span> a;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_vtable_call() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__registry__t.html">infix_registry_t</a>* reg = <a class="code hl_function" href="group__registry__api.html#gac808273483db7a9db2bc275c41b13296">infix_registry_create</a>();</div>
<div class="line">    <a class="code hl_function" href="group__registry__api.html#ga4ece2363948c40fe528826bf65dac280">infix_register_types</a>(reg,</div>
<div class="line">        <span class="stringliteral">&quot;@Adder = { val: int };&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;@Adder_add_fn = (*@Adder, int) -&gt; int;&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;@AdderVTable = { add: *@Adder_add_fn };&quot;</span> <span class="comment">// Only need to describe the one we&#39;re calling</span></div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    Adder* my_adder = create_adder(100);</div>
<div class="line">    <span class="keyword">const</span> AdderVTable* vtable = &amp;VTABLE;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* add_func_ptr = (<span class="keywordtype">void</span>*)vtable-&gt;add;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t_add = NULL;</div>
<div class="line">    <span class="comment">// Note: The signature here must match the member we are calling.</span></div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t_add, <span class="stringliteral">&quot;(*@Adder, int) -&gt; int&quot;</span>, add_func_ptr, reg);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> amount_to_add = 23;</div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line">    <span class="keywordtype">void</span>* add_args[] = { &amp;my_adder, &amp;amount_to_add };</div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t_add)(&amp;result, add_args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Result from v-table call: %d\n&quot;</span>, result); <span class="comment">// Expected: 123</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t_add);</div>
<div class="line">    <a class="code hl_function" href="group__registry__api.html#ga4c3b0c1f77732fc2f8aa0a8de62f8a1a">infix_registry_destroy</a>(reg);</div>
<div class="line">    free(my_adder);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md64"></a>
&lt;strong&gt;Recipe: Handling &lt;tt&gt;long double&lt;/tt&gt;&lt;/strong&gt;</h2>
<p><b>Problem</b>: You need to call a function that uses <code>long double</code>, which has different sizes and ABI rules on different platforms (e.g., 80-bit on x86, 128-bit on AArch64, or just an alias for <code>double</code> on MSVC/macOS). <b>Solution</b>: Use the <code>long double</code> keyword in your signature. <code>infix</code>'s ABI logic contains the platform-specific rules to handle it correctly, whether it's passed on the x87 FPU stack (System V x64), in a 128-bit vector register (AArch64), or as a normal <code>double</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A simple function using long double.</span></div>
<div class="line"><span class="keywordtype">long</span> <span class="keywordtype">double</span> native_sqrtl(<span class="keywordtype">long</span> <span class="keywordtype">double</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> sqrtl(x);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_long_double() {</div>
<div class="line">    <span class="comment">// On platforms where long double is distinct (like Linux), this will</span></div>
<div class="line">    <span class="comment">// trigger special ABI handling. On platforms where it&#39;s an alias for</span></div>
<div class="line">    <span class="comment">// double (like Windows), infix will treat it as a double.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;(long double) -&gt; long double&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)native_sqrtl, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">double</span> input = 144.0L;</div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">double</span> result = 0.0L;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;input };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;sqrtl(144.0L) = %Lf\n&quot;</span>, result); <span class="comment">// Expected: 12.0</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
Recipe: Proving Reentrancy with Nested FFI Calls</h2>
<p><b>Problem</b>: You need to be sure that making an FFI call from within an FFI callback is safe. <b>Solution</b>: <code>infix</code> is designed to be fully reentrant. The library uses no global mutable state, and all error information is stored in thread-local storage. This recipe demonstrates a forward call that invokes a reverse callback, which in turn makes another forward call.</p>
<div class="fragment"><div class="line"><span class="comment">// Innermost target function</span></div>
<div class="line"><span class="keywordtype">int</span> multiply(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a * b; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The callback handler that will make the nested forward call</span></div>
<div class="line"><span class="keywordtype">int</span> nested_call_handler(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a>* ctx, <span class="keywordtype">int</span> val) {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* fwd_trampoline = (<a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>*)<a class="code hl_function" href="group__introspection__api.html#gab41c717a6e4e4198c62284e526e5d9b3">infix_reverse_get_user_data</a>(ctx);</div>
<div class="line">    <span class="keywordtype">int</span> multiplier = 5;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;val, &amp;multiplier };</div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(fwd_trampoline)(&amp;result, args);</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The outer C function that takes our callback</span></div>
<div class="line"><span class="keywordtype">int</span> harness(<span class="keywordtype">int</span> (*func)(<span class="keywordtype">int</span>), <span class="keywordtype">int</span> input) {</div>
<div class="line">    <span class="keywordflow">return</span> func(input);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_reentrancy() {</div>
<div class="line">    <span class="comment">// 1. Create the innermost forward trampoline (for `multiply`)</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* fwd_multiply = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;fwd_multiply, <span class="stringliteral">&quot;(int, int)-&gt;int&quot;</span>, (<span class="keywordtype">void</span>*)multiply, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Create the reverse trampoline (callback), passing the forward trampoline as user_data</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a>* rev_nested = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga7d09d07b70706cb1a949e2efd5f5f471">infix_reverse_create</a>(&amp;rev_nested, <span class="stringliteral">&quot;(int)-&gt;int&quot;</span>, (<span class="keywordtype">void</span>*)nested_call_handler, fwd_multiply, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Create the outermost forward trampoline (for `harness`)</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* fwd_harness = NULL;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* harness_sig = <span class="stringliteral">&quot;(*((int)-&gt;int), int)-&gt;int&quot;</span>;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;fwd_harness, harness_sig, (<span class="keywordtype">void</span>*)harness, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Execute the call chain</span></div>
<div class="line">    <span class="keywordtype">void</span>* callback_ptr = <a class="code hl_function" href="group__introspection__api.html#ga3b75e8481ac13d11faa15046fc4adb66">infix_reverse_get_code</a>(rev_nested);</div>
<div class="line">    <span class="keywordtype">int</span> base_val = 8;</div>
<div class="line">    <span class="keywordtype">void</span>* harness_args[] = { &amp;callback_ptr, &amp;base_val };</div>
<div class="line">    <span class="keywordtype">int</span> final_result;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(fwd_harness)(&amp;final_result, harness_args);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Nested/reentrant call result: %d\n&quot;</span>, final_result); <span class="comment">// Expected: 8 * 5 = 40</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 5. Clean up all three trampolines</span></div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(fwd_harness);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#ga00b101025663c423a28433e139be5d4e">infix_reverse_destroy</a>(rev_nested);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(fwd_multiply);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
&lt;strong&gt;Recipe: Proving Thread Safety&lt;/strong&gt;</h2>
<p><b>Problem</b>: You need to create a trampoline in one thread and safely use it in another. <b>Solution</b>: <code>infix</code> trampoline handles (<code>infix_forward_t*</code> and <code>infix_reverse_t*</code>) are immutable after creation and are safe to share between threads. All error state is kept in thread-local storage, so calls from different threads will not interfere with each other.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line"><span class="preprocessor">#include &lt;windows.h&gt;</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#include &lt;pthread.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A simple function to be the FFI target.</span></div>
<div class="line"><span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A struct to pass data to our worker thread.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <a class="code hl_typedef" href="group__public__api.html#ga3042690c20cccd4137f134154bd62e1a">infix_cif_func</a> cif; <span class="comment">// The callable trampoline function pointer.</span></div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line">} thread_data_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The function our worker thread will execute.</span></div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line">DWORD WINAPI worker_thread_func(LPVOID arg) {</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="keywordtype">void</span>* worker_thread_func(<span class="keywordtype">void</span>* arg) {</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    thread_data_t* data = (thread_data_t*)arg;</div>
<div class="line">    <span class="keywordtype">int</span> a = 20, b = 22;</div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;a, &amp;b };</div>
<div class="line">    <span class="comment">// Call the trampoline function pointer that was created on the main thread.</span></div>
<div class="line">    data-&gt;cif(&amp;data-&gt;result, args);</div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_thread_safety() {</div>
<div class="line">    <span class="comment">// Main thread: Create the trampoline.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;trampoline, <span class="stringliteral">&quot;(int, int)-&gt;int&quot;</span>, (<span class="keywordtype">void</span>*)add, NULL);</div>
<div class="line"> </div>
<div class="line">    thread_data_t data = { <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(trampoline), 0 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Main thread: Spawn a worker thread, passing it the callable pointer.</span></div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line">    HANDLE thread_handle = CreateThread(NULL, 0, worker_thread_func, &amp;data, 0, NULL);</div>
<div class="line">    WaitForSingleObject(thread_handle, INFINITE);</div>
<div class="line">    CloseHandle(thread_handle);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    pthread_t thread_id;</div>
<div class="line">    pthread_create(&amp;thread_id, NULL, worker_thread_func, &amp;data);</div>
<div class="line">    pthread_join(thread_id, NULL);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Main thread: Check the result computed by the worker thread.</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;Result from worker thread: %d\n&quot;</span>, data.result); <span class="comment">// Expected: 42</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Main thread: Clean up the trampoline.</span></div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(trampoline);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md68"></a>
Chapter 5: Interoperability with Other Languages</h1>
<h2><a class="anchor" id="autotoc_md69"></a>
The Universal Principle: The C ABI</h2>
<p><code>infix</code> can call any function that exposes a standard C ABI. Nearly every compiled language provides a mechanism to export a function using this standard (<code>extern "C"</code> in C++/Rust/Zig, <code>//export</code> in Go, <code>bind(C)</code> in Fortran).</p>
<h2><a class="anchor" id="autotoc_md70"></a>
Recipe: Interfacing with a C++ Class (Directly)</h2>
<p><b>Problem</b>: You need to call C++ class methods without writing a C wrapper. <b>Solution</b>: Find the compiler-mangled names for the constructor, destructor, and methods. Use <code>infix</code> to call them directly, manually passing the <code>this</code> pointer as the first argument to methods.</p>
<div class="fragment"><div class="line"><span class="comment">// File: MyClass.cpp (compile to libmyclass.so/.dll)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="keyword">class </span>MyClass {</div>
<div class="line">    <span class="keywordtype">int</span> value;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClass(<span class="keywordtype">int</span> val) : value(val) { std::cout &lt;&lt; <span class="stringliteral">&quot;C++ Constructor called.\n&quot;</span>; }</div>
<div class="line">    ~MyClass() { std::cout &lt;&lt; <span class="stringliteral">&quot;C++ Destructor called.\n&quot;</span>; }</div>
<div class="line">    <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> this-&gt;value + x; }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">size_t</span> get_myclass_size() { <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(MyClass); }</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// File: main.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Mangled names depend on the compiler. Find them with `nm` or `dumpbin`.</span></div>
<div class="line"><span class="preprocessor">#if defined(__GNUC__) || defined(__clang__) </span><span class="comment">// Itanium ABI</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* MANGLED_CONSTRUCTOR = <span class="stringliteral">&quot;_ZN7MyClassC1Ei&quot;</span>; <span class="comment">// MyClass::MyClass(int)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* MANGLED_DESTRUCTOR = <span class="stringliteral">&quot;_ZN7MyClassD1Ev&quot;</span>;  <span class="comment">// MyClass::~MyClass()</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* MANGLED_ADD = <span class="stringliteral">&quot;_ZN7MyClass3addEi&quot;</span>;      <span class="comment">// MyClass::add(int)</span></div>
<div class="line"><span class="preprocessor">#elif defined(_MSC_VER) </span><span class="comment">// MSVC ABI</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* MANGLED_CONSTRUCTOR = <span class="stringliteral">&quot;??0MyClass@@QEAA@H@Z&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* MANGLED_DESTRUCTOR = <span class="stringliteral">&quot;??1MyClass@@QEAA@XZ&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* MANGLED_ADD = <span class="stringliteral">&quot;?add@MyClass@@QEAAHH@Z&quot;</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_cpp_mangled() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__library__t.html">infix_library_t</a>* lib = <a class="code hl_function" href="loader_8c.html#ac583cdbec7dfe1532917a7fbd849cba6">infix_library_open</a>(<span class="stringliteral">&quot;libmyclass.so&quot;</span>); <span class="comment">// or .dll</span></div>
<div class="line">    <span class="keywordflow">if</span> (!lib) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* p_ctor = <a class="code hl_function" href="loader_8c.html#a85a7867032b8bc17593d8ec8628f299e">infix_library_get_symbol</a>(lib, MANGLED_CONSTRUCTOR);</div>
<div class="line">    <span class="keywordtype">void</span>* p_dtor = <a class="code hl_function" href="loader_8c.html#a85a7867032b8bc17593d8ec8628f299e">infix_library_get_symbol</a>(lib, MANGLED_DESTRUCTOR);</div>
<div class="line">    <span class="keywordtype">void</span>* p_add = <a class="code hl_function" href="loader_8c.html#a85a7867032b8bc17593d8ec8628f299e">infix_library_get_symbol</a>(lib, MANGLED_ADD);</div>
<div class="line">    size_t (*p_size)() = <a class="code hl_function" href="loader_8c.html#a85a7867032b8bc17593d8ec8628f299e">infix_library_get_symbol</a>(lib, <span class="stringliteral">&quot;get_myclass_size&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!p_ctor || !p_dtor || !p_add || !p_size) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to find one or more symbols.\n&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(lib);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a> *t_ctor, *t_dtor, *t_add;</div>
<div class="line">    <span class="comment">// Constructor is effectively: void __thiscall(void* this, int val)</span></div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t_ctor, <span class="stringliteral">&quot;(*void, int)-&gt;void&quot;</span>, p_ctor, NULL);</div>
<div class="line">    <span class="comment">// Destructor is: void __thiscall(void* this)</span></div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t_dtor, <span class="stringliteral">&quot;(*void)-&gt;void&quot;</span>, p_dtor, NULL);</div>
<div class="line">    <span class="comment">// Method is: int __thiscall(void* this, int x)</span></div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t_add, <span class="stringliteral">&quot;(*void, int)-&gt;int&quot;</span>, p_add, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Simulate `MyClass* obj = new MyClass(100);` ---</span></div>
<div class="line">    <span class="keywordtype">void</span>* obj = malloc(p_size());</div>
<div class="line">    <span class="keywordtype">int</span> initial_val = 100;</div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t_ctor)(NULL, (<span class="keywordtype">void</span>*[]){ &amp;obj, &amp;initial_val });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Simulate `int result = obj-&gt;add(23);` ---</span></div>
<div class="line">    <span class="keywordtype">int</span> add_val = 23, result;</div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t_add)(&amp;result, (<span class="keywordtype">void</span>*[]){ &amp;obj, &amp;add_val });</div>
<div class="line">    printf(<span class="stringliteral">&quot;C++ mangled method returned: %d\n&quot;</span>, result); <span class="comment">// Should be 123</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// --- Simulate `delete obj;` ---</span></div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t_dtor)(NULL, (<span class="keywordtype">void</span>*[]){ &amp;obj });</div>
<div class="line">    free(obj);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(lib);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t_ctor);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t_dtor);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t_add);</div>
<div class="line">}</div>
<div class="ttc" id="aloader_8c_html_a85a7867032b8bc17593d8ec8628f299e"><div class="ttname"><a href="loader_8c.html#a85a7867032b8bc17593d8ec8628f299e">infix_library_get_symbol</a></div><div class="ttdeci">c23_nodiscard void * infix_library_get_symbol(infix_library_t *lib, const char *symbol_name)</div><div class="ttdef"><b>Definition</b> loader.c:144</div></div>
<div class="ttc" id="aloader_8c_html_aa8a13683c23c32d08b281075f0321d6b"><div class="ttname"><a href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a></div><div class="ttdeci">void infix_library_close(infix_library_t *lib)</div><div class="ttdef"><b>Definition</b> loader.c:113</div></div>
<div class="ttc" id="aloader_8c_html_ac583cdbec7dfe1532917a7fbd849cba6"><div class="ttname"><a href="loader_8c.html#ac583cdbec7dfe1532917a7fbd849cba6">infix_library_open</a></div><div class="ttdeci">c23_nodiscard infix_library_t * infix_library_open(const char *path)</div><div class="ttdef"><b>Definition</b> loader.c:65</div></div>
<div class="ttc" id="astructinfix__library__t_html"><div class="ttname"><a href="structinfix__library__t.html">infix_library_t</a></div><div class="ttdef"><b>Definition</b> loader.c:49</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md71"></a>
Recipe: Interfacing with C++ Templates</h2>
<p><b>Problem</b>: How do you call a C++ function template from C? <b>Solution</b>: You can't call the template itself, but you can call a <em>specific instantiation</em> of it. The compiler generates a normal function for each concrete type used with the template, and this function has a predictable mangled name that you can look up and call.</p>
<div class="fragment"><div class="line"><span class="comment">// File: Box.cpp (compile to libbox.so/.dll)</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>Box {</div>
<div class="line">    T value;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Box(T val) : value(val) {}</div>
<div class="line">    T get_value() { <span class="keywordflow">return</span> this-&gt;value; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We need to explicitly instantiate the templates we want to use</span></div>
<div class="line"><span class="comment">// so the compiler generates code for them.</span></div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>Box&lt;int&gt;;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>Box&lt;double&gt;;</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// File: main.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Mangled name for `Box&lt;double&gt;::get_value()` on GCC/Clang</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* MANGLED_GET_DBL = <span class="stringliteral">&quot;_ZNK3BoxIdE9get_valueEv&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_cpp_template() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__library__t.html">infix_library_t</a>* lib = <a class="code hl_function" href="loader_8c.html#ac583cdbec7dfe1532917a7fbd849cba6">infix_library_open</a>(<span class="stringliteral">&quot;libbox.so&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!lib) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Manually create a Box&lt;double&gt; for this example.</span></div>
<div class="line">    <span class="keywordtype">double</span> val = 3.14;</div>
<div class="line">    <span class="keywordtype">void</span>* my_box = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line">    memcpy(my_box, &amp;val, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* p_get_value = <a class="code hl_function" href="loader_8c.html#a85a7867032b8bc17593d8ec8628f299e">infix_library_get_symbol</a>(lib, MANGLED_GET_DBL);</div>
<div class="line">    <span class="keywordflow">if</span> (!p_get_value) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to find mangled template function.\n&quot;</span>);</div>
<div class="line">        free(my_box);</div>
<div class="line">        <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(lib);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t_get = NULL;</div>
<div class="line">    <span class="comment">// Signature: double get_value(Box&lt;double&gt;* this)</span></div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t_get, <span class="stringliteral">&quot;(*void) -&gt; double&quot;</span>, p_get_value, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> result;</div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t_get)(&amp;result, (<span class="keywordtype">void</span>*[]){ &amp;my_box });</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Value from C++ template object: %f\n&quot;</span>, result); <span class="comment">// Should be 3.14</span></div>
<div class="line"> </div>
<div class="line">    free(my_box);</div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t_get);</div>
<div class="line">    <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(lib);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md72"></a>
The Pattern for Other Compiled Languages</h2>
<p>The <code>extern "C"</code> pattern is universal. The C code to call any of the functions below would be identical: load the library, find the symbol, create a trampoline for <code>(int, int) -&gt; int</code>, and call it.</p>
<h3><a class="anchor" id="autotoc_md73"></a>
Rust</h3>
<p>To export a C-compatible function from Rust, use <code>#[no_mangle]</code> to prevent name mangling and <code>extern "C"</code> to specify the calling convention.</p>
<div class="fragment"><div class="line">// librust_math.rs</div>
<div class="line">#[no_mangle]</div>
<div class="line">pub extern &quot;C&quot; fn rust_add(a: i32, b: i32) -&gt; i32 {</div>
<div class="line">    a + b</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>Compile with: <code>rustc --crate-type cdylib librust_math.rs</code></em></p>
<h3><a class="anchor" id="autotoc_md74"></a>
Zig</h3>
<p>Zig's <code>export</code> keyword makes a function available with the C ABI by default.</p>
<div class="fragment"><div class="line">// libzig_math.zig</div>
<div class="line">export fn zig_add(a: c_int, b: c_int) c_int {</div>
<div class="line">    return a + b;</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>Compile with: <code>zig build-lib -dynamic libzig_math.zig</code></em></p>
<h3><a class="anchor" id="autotoc_md75"></a>
Go</h3>
<p>Go can export functions to C using a special <code>//export</code> comment directive.</p>
<div class="fragment"><div class="line">// libgo_math.go</div>
<div class="line">package main</div>
<div class="line">import &quot;C&quot;</div>
<div class="line"> </div>
<div class="line">//export go_add</div>
<div class="line">func go_add(a C.int, b C.int) C.int { return a + b }</div>
<div class="line">func main() {}</div>
</div><!-- fragment --><p><em>Compile with: <code>go build -buildmode=c-shared -o libgo_math.so libgo_math.go</code></em></p>
<h3><a class="anchor" id="autotoc_md76"></a>
Swift</h3>
<p>The <code>@_cdecl</code> attribute exposes a Swift function to C with a specified name.</p>
<div class="fragment"><div class="line">// libswift_math.swift</div>
<div class="line">@_cdecl(&quot;swift_add&quot;)</div>
<div class="line">public func swift_add(a: CInt, b: CInt) -&gt; CInt {</div>
<div class="line">    return a + b</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>Compile with: <code>swiftc -emit-library libswift_math.swift -o libswift_math.so</code></em></p>
<h3><a class="anchor" id="autotoc_md77"></a>
Dlang</h3>
<p>The <code>extern(C)</code> attribute specifies the C calling convention for a D function.</p>
<div class="fragment"><div class="line"><span class="comment">// libd_math.d</span></div>
<div class="line"><span class="keyword">extern</span> (C) <span class="keywordtype">int</span> d_add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; }</div>
</div><!-- fragment --><p><em>Compile with: <code>dmd -shared -fPIC -of=libd_math.so libd_math.d</code></em></p>
<h3><a class="anchor" id="autotoc_md78"></a>
Fortran</h3>
<p>The <code>bind(C)</code> attribute from the <code>iso_c_binding</code> module provides C interoperability.</p>
<div class="fragment"><div class="line"><span class="comment">! libfortran_math.f90</span></div>
<div class="line"><span class="keyword">function </span>fortran_add(a, b) <span class="keyword">result</span>(c) bind(C, name=&#39;fortran_add&#39;)</div>
<div class="line">    <span class="keywordtype">use </span>iso_c_binding</div>
<div class="line">    <span class="keywordtype">integer(c_int)</span>, <span class="keywordtype">value</span> :: a, b</div>
<div class="line">    <span class="keywordtype">integer(c_int)</span> :: c</div>
<div class="line">    c = a + b</div>
<div class="line"><span class="keyword">end function </span>fortran_add</div>
</div><!-- fragment --><p><em>Compile with: <code>gfortran -shared -fPIC -o libfortran_math.so libfortran_math.f90</code></em></p>
<h3><a class="anchor" id="autotoc_md79"></a>
Assembly</h3>
<p>Pure machine code has no name mangling. You just need to follow the target ABI's calling convention.</p>
<div class="fragment"><div class="line">; libasm_math.asm (for System V x64 ABI)</div>
<div class="line">section .text</div>
<div class="line">global asm_add</div>
<div class="line">asm_add:</div>
<div class="line">    mov eax, edi ; Move first argument (RDI) into EAX</div>
<div class="line">    add eax, esi ; Add second argument (RSI) to EAX</div>
<div class="line">    ret          ; Return value is in EAX</div>
</div><!-- fragment --><p><em>Compile with: <code>nasm -f elf64 libasm_math.asm &amp;&amp; gcc -shared -o libasm_math.so libasm_math.o</code></em></p>
<h1><a class="anchor" id="autotoc_md80"></a>
Chapter 6: Dynamic Libraries &amp; System Calls</h1>
<h2><a class="anchor" id="autotoc_md81"></a>
Recipe: Calling Native System Libraries without Linking</h2>
<p><b>Problem</b>: You need to call a function from a system library (e.g., <code>user32.dll</code>) without linking against its import library at compile time.</p>
<p><b>Solution</b>: Use <code>infix</code>'s cross-platform library loading API to get a handle to the library and the function pointer, then create a trampoline.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line"><span class="preprocessor">#include &lt;windows.h&gt;</span> <span class="comment">// For UINT</span></div>
<div class="line"><span class="keywordtype">void</span> recipe_system_call() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__library__t.html">infix_library_t</a>* user32 = <a class="code hl_function" href="loader_8c.html#ac583cdbec7dfe1532917a7fbd849cba6">infix_library_open</a>(<span class="stringliteral">&quot;user32.dll&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!user32) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to open user32.dll\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* pMessageBoxA = <a class="code hl_function" href="loader_8c.html#a85a7867032b8bc17593d8ec8628f299e">infix_library_get_symbol</a>(user32, <span class="stringliteral">&quot;MessageBoxA&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!pMessageBoxA) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to find MessageBoxA\n&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(user32);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);</span></div>
<div class="line">    <span class="comment">// Note: HWND is a pointer, LPCSTR is *char, UINT is uint32.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* sig = <span class="stringliteral">&quot;(*void, *char, *char, uint32) -&gt; int&quot;</span>;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, sig, pMessageBoxA, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* hwnd = NULL;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* text = <span class="stringliteral">&quot;Hello from a dynamically loaded function!&quot;</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* caption = <span class="stringliteral">&quot;infix FFI&quot;</span>;</div>
<div class="line">    uint32_t type = 0; <span class="comment">// MB_OK</span></div>
<div class="line">    <span class="keywordtype">void</span>* args[] = { &amp;hwnd, &amp;text, &amp;caption, &amp;type };</div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, args);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">    <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(user32);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="comment">// Dummy implementation for non-Windows platforms to allow compilation.</span></div>
<div class="line"><span class="keywordtype">void</span> recipe_system_call() {</div>
<div class="line">    printf(<span class="stringliteral">&quot;This recipe is for Windows only.\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md82"></a>
Recipe: Reading and Writing Global Variables</h2>
<p><b>Problem</b>: You need to access a global variable exported from a shared library, not just a function.</p>
<p><b>Solution</b>: Use <code><a class="el" href="group__exports__api.html#gae75c91d8011786875c73f26d2aa437a8" title="Reads the value of a global variable from a loaded library.">infix_read_global()</a></code> and <code><a class="el" href="group__exports__api.html#ga3df4f2e6494af3e1fda98cd5a61d167f" title="Writes a value to a global variable in a loaded library.">infix_write_global()</a></code>. The powerful signature language is used to describe the variable's type, ensuring <code>infix</code> reads or writes the correct number of bytes.</p>
<h3><a class="anchor" id="autotoc_md83"></a>
Example 1: Simple Integer Variable</h3>
<p>First, create a simple shared library (<code>libglobals.c</code>) that exports a counter: </p><div class="fragment"><div class="line"><span class="comment">// libglobals.c - Compile to a shared library</span></div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line"><span class="preprocessor">#define EXPORT __declspec(dllexport)</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#define EXPORT</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">EXPORT <span class="keywordtype">int</span> global_counter = 42;</div>
</div><!-- fragment --><p>Now, the C code to interact with it: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_global_int() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__library__t.html">infix_library_t</a>* lib = <a class="code hl_function" href="loader_8c.html#ac583cdbec7dfe1532917a7fbd849cba6">infix_library_open</a>(<span class="stringliteral">&quot;./libglobals.so&quot;</span>); <span class="comment">// or &quot;libglobals.dll&quot;</span></div>
<div class="line">    <span class="keywordflow">if</span> (!lib) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> counter_val = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. Read the initial value. The signature is simply the type of the variable.</span></div>
<div class="line">    <a class="code hl_function" href="group__exports__api.html#gae75c91d8011786875c73f26d2aa437a8">infix_read_global</a>(lib, <span class="stringliteral">&quot;global_counter&quot;</span>, <span class="stringliteral">&quot;int&quot;</span>, &amp;counter_val);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Initial value of global_counter: %d\n&quot;</span>, counter_val); <span class="comment">// Expected: 42</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Write a new value to the global variable.</span></div>
<div class="line">    <span class="keywordtype">int</span> new_val = 100;</div>
<div class="line">    <a class="code hl_function" href="group__exports__api.html#ga3df4f2e6494af3e1fda98cd5a61d167f">infix_write_global</a>(lib, <span class="stringliteral">&quot;global_counter&quot;</span>, <span class="stringliteral">&quot;int&quot;</span>, &amp;new_val);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Read the value again to confirm it was changed.</span></div>
<div class="line">    counter_val = 0; <span class="comment">// Reset our local variable</span></div>
<div class="line">    <a class="code hl_function" href="group__exports__api.html#gae75c91d8011786875c73f26d2aa437a8">infix_read_global</a>(lib, <span class="stringliteral">&quot;global_counter&quot;</span>, <span class="stringliteral">&quot;int&quot;</span>, &amp;counter_val);</div>
<div class="line">    printf(<span class="stringliteral">&quot;New value of global_counter: %d\n&quot;</span>, counter_val); <span class="comment">// Expected: 100</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(lib);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__exports__api_html_ga3df4f2e6494af3e1fda98cd5a61d167f"><div class="ttname"><a href="group__exports__api.html#ga3df4f2e6494af3e1fda98cd5a61d167f">infix_write_global</a></div><div class="ttdeci">infix_status infix_write_global(infix_library_t *, const char *, const char *, void *)</div><div class="ttdoc">Writes a value to a global variable in a loaded library.</div><div class="ttdef"><b>Definition</b> loader.c:213</div></div>
<div class="ttc" id="agroup__exports__api_html_gae75c91d8011786875c73f26d2aa437a8"><div class="ttname"><a href="group__exports__api.html#gae75c91d8011786875c73f26d2aa437a8">infix_read_global</a></div><div class="ttdeci">infix_status infix_read_global(infix_library_t *, const char *, const char *, void *)</div><div class="ttdoc">Reads the value of a global variable from a loaded library.</div><div class="ttdef"><b>Definition</b> loader.c:170</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md84"></a>
Example 2: Aggregate (Struct) Variable</h3>
<p>Let's expand <code>libglobals.c</code> to export a configuration struct: </p><div class="fragment"><div class="line"><span class="comment">// Add to libglobals.c</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* name;</div>
<div class="line">    <span class="keywordtype">int</span> version;</div>
<div class="line">} Config;</div>
<div class="line"> </div>
<div class="line">EXPORT Config g_config = { <span class="stringliteral">&quot;default&quot;</span>, 1 };</div>
</div><!-- fragment --><p>Now, the C code to read and write this struct: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span>* name; <span class="keywordtype">int</span> version; } Config;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_global_struct() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__library__t.html">infix_library_t</a>* lib = <a class="code hl_function" href="loader_8c.html#ac583cdbec7dfe1532917a7fbd849cba6">infix_library_open</a>(<span class="stringliteral">&quot;./libglobals.so&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!lib) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// It&#39;s good practice to use the registry for structs.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__registry__t.html">infix_registry_t</a>* reg = <a class="code hl_function" href="group__registry__api.html#gac808273483db7a9db2bc275c41b13296">infix_registry_create</a>();</div>
<div class="line">    <a class="code hl_function" href="group__registry__api.html#ga4ece2363948c40fe528826bf65dac280">infix_register_types</a>(reg, <span class="stringliteral">&quot;@Config = {*char, int};&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    Config local_config;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. Read the global struct into our local variable.</span></div>
<div class="line">    <a class="code hl_function" href="group__exports__api.html#gae75c91d8011786875c73f26d2aa437a8">infix_read_global</a>(lib, <span class="stringliteral">&quot;g_config&quot;</span>, <span class="stringliteral">&quot;@Config&quot;</span>, &amp;local_config);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Initial config: name=&#39;%s&#39;, version=%d\n&quot;</span>, local_config.name, local_config.version);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Modify and write the struct back to the library.</span></div>
<div class="line">    Config new_config = { <span class="stringliteral">&quot;updated&quot;</span>, 2 };</div>
<div class="line">    <a class="code hl_function" href="group__exports__api.html#ga3df4f2e6494af3e1fda98cd5a61d167f">infix_write_global</a>(lib, <span class="stringliteral">&quot;g_config&quot;</span>, <span class="stringliteral">&quot;@Config&quot;</span>, &amp;new_config);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Read it back to verify the change.</span></div>
<div class="line">    memset(&amp;local_config, 0, <span class="keyword">sizeof</span>(Config));</div>
<div class="line">    <a class="code hl_function" href="group__exports__api.html#gae75c91d8011786875c73f26d2aa437a8">infix_read_global</a>(lib, <span class="stringliteral">&quot;g_config&quot;</span>, <span class="stringliteral">&quot;@Config&quot;</span>, &amp;local_config);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Updated config: name=&#39;%s&#39;, version=%d\n&quot;</span>, local_config.name, local_config.version);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__registry__api.html#ga4c3b0c1f77732fc2f8aa0a8de62f8a1a">infix_registry_destroy</a>(reg);</div>
<div class="line">    <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(lib);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md85"></a>
Recipe: Handling Library Dependencies</h2>
<p><b>Problem:</b> You want to load a library (<code>libA</code>) that itself depends on another shared library (<code>libB</code>). <b>Solution:</b> You don't have to do anything special. On all modern operating systems, the dynamic linker will automatically find, load, and link <code>libB</code> when you load <code>libA</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// libB.c -&gt; provides a helper function</span></div>
<div class="line"><span class="keywordtype">int</span> helper_from_lib_b() { <span class="keywordflow">return</span> 100; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// libA.c -&gt; depends on libB</span></div>
<div class="line"><span class="keywordtype">int</span> helper_from_lib_b();</div>
<div class="line"><span class="keywordtype">int</span> entry_point_a() { <span class="keywordflow">return</span> 200 + helper_from_lib_b(); }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// How to compile:</span></div>
<div class="line"><span class="comment">// gcc -shared -fPIC -o libB.so libB.c</span></div>
<div class="line"><span class="comment">// gcc -shared -fPIC -o libA.so libA.c -L. -lB // Link libA against libB</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_library_dependencies() {</div>
<div class="line">    <span class="comment">// We only need to open libA. The OS will handle loading libB.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__library__t.html">infix_library_t</a>* lib = <a class="code hl_function" href="loader_8c.html#ac583cdbec7dfe1532917a7fbd849cba6">infix_library_open</a>(<span class="stringliteral">&quot;./libA.so&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!lib) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* p_entry = <a class="code hl_function" href="loader_8c.html#a85a7867032b8bc17593d8ec8628f299e">infix_library_get_symbol</a>(lib, <span class="stringliteral">&quot;entry_point_a&quot;</span>);</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, <span class="stringliteral">&quot;()-&gt;int&quot;</span>, p_entry, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line">    <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;result, NULL);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Result from chained libraries: %d\n&quot;</span>, result); <span class="comment">// Should be 300</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
<div class="line">    <a class="code hl_function" href="loader_8c.html#aa8a13683c23c32d08b281075f0321d6b">infix_library_close</a>(lib);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md87"></a>
Chapter 7: Introspection for Data Marshalling</h1>
<h2><a class="anchor" id="autotoc_md88"></a>
Recipe: Dynamic Struct Marshalling with the Signature Parser</h2>
<p><b>Problem</b>: You have data from a dynamic source (like a script) and need to pack it into a C <code>struct</code> layout at runtime. <b>Solution</b>: Use <code>infix_type_from_signature</code> to parse a signature into a detailed <code>infix_type</code> graph. This graph contains all the <code>size</code>, <code>alignment</code>, and member <code>offset</code> information needed to correctly write data into a C-compatible memory buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ int32_t user_id; <span class="keywordtype">double</span> score; <span class="keyword">const</span> <span class="keywordtype">char</span>* name; } UserProfile;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> marshal_ordered_data(<span class="keywordtype">void</span>* dest, <span class="keyword">const</span> <span class="keywordtype">char</span>* sig, <span class="keywordtype">void</span>** src) {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__type__t.html">infix_type</a>* type = NULL;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__arena__t.html">infix_arena_t</a>* arena = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__high__level__api.html#ga3632147d55b80e520987d37722ddcf61">infix_type_from_signature</a>(&amp;type, &amp;arena, sig, NULL) != <a class="code hl_enumvalue" href="group__public__api.html#gga8643667be6ea1ef9269c2e46d8f11ff7ae50c34a24362f9364b4b20ef29d259da">INFIX_SUCCESS</a>) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code hl_function" href="group__introspection__api.html#ga678390feeed80a43111725c4e73c0dda">infix_type_get_member_count</a>(type); ++i) {</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_struct" href="structinfix__struct__member__t.html">infix_struct_member</a>* member = <a class="code hl_function" href="group__introspection__api.html#gafc256d548bfd78ff90ee38a1cc0ae8b9">infix_type_get_member</a>(type, i);</div>
<div class="line">        memcpy((<span class="keywordtype">char</span>*)dest + member-&gt;<a class="code hl_variable" href="structinfix__struct__member__t.html#abc9fb3780626694111f4c8c74700a9b9">offset</a>, src[i], <a class="code hl_function" href="group__introspection__api.html#ga0e49d4bdbfe42b661bf7bcb597793e9a">infix_type_get_size</a>(member-&gt;<a class="code hl_variable" href="structinfix__struct__member__t.html#aa89e6621da98f5115dcc807599c4ac77">type</a>));</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_function" href="group__memory__management.html#ga50b7219c58789fc03898690254f0280e">infix_arena_destroy</a>(arena);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_dynamic_packing() {</div>
<div class="line">    int32_t <span class="keywordtype">id</span> = 123;</div>
<div class="line">    <span class="keywordtype">double</span> score = 98.6;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* name = <span class="stringliteral">&quot;Sanko&quot;</span>;</div>
<div class="line">    <span class="keywordtype">void</span>* my_data[] = { &amp;id, &amp;score, &amp;name };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* profile_sig = <span class="stringliteral">&quot;{id:int32, score:double, name:*char}&quot;</span>;</div>
<div class="line">    UserProfile profile_buffer = {0};</div>
<div class="line"> </div>
<div class="line">    marshal_ordered_data(&amp;profile_buffer, profile_sig, my_data);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Resulting C struct: id=%d, score=%.1f, name=%s\n&quot;</span>,</div>
<div class="line">           profile_buffer.user_id, profile_buffer.score, profile_buffer.name);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__high__level__api_html_ga3632147d55b80e520987d37722ddcf61"><div class="ttname"><a href="group__high__level__api.html#ga3632147d55b80e520987d37722ddcf61">infix_type_from_signature</a></div><div class="ttdeci">c23_nodiscard infix_status infix_type_from_signature(infix_type **, infix_arena_t **, const char *, infix_registry_t *)</div><div class="ttdoc">Parses a signature string representing a single data type.</div><div class="ttdef"><b>Definition</b> signature.c:1090</div></div>
<div class="ttc" id="agroup__introspection__api_html_ga0e49d4bdbfe42b661bf7bcb597793e9a"><div class="ttname"><a href="group__introspection__api.html#ga0e49d4bdbfe42b661bf7bcb597793e9a">infix_type_get_size</a></div><div class="ttdeci">c23_nodiscard size_t infix_type_get_size(const infix_type *)</div><div class="ttdoc">Retrieves the size of an infix_type in bytes.</div><div class="ttdef"><b>Definition</b> types.c:729</div></div>
<div class="ttc" id="agroup__introspection__api_html_ga678390feeed80a43111725c4e73c0dda"><div class="ttname"><a href="group__introspection__api.html#ga678390feeed80a43111725c4e73c0dda">infix_type_get_member_count</a></div><div class="ttdeci">c23_nodiscard size_t infix_type_get_member_count(const infix_type *)</div><div class="ttdoc">Retrieves the number of members in an aggregate type (struct or union).</div><div class="ttdef"><b>Definition</b> types.c:746</div></div>
<div class="ttc" id="agroup__introspection__api_html_gafc256d548bfd78ff90ee38a1cc0ae8b9"><div class="ttname"><a href="group__introspection__api.html#gafc256d548bfd78ff90ee38a1cc0ae8b9">infix_type_get_member</a></div><div class="ttdeci">c23_nodiscard const infix_struct_member * infix_type_get_member(const infix_type *, size_t)</div><div class="ttdoc">Retrieves a specific member from an aggregate type by its index.</div><div class="ttdef"><b>Definition</b> types.c:757</div></div>
<div class="ttc" id="agroup__memory__management_html_ga50b7219c58789fc03898690254f0280e"><div class="ttname"><a href="group__memory__management.html#ga50b7219c58789fc03898690254f0280e">infix_arena_destroy</a></div><div class="ttdeci">void infix_arena_destroy(infix_arena_t *)</div><div class="ttdoc">Frees an entire memory arena and all objects allocated within it.</div><div class="ttdef"><b>Definition</b> arena.c:68</div></div>
<div class="ttc" id="agroup__public__api_html_gga8643667be6ea1ef9269c2e46d8f11ff7ae50c34a24362f9364b4b20ef29d259da"><div class="ttname"><a href="group__public__api.html#gga8643667be6ea1ef9269c2e46d8f11ff7ae50c34a24362f9364b4b20ef29d259da">INFIX_SUCCESS</a></div><div class="ttdeci">@ INFIX_SUCCESS</div><div class="ttdoc">The operation completed successfully.</div><div class="ttdef"><b>Definition</b> infix.h:360</div></div>
<div class="ttc" id="astructinfix__arena__t_html"><div class="ttname"><a href="structinfix__arena__t.html">infix_arena_t</a></div><div class="ttdef"><b>Definition</b> infix_internals.h:129</div></div>
<div class="ttc" id="astructinfix__struct__member__t_html"><div class="ttname"><a href="structinfix__struct__member__t.html">infix_struct_member_t</a></div><div class="ttdoc">Describes a single member of an aggregate type (struct or union).</div><div class="ttdef"><b>Definition</b> infix.h:219</div></div>
<div class="ttc" id="astructinfix__struct__member__t_html_aa89e6621da98f5115dcc807599c4ac77"><div class="ttname"><a href="structinfix__struct__member__t.html#aa89e6621da98f5115dcc807599c4ac77">infix_struct_member_t::type</a></div><div class="ttdeci">infix_type * type</div><div class="ttdoc">An infix_type describing the member's type.</div><div class="ttdef"><b>Definition</b> infix.h:221</div></div>
<div class="ttc" id="astructinfix__struct__member__t_html_abc9fb3780626694111f4c8c74700a9b9"><div class="ttname"><a href="structinfix__struct__member__t.html#abc9fb3780626694111f4c8c74700a9b9">infix_struct_member_t::offset</a></div><div class="ttdeci">size_t offset</div><div class="ttdoc">The byte offset of the member from the start of the aggregate.</div><div class="ttdef"><b>Definition</b> infix.h:222</div></div>
<div class="ttc" id="astructinfix__type__t_html"><div class="ttname"><a href="structinfix__type__t.html">infix_type_t</a></div><div class="ttdoc">The central structure for describing any data type in the FFI system.</div><div class="ttdef"><b>Definition</b> infix.h:161</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md89"></a>
Recipe: Building a Signature String at Runtime</h2>
<p><b>Problem</b>: The structure of the data you need to work with isn't known until runtime (e.g., it's defined in a configuration file or a user script). <b>Solution</b>: Since <code>infix</code> signatures are just strings, you can build them dynamically using <code>snprintf</code>. You can then parse this dynamic signature to get layout information, which is perfect for data marshalling or dynamic RPC systems.</p>
<div class="fragment"><div class="line"><span class="comment">// Imagine this data comes from a config file</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* user_defined_fields[] = { <span class="stringliteral">&quot;int&quot;</span>, <span class="stringliteral">&quot;int&quot;</span>, <span class="stringliteral">&quot;double&quot;</span> };</div>
<div class="line"><span class="keywordtype">int</span> num_fields = 3;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_dynamic_signature() {</div>
<div class="line">    <span class="keywordtype">char</span> signature_buffer = <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span>* current = signature_buffer + 1;</div>
<div class="line">    <span class="keywordtype">size_t</span> remaining = <span class="keyword">sizeof</span>(signature_buffer) - 1;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. Build the signature string dynamically.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_fields; ++i) {</div>
<div class="line">        <span class="keywordtype">int</span> written = snprintf(current, remaining, <span class="stringliteral">&quot;%s%s&quot;</span>, user_defined_fields[i], (i == num_fields - 1) ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;,&quot;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (written &lt; 0 || (<span class="keywordtype">size_t</span>)written &gt;= remaining) {</div>
<div class="line">            printf(<span class="stringliteral">&quot;Error: Signature buffer too small.\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        current += written;</div>
<div class="line">        remaining -= written;</div>
<div class="line">    }</div>
<div class="line">    strcat(signature_buffer, <span class="stringliteral">&quot;}&quot;</span>); <span class="comment">// Final string is &quot;{int,int,double}&quot;</span></div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Dynamically generated signature: %s\n&quot;</span>, signature_buffer);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Use the dynamic signature to get layout information.</span></div>
<div class="line">    <a class="code hl_struct" href="structinfix__type__t.html">infix_type</a>* dynamic_type = NULL;</div>
<div class="line">    <a class="code hl_struct" href="structinfix__arena__t.html">infix_arena_t</a>* arena = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga3632147d55b80e520987d37722ddcf61">infix_type_from_signature</a>(&amp;dynamic_type, &amp;arena, signature_buffer, NULL);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (dynamic_type) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Dynamic struct size: %zu bytes\n&quot;</span>, <a class="code hl_function" href="group__introspection__api.html#ga0e49d4bdbfe42b661bf7bcb597793e9a">infix_type_get_size</a>(dynamic_type));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__memory__management.html#ga50b7219c58789fc03898690254f0280e">infix_arena_destroy</a>(arena);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md90"></a>
Recipe: Introspecting a Trampoline for a Wrapper</h2>
<p><b>Problem</b>: You are building a language binding and need to validate the number and types of arguments provided by the user before making an FFI call. <b>Solution</b>: Use the trampoline introspection API to query the signature information stored in the handle.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> dynamic_wrapper(<a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline, <span class="keywordtype">void</span>* target_func, <span class="keywordtype">void</span>** args, <span class="keywordtype">size_t</span> num_provided_args) {</div>
<div class="line">    <span class="keywordflow">if</span> (num_provided_args != <a class="code hl_function" href="group__introspection__api.html#ga7b7e73aa032acb4185433f40720ec126">infix_forward_get_num_args</a>(trampoline)) {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Error: Incorrect number of arguments. Expected %zu, got %zu.\n&quot;</span>,</div>
<div class="line">                <a class="code hl_function" href="group__introspection__api.html#ga7b7e73aa032acb4185433f40720ec126">infix_forward_get_num_args</a>(trampoline), num_provided_args);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// A real binding would also check the types using infix_forward_get_arg_type().</span></div>
<div class="line">    ((<a class="code hl_typedef" href="group__public__api.html#ga48f7ee868576f525269902fc953887bd">infix_unbound_cif_func</a>)<a class="code hl_function" href="group__introspection__api.html#ga5f3559908e6a7bcc72103c52937d67ad">infix_forward_get_unbound_code</a>(trampoline))(target_func, NULL, args);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__introspection__api_html_ga7b7e73aa032acb4185433f40720ec126"><div class="ttname"><a href="group__introspection__api.html#ga7b7e73aa032acb4185433f40720ec126">infix_forward_get_num_args</a></div><div class="ttdeci">c23_nodiscard size_t infix_forward_get_num_args(const infix_forward_t *)</div><div class="ttdoc">Retrieves the number of arguments for a forward trampoline.</div><div class="ttdef"><b>Definition</b> types.c:794</div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md92"></a>
Chapter 8: Performance &amp; Memory Management</h1>
<h2><a class="anchor" id="autotoc_md93"></a>
Best Practice: Caching Trampolines</h2>
<p><b>Rule</b>: <b>NEVER</b> generate a new trampoline for the same function signature inside a hot loop. The performance of <code>infix</code> comes from amortizing the one-time generation cost over many fast calls.</p>
<div class="fragment"><div class="line"><span class="comment">// FAST: Create once, call many times</span></div>
<div class="line"><a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line"><a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, <span class="stringliteral">&quot;(int, int) -&gt; int&quot;</span>, my_func, NULL);</div>
<div class="line"><a class="code hl_typedef" href="group__public__api.html#ga3042690c20cccd4137f134154bd62e1a">infix_cif_func</a> cif = <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t);</div>
<div class="line"><span class="keywordtype">int</span> result;</div>
<div class="line"><span class="keywordtype">void</span>* args[] = { <span class="comment">/* ... */</span> };</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {</div>
<div class="line">    cif(&amp;result, args); <span class="comment">// VERY FAST</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md94"></a>
Recipe: Using a Custom Arena for a Group of Types</h2>
<p><b>Goal:</b> Create a set of related <code>infix_type</code> objects for the Manual API and free them all at once.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> recipe_custom_arena() {</div>
<div class="line">    <a class="code hl_struct" href="structinfix__arena__t.html">infix_arena_t</a>* arena = <a class="code hl_function" href="group__memory__management.html#gae39ca61ea3637aee7e87c1b41188c733">infix_arena_create</a>(8192);</div>
<div class="line">    <a class="code hl_struct" href="structinfix__type__t.html">infix_type</a>* int_type = <a class="code hl_function" href="group__type__system.html#gae323d599fbc081976a99a1e3b726a0b8">infix_type_create_primitive</a>(<a class="code hl_enumvalue" href="group__type__system.html#gga2cd7b00c1f2606249654a8e8b7cbc044a449724cf88949d38538312535be9ce6f">INFIX_PRIMITIVE_SINT32</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structinfix__type__t.html">infix_type</a>* int_array_type = NULL;</div>
<div class="line">    <a class="code hl_function" href="group__type__system.html#ga9f0d8a41015262d2dcffc97cf5f87772">infix_type_create_array</a>(arena, &amp;int_array_type, int_type, 100);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... use these types with `infix_forward_create_manual` ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// A single call to destroy the arena cleans up everything allocated from it.</span></div>
<div class="line">    <a class="code hl_function" href="group__memory__management.html#ga50b7219c58789fc03898690254f0280e">infix_arena_destroy</a>(arena);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__memory__management_html_gae39ca61ea3637aee7e87c1b41188c733"><div class="ttname"><a href="group__memory__management.html#gae39ca61ea3637aee7e87c1b41188c733">infix_arena_create</a></div><div class="ttdeci">c23_nodiscard infix_arena_t * infix_arena_create(size_t)</div><div class="ttdoc">Creates and initializes a new memory arena.</div><div class="ttdef"><b>Definition</b> arena.c:41</div></div>
<div class="ttc" id="agroup__type__system_html_ga9f0d8a41015262d2dcffc97cf5f87772"><div class="ttname"><a href="group__type__system.html#ga9f0d8a41015262d2dcffc97cf5f87772">infix_type_create_array</a></div><div class="ttdeci">c23_nodiscard infix_status infix_type_create_array(infix_arena_t *, infix_type **, infix_type *, size_t)</div><div class="ttdoc">Creates a new infix_type for a fixed-size array from an arena.</div><div class="ttdef"><b>Definition</b> types.c:256</div></div>
<div class="ttc" id="agroup__type__system_html_gae323d599fbc081976a99a1e3b726a0b8"><div class="ttname"><a href="group__type__system.html#gae323d599fbc081976a99a1e3b726a0b8">infix_type_create_primitive</a></div><div class="ttdeci">c23_nodiscard infix_type * infix_type_create_primitive(infix_primitive_type_id)</div><div class="ttdoc">Creates an infix_type descriptor for a primitive C type.</div><div class="ttdef"><b>Definition</b> types.c:99</div></div>
<div class="ttc" id="agroup__type__system_html_gga2cd7b00c1f2606249654a8e8b7cbc044a449724cf88949d38538312535be9ce6f"><div class="ttname"><a href="group__type__system.html#gga2cd7b00c1f2606249654a8e8b7cbc044a449724cf88949d38538312535be9ce6f">INFIX_PRIMITIVE_SINT32</a></div><div class="ttdeci">@ INFIX_PRIMITIVE_SINT32</div><div class="ttdoc">signed int, int32_t</div><div class="ttdef"><b>Definition</b> infix.h:140</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md95"></a>
&lt;strong&gt;Recipe: Using Custom Memory Allocators&lt;/strong&gt;</h2>
<p><b>Problem</b>: Your application uses a custom memory manager for tracking, pooling, or integration with a garbage collector. You need <code>infix</code> to use your allocators instead of the standard <code>malloc</code>, <code>calloc</code>, etc.</p>
<p><b>Solution</b>: <code>infix</code> provides override macros (<code>infix_malloc</code>, <code>infix_free</code>, etc.). Define these macros <em>before</em> you include <code><a class="el" href="infix_8h.html">infix.h</a></code> to redirect all of its internal memory operations.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Define your custom memory management functions.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">size_t</span> g_total_allocated = 0;</div>
<div class="line"><span class="keywordtype">void</span>* tracking_malloc(<span class="keywordtype">size_t</span> size) {</div>
<div class="line">    g_total_allocated += size;</div>
<div class="line">    printf(<span class="stringliteral">&quot;&gt;&gt; Custom Malloc: Allocating %zu bytes (Total: %zu)\n&quot;</span>, size, g_total_allocated);</div>
<div class="line">    <span class="keywordflow">return</span> malloc(size);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tracking_free(<span class="keywordtype">void</span>* ptr) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;&gt;&gt; Custom Free\n&quot;</span>);</div>
<div class="line">    free(ptr);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Define the infix override macros BEFORE including infix.h</span></div>
<div class="line"><span class="preprocessor">#define infix_malloc(size) tracking_malloc(size)</span></div>
<div class="line"><span class="preprocessor">#define infix_free(ptr)    tracking_free(ptr)</span></div>
<div class="line"><span class="comment">// You can also override infix_calloc and infix_realloc if needed.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> recipe_custom_allocators() {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Creating trampoline with custom allocators\n&quot;</span>);</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line">    <span class="comment">// All internal allocations for the trampoline will now use tracking_malloc.</span></div>
<div class="line">    <a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;trampoline, <span class="stringliteral">&quot;()-&gt;void&quot;</span>, (<span class="keywordtype">void</span>*)recipe_custom_allocators, NULL);</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;Destroying trampoline\n&quot;</span>);</div>
<div class="line">    <span class="comment">// The free operations will now use tracking_free.</span></div>
<div class="line">    <a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(trampoline);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Done\n&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md97"></a>
Chapter 9: Common Pitfalls &amp; Troubleshooting</h1>
<h2><a class="anchor" id="autotoc_md98"></a>
Mistake: Passing a Value Instead of a Pointer in &lt;tt&gt;args[]&lt;/tt&gt;</h2>
<ul>
<li><b>Symptom</b>: Crash or garbage data.</li>
<li><b>Explanation</b>: The <code>args</code> array for a forward call must be an array of <b>pointers to</b> your argument values, not the values themselves.</li>
</ul>
<h2><a class="anchor" id="autotoc_md99"></a>
Mistake: &lt;tt&gt;infix&lt;/tt&gt; Signature Mismatch</h2>
<ul>
<li><b>Symptom</b>: Silent data corruption, garbage values, or a crash.</li>
<li><b>Explanation</b>: The signature string must <em>exactly</em> match the C type's size and alignment. A <code>long</code> is 32 bits on 64-bit Windows but 64 bits on 64-bit Linux.</li>
<li><b>Solution</b>: Use fixed-width types (<code>int32</code>, <code>uint64</code>) whenever possible.</li>
</ul>
<h2><a class="anchor" id="autotoc_md100"></a>
Pitfall: Function Pointer Syntax</h2>
<ul>
<li><b>Symptom</b>: Parser error.</li>
<li><b>Explanation</b>: A function type is <code>(...) -&gt; ...</code>, and a pointer is <code>*...</code>. Therefore, a pointer to a function type is <code>*((...) -&gt; ...)</code>.</li>
<li><b>Solution</b>: <code>int (*callback)(void)</code> becomes <code>*(() -&gt; int)</code>.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md102"></a>
Chapter 10: A Comparative Look: &lt;tt&gt;infix&lt;/tt&gt; vs. &lt;tt&gt;libffi&lt;/tt&gt; and &lt;tt&gt;dyncall&lt;/tt&gt;</h1>
<p>This chapter provides a practical, code-level comparison of <code>infix</code> with two other popular FFI libraries: <code>libffi</code> (the industry standard) and <code>dyncall</code>. All three are powerful tools, but they are built with different philosophies and trade-offs. We will compare them across three common FFI tasks.</p>
<h2><a class="anchor" id="autotoc_md103"></a>
Scenario 1: Calling a Simple Function</h2>
<p><b>Goal</b>: Call a simple function <code>double add_doubles(double a, double b);</code>. This demonstrates the core calling mechanism and API ergonomics.</p>
<h3><a class="anchor" id="autotoc_md104"></a>
The &lt;tt&gt;dyncall&lt;/tt&gt; Approach</h3>
<p><code>dyncall</code> uses a "call virtual machine" (VM) where arguments are pushed one-by-one. The setup cost is incurred on <b>every call</b>, making it very flexible but less performant for repeated calls to the same function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;dyncall.h&gt;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">DCCallVM* vm = dcNewCallVM(4096);</div>
<div class="line"><span class="keywordtype">double</span> result;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Per-call setup and execution</span></div>
<div class="line">dcReset(vm);</div>
<div class="line">dcArgDouble(vm, 1.5);</div>
<div class="line">dcArgDouble(vm, 2.5);</div>
<div class="line">result = dcCallDouble(vm, (DCpointer)&amp;add_doubles); <span class="comment">// result is 4.0</span></div>
<div class="line"> </div>
<div class="line">dcFree(vm);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md105"></a>
The &lt;tt&gt;libffi&lt;/tt&gt; Approach</h3>
<p><code>libffi</code> requires a one-time "Call Interface" (<code>ffi_cif</code>) preparation. Subsequent calls are fast, but the initial type definition is manual and programmatic.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ffi.h&gt;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">ffi_cif cif;</div>
<div class="line">ffi_type* args_types[] = { &amp;ffi_type_double, &amp;ffi_type_double };</div>
<div class="line">ffi_type* ret_type = &amp;ffi_type_double;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// One-time setup</span></div>
<div class="line">ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, 2, ret_type, args_types);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> a = 1.5, b = 2.5;</div>
<div class="line"><span class="keywordtype">void</span>* args_values[] = { &amp;a, &amp;b };</div>
<div class="line"><span class="keywordtype">double</span> result;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subsequent calls are fast</span></div>
<div class="line">ffi_call(&amp;cif, FFI_FN(add_doubles), &amp;result, args_values);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md106"></a>
The &lt;tt&gt;infix&lt;/tt&gt; Approach</h3>
<p><code>infix</code> combines the performance model of <code>libffi</code> (one-time setup) with a much higher-level, human-readable API. The key difference is the use of a simple signature string.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line"><span class="comment">// One-time setup from a simple string</span></div>
<div class="line"><a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, <span class="stringliteral">&quot;(double, double) -&gt; double&quot;</span>, (<span class="keywordtype">void</span>*)add_doubles, NULL);</div>
<div class="line"><a class="code hl_typedef" href="group__public__api.html#ga3042690c20cccd4137f134154bd62e1a">infix_cif_func</a> cif = <a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> a = 1.5, b = 2.5;</div>
<div class="line"><span class="keywordtype">void</span>* args[] = { &amp;a, &amp;b };</div>
<div class="line"><span class="keywordtype">double</span> result;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subsequent calls are very fast</span></div>
<div class="line">cif(&amp;result, args);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md107"></a>
Scenario 2: Calling a Function with a Struct</h2>
<p><b>Goal</b>: Call <code>Point move_point(Point p);</code> where <code>Point</code> is <code>{double, double}</code>. This highlights the critical differences in type systems.</p>
<h3><a class="anchor" id="autotoc_md108"></a>
The &lt;tt&gt;dyncall&lt;/tt&gt; Approach</h3>
<p><code>dyncall</code> requires manual construction of an aggregate object (<code>DCaggr</code>) to describe the struct layout. This must be done at runtime before the call.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;dyncall.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;dyncall_aggregate.h&gt;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">double</span> x, y; } Point;</div>
<div class="line">DCCallVM* vm = dcNewCallVM(4096);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Manually describe the struct layout for dyncall</span></div>
<div class="line">DCaggr* ag = dcNewAggr(2); <span class="comment">// 2 members</span></div>
<div class="line">dcAggrField(ag, DC_TYPE_DOUBLE, DC_ALIGNMENT_DOUBLE, 1); <span class="comment">// member x</span></div>
<div class="line">dcAggrField(ag, DC_TYPE_DOUBLE, DC_ALIGNMENT_DOUBLE, 1); <span class="comment">// member y</span></div>
<div class="line">dcCloseAggr(ag);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Prepare the struct data and call</span></div>
<div class="line">Point p_in = {10.0, 20.0};</div>
<div class="line">Point p_out;</div>
<div class="line">dcReset(vm);</div>
<div class="line">dcArgAggr(vm, ag, &amp;p_in);</div>
<div class="line">dcCallAggr(vm, (DCpointer)&amp;move_point, ag, &amp;p_out);</div>
<div class="line"> </div>
<div class="line">dcFreeAggr(ag);</div>
<div class="line">dcFree(vm);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md109"></a>
The &lt;tt&gt;libffi&lt;/tt&gt; Approach</h3>
<p><code>libffi</code> also requires programmatic struct definition, which is done by creating an <code>ffi_type</code> struct and an array for its elements.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ffi.h&gt;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">double</span> x, y; } Point;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Manually define the struct layout for libffi</span></div>
<div class="line">ffi_type point_elements[] = { &amp;ffi_type_double, &amp;ffi_type_double, NULL };</div>
<div class="line">ffi_type point_type;</div>
<div class="line">point_type.size = 0; point_type.alignment = 0;</div>
<div class="line">point_type.type = FFI_TYPE_STRUCT;</div>
<div class="line">point_type.elements = point_elements;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Prepare the CIF using the new struct type</span></div>
<div class="line">ffi_cif cif;</div>
<div class="line">ffi_type* args_types[] = { &amp;point_type };</div>
<div class="line">ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, 1, &amp;point_type, args_types);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Prepare args and call</span></div>
<div class="line">Point p_in = {10.0, 20.0};</div>
<div class="line">Point p_out;</div>
<div class="line"><span class="keywordtype">void</span>* args_values[] = { &amp;p_in };</div>
<div class="line">ffi_call(&amp;cif, FFI_FN(move_point), &amp;p_out, args_values);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md110"></a>
The &lt;tt&gt;infix&lt;/tt&gt; Approach</h3>
<p><code>infix</code> handles the entire struct definition within the signature string, making the C code for the FFI call trivial and declarative.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">double</span> x, y; } Point;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Describe the struct and function in one line.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* signature = <span class="stringliteral">&quot;({double, double}) -&gt; {double, double}&quot;</span>;</div>
<div class="line"><a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* t = NULL;</div>
<div class="line"><a class="code hl_function" href="group__high__level__api.html#ga5362b6f6976298aebefdb2a487e72e36">infix_forward_create</a>(&amp;t, signature, (<span class="keywordtype">void</span>*)move_point, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Prepare args and call.</span></div>
<div class="line">Point p_in = {10.0, 20.0};</div>
<div class="line">Point p_out;</div>
<div class="line"><span class="keywordtype">void</span>* args[] = { &amp;p_in };</div>
<div class="line"><a class="code hl_function" href="group__introspection__api.html#ga32fc7e60dd474cebc4ac082e49ac9ea8">infix_forward_get_code</a>(t)(&amp;p_out, args);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>(t);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md111"></a>
Scenario 3: Creating a Callback</h2>
<p><b>Goal</b>: Create a native C function pointer from a custom handler to be used by <code>qsort</code>.</p>
<h3><a class="anchor" id="autotoc_md112"></a>
The &lt;tt&gt;dyncall&lt;/tt&gt; Approach</h3>
<p><code>dyncallback</code> requires creating a <code>DCCallback</code> object and initializing it with a C function that uses a special <code>dcbArg*</code> API to retrieve arguments one by one.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;dyncall_callback.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. The handler uses the dyncallback API to get arguments.</span></div>
<div class="line"><span class="keywordtype">void</span> qsort_handler_dc(DCCallback* cb, DCArgs* args, DCValue* result, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>* a = (<span class="keyword">const</span> <span class="keywordtype">int</span>*)dcbArgPointer(args);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>* b = (<span class="keyword">const</span> <span class="keywordtype">int</span>*)dcbArgPointer(args);</div>
<div class="line">    result-&gt;i = (*a - *b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Create the callback object.</span></div>
<div class="line">DCCallback* cb = dcbNewCallback(<span class="stringliteral">&quot;pp)i&quot;</span>, &amp;qsort_handler_dc, NULL);</div>
<div class="line">qsort(numbers, 5, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), (<span class="keywordtype">void</span>*)cb);</div>
<div class="line">dcbFree(cb);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md113"></a>
The &lt;tt&gt;libffi&lt;/tt&gt; Approach</h3>
<p><code>libffi</code> can create a "closure" which is a block of executable memory that acts as the C function pointer. The handler receives arguments via <code>ffi_call</code>-style arrays.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ffi.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. The handler receives arguments in libffi&#39;s generic format.</span></div>
<div class="line"><span class="keywordtype">void</span> qsort_handler_ffi(ffi_cif* cif, <span class="keywordtype">void</span>* ret, <span class="keywordtype">void</span>** args, <span class="keywordtype">void</span>* userdata) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>* a = *(<span class="keyword">const</span> <span class="keywordtype">int</span>**)args;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>* b = *(<span class="keyword">const</span> <span class="keywordtype">int</span>**)args;</div>
<div class="line">    *(ffi_sarg*)ret = (*a - *b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Prepare the CIF for the callback&#39;s signature.</span></div>
<div class="line">ffi_cif cif;</div>
<div class="line">ffi_type* args_types[] = { &amp;ffi_type_pointer, &amp;ffi_type_pointer };</div>
<div class="line">ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, 2, &amp;ffi_type_sint, args_types);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Allocate and create the closure.</span></div>
<div class="line"><span class="keywordtype">void</span>* func_ptr = NULL;</div>
<div class="line">ffi_closure* closure = ffi_closure_alloc(<span class="keyword">sizeof</span>(ffi_closure), &amp;func_ptr);</div>
<div class="line">ffi_prep_closure_loc(closure, &amp;cif, qsort_handler_ffi, NULL, func_ptr);</div>
<div class="line">qsort(numbers, 5, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), (<span class="keywordtype">void</span>*)func_ptr);</div>
<div class="line">ffi_closure_free(closure);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md114"></a>
The &lt;tt&gt;infix&lt;/tt&gt; Approach</h3>
<p><code>infix</code> generates a reverse trampoline. The handler is a normal C function that receives its arguments directly, prefixed by the <code>infix_context_t*</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. The handler is a standard C function with the context as the first argument.</span></div>
<div class="line"><span class="keywordtype">int</span> qsort_handler_infix(<a class="code hl_struct" href="structinfix__reverse__t.html">infix_context_t</a>* ctx, <span class="keyword">const</span> <span class="keywordtype">int</span>* a, <span class="keyword">const</span> <span class="keywordtype">int</span>* b) {</div>
<div class="line">    (void)ctx;</div>
<div class="line">    <span class="keywordflow">return</span> (*a - *b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Create the reverse trampoline from a signature.</span></div>
<div class="line"><a class="code hl_struct" href="structinfix__reverse__t.html">infix_reverse_t</a>* context = NULL;</div>
<div class="line"><a class="code hl_function" href="group__high__level__api.html#ga7d09d07b70706cb1a949e2efd5f5f471">infix_reverse_create</a>(&amp;context, <span class="stringliteral">&quot;(*void, *void)-&gt;int&quot;</span>, (<span class="keywordtype">void</span>*)qsort_handler_infix, NULL, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Get the native function pointer and use it.</span></div>
<div class="line"><span class="keyword">typedef</span> int (*compare_func_t)(<span class="keyword">const</span> <span class="keywordtype">void</span>*, <span class="keyword">const</span> <span class="keywordtype">void</span>*);</div>
<div class="line">compare_func_t my_comparator = (compare_func_t)<a class="code hl_function" href="group__introspection__api.html#ga3b75e8481ac13d11faa15046fc4adb66">infix_reverse_get_code</a>(context);</div>
<div class="line">qsort(numbers, 5, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), my_comparator);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__manual__api.html#ga00b101025663c423a28433e139be5d4e">infix_reverse_destroy</a>(context);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md115"></a>
Analysis and Takeaways</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Aspect   </th><th class="markdownTableHeadLeft"><code>dyncall</code>   </th><th class="markdownTableHeadLeft"><code>libffi</code>   </th><th class="markdownTableHeadLeft"><code>infix</code>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Readability</b>   </td><td class="markdownTableBodyLeft">Low (single-character signatures)   </td><td class="markdownTableBodyLeft">Medium (C code is clear, but type setup is verbose)   </td><td class="markdownTableBodyLeft"><b>High</b> (Human-readable, self-contained signature strings)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Performance Model</b>   </td><td class="markdownTableBodyLeft">Setup cost on <b>every call</b>   </td><td class="markdownTableBodyLeft"><b>One-time setup</b> (<code>ffi_prep_cif</code>)   </td><td class="markdownTableBodyLeft"><b>One-time setup</b> (JIT compilation)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Type System</b>   </td><td class="markdownTableBodyLeft">Programmatic, with struct support   </td><td class="markdownTableBodyLeft">Manual, programmatic <code>ffi_type</code> creation   </td><td class="markdownTableBodyLeft"><b>Integrated</b>. Types are part of the signature string, with registry support.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Ease of Use</b>   </td><td class="markdownTableBodyLeft">Simple for primitives, complex for structs   </td><td class="markdownTableBodyLeft">Complex, powerful, requires deep knowledge of the API   </td><td class="markdownTableBodyLeft"><b>Simple and Declarative</b>, designed for a high-level experience.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Callback Handler</b>   </td><td class="markdownTableBodyLeft">Special API (<code>dcbArg*</code>)   </td><td class="markdownTableBodyLeft">Generic <code>void**</code> arguments   </td><td class="markdownTableBodyLeft"><b>Native C arguments</b>, easy to read and write.   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md117"></a>
Chapter 11: Building Language Bindings</h1>
<h2><a class="anchor" id="autotoc_md118"></a>
The Four Pillars of a Language Binding</h2>
<p>A robust language binding built on <code>infix</code> must solve four main challenges:</p>
<ol type="1">
<li><b>Type Mapping &amp; Signature Generation:</b> The binding's primary job is to translate the host language's type representation (e.g., Python's <code>ctypes.c_int</code>) into an <code>infix</code> signature string.</li>
<li><b>Trampoline Caching:</b> The binding <b>must</b> implement a global, persistent cache for trampolines, using the signature string as the key, to amortize the one-time JIT compilation cost.</li>
<li><b>Memory &amp; Lifetime Management:</b> The binding must act as a bridge between the host language's Garbage Collector (GC) and C's manual memory management, holding references to objects to prevent premature collection.</li>
<li><b>The Callback Bridge:</b> A C handler must be implemented to transfer control from a native C call back into the host language's runtime, handling argument unmarshalling and potential GIL (Global Interpreter Lock) acquisition.</li>
</ol>
<h2><a class="anchor" id="autotoc_md119"></a>
Recipe: Porting a Python Binding from &lt;tt&gt;dyncall&lt;/tt&gt; to &lt;tt&gt;infix&lt;/tt&gt;</h2>
<p>This recipe demonstrates how one might port a Python binding from a library like <code>dyncall</code> to <code>infix</code>.</p>
<p><b>The <code>dyncall</code> approach</b> involves a "call virtual machine" (<code>DCCallVM*</code>) that arguments are pushed to one-by-one at call time. This is flexible but incurs overhead on every call.</p>
<p><b>The <code>infix</code> approach</b> shifts the expensive work (parsing and code generation) to a one-time setup phase, making subsequent calls much faster. The core logic of the binding becomes centered around a trampoline cache.</p>
<div class="fragment"><div class="line"><span class="comment">// Conceptual port to infix for a Python module</span></div>
<div class="line"><span class="preprocessor">#include &lt;Python.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8h.html">infix/infix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;alloca.h&gt;</span> <span class="comment">// For alloca</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A global Python dictionary to cache trampolines: { signature_str: PyCapsule(trampoline) }</span></div>
<div class="line"><span class="keyword">static</span> PyObject* g_trampoline_cache = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> PyObject* infix_python_call(PyObject* self, PyObject* py_args) {</div>
<div class="line">    PyObject* target_func_capsule = NULL;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* signature = NULL;</div>
<div class="line">    PyObject* py_func_args = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (!PyArg_ParseTuple(py_args, <span class="stringliteral">&quot;OsO!&quot;</span>, &amp;target_func_capsule, &amp;signature, &amp;PyTuple_Type, &amp;py_func_args)) <span class="keywordflow">return</span> NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span>* target_func = PyCapsule_GetPointer(target_func_capsule, NULL);</div>
<div class="line">    <span class="keywordflow">if</span>(!target_func) <span class="keywordflow">return</span> NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (g_trampoline_cache == NULL) g_trampoline_cache = PyDict_New();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1. Trampoline Caching</span></div>
<div class="line">    PyObject* signature_py = PyUnicode_FromString(signature);</div>
<div class="line">    PyObject* capsule = PyDict_GetItem(g_trampoline_cache, signature_py);</div>
<div class="line">    <a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>* trampoline = NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (capsule) {</div>
<div class="line">        trampoline = (<a class="code hl_struct" href="structinfix__forward__t.html">infix_forward_t</a>*)PyCapsule_GetPointer(capsule, <span class="stringliteral">&quot;infix_trampoline&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Not in cache: create, then store in cache via a PyCapsule.</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="group__high__level__api.html#ga524a8ccebd24c9232d30cb2f79aee5a5">infix_forward_create_unbound</a>(&amp;trampoline, signature, NULL) != <a class="code hl_enumvalue" href="group__public__api.html#gga8643667be6ea1ef9269c2e46d8f11ff7ae50c34a24362f9364b4b20ef29d259da">INFIX_SUCCESS</a>) {</div>
<div class="line">            PyErr_SetString(PyExc_RuntimeError, <span class="stringliteral">&quot;Failed to create infix trampoline.&quot;</span>);</div>
<div class="line">            Py_DECREF(signature_py);</div>
<div class="line">            <span class="keywordflow">return</span> NULL;</div>
<div class="line">        }</div>
<div class="line">        capsule = PyCapsule_New(trampoline, <span class="stringliteral">&quot;infix_trampoline&quot;</span>, (PyCapsule_Destructor)<a class="code hl_function" href="group__manual__api.html#gad87a8882dec00b89a4bc5c87db2fc032">infix_forward_destroy</a>);</div>
<div class="line">        PyDict_SetItem(g_trampoline_cache, signature_py, capsule);</div>
<div class="line">        Py_DECREF(capsule);</div>
<div class="line">    }</div>
<div class="line">    Py_DECREF(signature_py);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Argument Marshalling (simplified)</span></div>
<div class="line">    <span class="keywordtype">size_t</span> num_args = PyTuple_GET_SIZE(py_func_args);</div>
<div class="line">    <span class="keywordtype">void</span>** c_args = (<span class="keywordtype">void</span>**)alloca(<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) * num_args);</div>
<div class="line">    <span class="comment">// In a real binding, this storage would need to be managed more robustly.</span></div>
<div class="line">    <span class="keywordtype">void</span>* storage = alloca(1024);</div>
<div class="line">    <span class="keywordtype">char</span>* storage_ptr = (<span class="keywordtype">char</span>*)storage;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; num_args; ++i) {</div>
<div class="line">        PyObject* py_arg = PyTuple_GET_ITEM(py_func_args, i);</div>
<div class="line">        <span class="keywordflow">if</span> (PyLong_Check(py_arg)) {</div>
<div class="line">            <span class="keywordtype">long</span>* val = (<span class="keywordtype">long</span>*)storage_ptr; *val = PyLong_AsLong(py_arg);</div>
<div class="line">            c_args[i] = val; storage_ptr += <span class="keyword">sizeof</span>(long);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PyFloat_Check(py_arg)) {</div>
<div class="line">            <span class="keywordtype">double</span>* val = (<span class="keywordtype">double</span>*)storage_ptr; *val = PyFloat_AsDouble(py_arg);</div>
<div class="line">            c_args[i] = val; storage_ptr += <span class="keyword">sizeof</span>(double);</div>
<div class="line">        } <span class="comment">// ... etc.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. The FFI Call</span></div>
<div class="line">    <a class="code hl_typedef" href="group__public__api.html#ga48f7ee868576f525269902fc953887bd">infix_unbound_cif_func</a> cif = <a class="code hl_function" href="group__introspection__api.html#ga5f3559908e6a7bcc72103c52937d67ad">infix_forward_get_unbound_code</a>(trampoline);</div>
<div class="line">    <span class="comment">// A real binding would inspect the signature to handle the return value.</span></div>
<div class="line">    cif(target_func, NULL, c_args);</div>
<div class="line"> </div>
<div class="line">    Py_RETURN_NONE;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
