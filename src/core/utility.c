/**
 * Copyright (c) 2025 Sanko Robinson
 *
 * This source code is dual-licensed under the Artistic License 2.0 or the MIT License.
 * You may choose to use this code under the terms of either license.
 *
 * SPDX-License-Identifier: (Artistic-2.0 OR MIT)
 *
 * The documentation blocks within this file are licensed under the
 * Creative Commons Attribution 4.0 International License (CC BY 4.0).
 *
 * SPDX-License-Identifier: CC-BY-4.0
 */
/**
 * @file utility.c
 * @brief Implementation of debugging utility functions.
 *
 * @details This file provides the implementation for debugging helper functions,
 * such as `infix_dump_hex`. The content is conditionally compiled based on INFIX_DEBUG_ENABLED.
 *
 * It is also conditionally aware of DBLTAP_ENABLE. If the test harness is active,
 * it routes its output through the harness's `note()` macro. Otherwise, it falls
 * back to standard printf, making it safe to link into executables that do not
 * use the double_tap framework.
 */

#if defined(INFIX_DEBUG_ENABLED) && INFIX_DEBUG_ENABLED

// Only include and use double_tap if the DBLTAP_IMPLEMENTATION macro is also
// defined. This prevents the core library from accidentally compiling in a
// dependency on the test framework's symbols.
#if defined(DBLTAP_ENABLE) && defined(DBLTAP_IMPLEMENTATION)
#include "common/double_tap.h"
#else
// Otherwise, define a simple printf-based fallback for note().
#include <stdio.h>
#define note(...)                 \
    do {                          \
        printf("# " __VA_ARGS__); \
        printf("\n");             \
    } while (0)
#endif

#include "common/utility.h"
#include <inttypes.h>

/**
 * @brief Prints a detailed hexadecimal and ASCII dump of a memory region.
 *
 * @details This function generates a human-readable "hexdump" of a block of
 * memory, which is invaluable for debugging the raw machine code generated by
 * the JIT compiler. The output is formatted into lines of 16 bytes, showing
 * the offset, hexadecimal values, and ASCII representation.
 *
 * @note This function is only available in debug builds (when `INFIX_DEBUG_ENABLED`
 * is active).
 *
 * @param data A pointer to the start of the memory block to dump.
 * @param size The number of bytes to dump.
 * @param title A descriptive title to print before and after the hex dump.
 */
void infix_dump_hex(const void * data, size_t size, const char * title) {
    const uint8_t * byte = (const uint8_t *)data;
    char line_buf[256];
    char * buf_ptr;
    size_t remaining_len;
    int written;

    // Print header with title and size.
    note("%s (size: %llu bytes)", title, (unsigned long long)size);

    for (size_t i = 0; i < size; i += 16) {
        buf_ptr = line_buf;
        remaining_len = sizeof(line_buf);

        // Print the current offset within the data block.
        written = snprintf(buf_ptr, remaining_len, "0x%04llx: ", (unsigned long long)i);
        if (written < 0 || (size_t)written >= remaining_len)
            goto print_line;  // Buffer full or error
        buf_ptr += written;
        remaining_len -= written;

        // Print 16 bytes in hexadecimal representation.
        for (size_t j = 0; j < 16; ++j) {
            if (i + j < size)
                written = snprintf(buf_ptr, remaining_len, "%02x ", byte[i + j]);
            else
                written = snprintf(buf_ptr, remaining_len, "   ");  // Pad if at the end.
            if (written < 0 || (size_t)written >= remaining_len)
                goto print_line;
            buf_ptr += written;
            remaining_len -= written;

            if (j == 7) {  // Add extra space in the middle for readability.
                written = snprintf(buf_ptr, remaining_len, " ");
                if (written < 0 || (size_t)written >= remaining_len)
                    goto print_line;
                buf_ptr += written;
                remaining_len -= written;
            }
        }

        written = snprintf(buf_ptr, remaining_len, "| ");
        if (written < 0 || (size_t)written >= remaining_len)
            goto print_line;
        buf_ptr += written;
        remaining_len -= written;

        // Print the ASCII representation of the 16 bytes.
        for (size_t j = 0; j < 16; ++j) {
            if (i + j < size) {
                // Use a '.' for non-printable characters.
                if (byte[i + j] >= 32 && byte[i + j] <= 126)
                    written = snprintf(buf_ptr, remaining_len, "%c", byte[i + j]);
                else
                    written = snprintf(buf_ptr, remaining_len, ".");
                if (written < 0 || (size_t)written >= remaining_len)
                    goto print_line;
                buf_ptr += written;
                remaining_len -= written;
            }
        }

print_line:
        // Output the fully formatted (or partially formatted, if truncated) line.
        // snprintf guarantees null-termination if the buffer size is > 0.
        note("  %s", line_buf);
    }
    note("End of %s", title);
}
#endif  // INFIX_DEBUG_ENABLED
